{"ast":null,"code":"'use strict';\n\nconst Block = require('ipld-block');\n\nconst multihashing = require('multihashing-async');\n\nconst CID = require('cids');\n\nconst isIPFS = require('is-ipfs');\n\nconst {\n  withTimeoutOption\n} = require('../../utils');\n/**\n * @typedef {import('cids')} CID\n * @typedef {import('ipld-block')} Block\n * @typedef {0 | 1} CidVersion\n */\n\n/**\n * @typedef {object} BlockPutOptions\n * @property {CID} [cid] - A CID to store the block under (default: `undefined`)\n * @property {string} [format] - The codec to use to create the CID (default: `'dag-pb'`)\n * @property {string} [mhtype] - The hashing algorithm to use to create the CID (default: `'sha2-256'`)\n * @property {number} [mhlen]\n * @property {CidVersion} [version] - The version to use to create the CID (default: `0`)\n * @property {boolean} [pin] - If true, pin added blocks recursively (default: `false`)\n */\n\n/**\n * Stores input as an IPFS block.\n * @template {Record<string, any>} ExtraOptions\n * @callback BlockPut\n * @param {Buffer | Block} block - The block or data to store\n * @param {BlockPutOptions & import('../../utils').AbortOptions & ExtraOptions} [options] - **Note:** If you pass a `Block` instance as the block parameter, you don't need to pass options, as the block instance will carry the CID value as a property.\n * @returns {Promise<Block>} - A Block type object, containing both the data and the hash of the block\n */\n\n\nmodule.exports = ({\n  blockService,\n  pin,\n  gcLock,\n  preload\n}) => {\n  // eslint-disable-next-line valid-jsdoc\n\n  /**\n   * @type {BlockPut<import('./get').PreloadOptions>}\n   */\n  async function put(block, options) {\n    options = options || {};\n\n    if (Array.isArray(block)) {\n      throw new Error('Array is not supported');\n    }\n\n    if (!Block.isBlock(block)) {\n      if (options.cid && isIPFS.cid(options.cid)) {\n        block = new Block(block, CID.isCID(options.cid) ? options.cid : new CID(options.cid));\n      } else {\n        const mhtype = options.mhtype || 'sha2-256';\n        const format = options.format || 'dag-pb';\n        /** @type {CidVersion} */\n\n        let cidVersion;\n\n        if (options.version == null) {\n          // Pick appropriate CID version\n          cidVersion = mhtype === 'sha2-256' && format === 'dag-pb' ? 0 : 1;\n        } else {\n          cidVersion = options.version;\n        }\n\n        const multihash = await multihashing(block, mhtype);\n        const cid = new CID(cidVersion, format, multihash);\n        block = new Block(block, cid);\n      }\n    }\n\n    const release = await gcLock.readLock();\n\n    try {\n      await blockService.put(block, {\n        signal: options.signal\n      });\n\n      if (options.preload !== false) {\n        preload(block.cid);\n      }\n\n      if (options.pin === true) {\n        await pin.add(block.cid, {\n          recursive: true,\n          signal: options.signal\n        });\n      }\n\n      return block;\n    } finally {\n      release();\n    }\n  }\n\n  return withTimeoutOption(put);\n};","map":{"version":3,"sources":["/home/user/orbit-playground/music-app/node_modules/ipfs/src/core/components/block/put.js"],"names":["Block","require","multihashing","CID","isIPFS","withTimeoutOption","module","exports","blockService","pin","gcLock","preload","put","block","options","Array","isArray","Error","isBlock","cid","isCID","mhtype","format","cidVersion","version","multihash","release","readLock","signal","add","recursive"],"mappings":"AAAA;;AAEA,MAAMA,KAAK,GAAGC,OAAO,CAAC,YAAD,CAArB;;AACA,MAAMC,YAAY,GAAGD,OAAO,CAAC,oBAAD,CAA5B;;AACA,MAAME,GAAG,GAAGF,OAAO,CAAC,MAAD,CAAnB;;AACA,MAAMG,MAAM,GAAGH,OAAO,CAAC,SAAD,CAAtB;;AACA,MAAM;AAAEI,EAAAA;AAAF,IAAwBJ,OAAO,CAAC,aAAD,CAArC;AAEA;;;;;;AAMA;;;;;;;;;;AAUA;;;;;;;;;;AASAK,MAAM,CAACC,OAAP,GAAiB,CAAC;AAAEC,EAAAA,YAAF;AAAgBC,EAAAA,GAAhB;AAAqBC,EAAAA,MAArB;AAA6BC,EAAAA;AAA7B,CAAD,KAA4C;AAC3D;;AACA;;;AAGA,iBAAeC,GAAf,CAAoBC,KAApB,EAA2BC,OAA3B,EAAoC;AAClCA,IAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;;AAEA,QAAIC,KAAK,CAACC,OAAN,CAAcH,KAAd,CAAJ,EAA0B;AACxB,YAAM,IAAII,KAAJ,CAAU,wBAAV,CAAN;AACD;;AAED,QAAI,CAACjB,KAAK,CAACkB,OAAN,CAAcL,KAAd,CAAL,EAA2B;AACzB,UAAIC,OAAO,CAACK,GAAR,IAAef,MAAM,CAACe,GAAP,CAAWL,OAAO,CAACK,GAAnB,CAAnB,EAA4C;AAC1CN,QAAAA,KAAK,GAAG,IAAIb,KAAJ,CAAUa,KAAV,EAAiBV,GAAG,CAACiB,KAAJ,CAAUN,OAAO,CAACK,GAAlB,IAAyBL,OAAO,CAACK,GAAjC,GAAuC,IAAIhB,GAAJ,CAAQW,OAAO,CAACK,GAAhB,CAAxD,CAAR;AACD,OAFD,MAEO;AACL,cAAME,MAAM,GAAGP,OAAO,CAACO,MAAR,IAAkB,UAAjC;AACA,cAAMC,MAAM,GAAGR,OAAO,CAACQ,MAAR,IAAkB,QAAjC;AAEA;;AACA,YAAIC,UAAJ;;AAEA,YAAIT,OAAO,CAACU,OAAR,IAAmB,IAAvB,EAA6B;AAC3B;AACAD,UAAAA,UAAU,GAAGF,MAAM,KAAK,UAAX,IAAyBC,MAAM,KAAK,QAApC,GAA+C,CAA/C,GAAmD,CAAhE;AACD,SAHD,MAGO;AACLC,UAAAA,UAAU,GAAGT,OAAO,CAACU,OAArB;AACD;;AAED,cAAMC,SAAS,GAAG,MAAMvB,YAAY,CAACW,KAAD,EAAQQ,MAAR,CAApC;AACA,cAAMF,GAAG,GAAG,IAAIhB,GAAJ,CAAQoB,UAAR,EAAoBD,MAApB,EAA4BG,SAA5B,CAAZ;AAEAZ,QAAAA,KAAK,GAAG,IAAIb,KAAJ,CAAUa,KAAV,EAAiBM,GAAjB,CAAR;AACD;AACF;;AAED,UAAMO,OAAO,GAAG,MAAMhB,MAAM,CAACiB,QAAP,EAAtB;;AAEA,QAAI;AACF,YAAMnB,YAAY,CAACI,GAAb,CAAiBC,KAAjB,EAAwB;AAC5Be,QAAAA,MAAM,EAAEd,OAAO,CAACc;AADY,OAAxB,CAAN;;AAIA,UAAId,OAAO,CAACH,OAAR,KAAoB,KAAxB,EAA+B;AAC7BA,QAAAA,OAAO,CAACE,KAAK,CAACM,GAAP,CAAP;AACD;;AAED,UAAIL,OAAO,CAACL,GAAR,KAAgB,IAApB,EAA0B;AACxB,cAAMA,GAAG,CAACoB,GAAJ,CAAQhB,KAAK,CAACM,GAAd,EAAmB;AACvBW,UAAAA,SAAS,EAAE,IADY;AAEvBF,UAAAA,MAAM,EAAEd,OAAO,CAACc;AAFO,SAAnB,CAAN;AAID;;AAED,aAAOf,KAAP;AACD,KAjBD,SAiBU;AACRa,MAAAA,OAAO;AACR;AACF;;AAED,SAAOrB,iBAAiB,CAACO,GAAD,CAAxB;AACD,CA7DD","sourcesContent":["'use strict'\n\nconst Block = require('ipld-block')\nconst multihashing = require('multihashing-async')\nconst CID = require('cids')\nconst isIPFS = require('is-ipfs')\nconst { withTimeoutOption } = require('../../utils')\n\n/**\n * @typedef {import('cids')} CID\n * @typedef {import('ipld-block')} Block\n * @typedef {0 | 1} CidVersion\n */\n\n/**\n * @typedef {object} BlockPutOptions\n * @property {CID} [cid] - A CID to store the block under (default: `undefined`)\n * @property {string} [format] - The codec to use to create the CID (default: `'dag-pb'`)\n * @property {string} [mhtype] - The hashing algorithm to use to create the CID (default: `'sha2-256'`)\n * @property {number} [mhlen]\n * @property {CidVersion} [version] - The version to use to create the CID (default: `0`)\n * @property {boolean} [pin] - If true, pin added blocks recursively (default: `false`)\n */\n\n/**\n * Stores input as an IPFS block.\n * @template {Record<string, any>} ExtraOptions\n * @callback BlockPut\n * @param {Buffer | Block} block - The block or data to store\n * @param {BlockPutOptions & import('../../utils').AbortOptions & ExtraOptions} [options] - **Note:** If you pass a `Block` instance as the block parameter, you don't need to pass options, as the block instance will carry the CID value as a property.\n * @returns {Promise<Block>} - A Block type object, containing both the data and the hash of the block\n */\n\nmodule.exports = ({ blockService, pin, gcLock, preload }) => {\n  // eslint-disable-next-line valid-jsdoc\n  /**\n   * @type {BlockPut<import('./get').PreloadOptions>}\n   */\n  async function put (block, options) {\n    options = options || {}\n\n    if (Array.isArray(block)) {\n      throw new Error('Array is not supported')\n    }\n\n    if (!Block.isBlock(block)) {\n      if (options.cid && isIPFS.cid(options.cid)) {\n        block = new Block(block, CID.isCID(options.cid) ? options.cid : new CID(options.cid))\n      } else {\n        const mhtype = options.mhtype || 'sha2-256'\n        const format = options.format || 'dag-pb'\n\n        /** @type {CidVersion} */\n        let cidVersion\n\n        if (options.version == null) {\n          // Pick appropriate CID version\n          cidVersion = mhtype === 'sha2-256' && format === 'dag-pb' ? 0 : 1\n        } else {\n          cidVersion = options.version\n        }\n\n        const multihash = await multihashing(block, mhtype)\n        const cid = new CID(cidVersion, format, multihash)\n\n        block = new Block(block, cid)\n      }\n    }\n\n    const release = await gcLock.readLock()\n\n    try {\n      await blockService.put(block, {\n        signal: options.signal\n      })\n\n      if (options.preload !== false) {\n        preload(block.cid)\n      }\n\n      if (options.pin === true) {\n        await pin.add(block.cid, {\n          recursive: true,\n          signal: options.signal\n        })\n      }\n\n      return block\n    } finally {\n      release()\n    }\n  }\n\n  return withTimeoutOption(put)\n}\n"]},"metadata":{},"sourceType":"script"}