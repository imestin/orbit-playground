{"ast":null,"code":"'use strict';\n\nconst toUri = require('multiaddr-to-uri');\n\nconst debug = require('debug');\n\nconst CID = require('cids');\n\nconst shuffle = require('array-shuffle');\n\nconst AbortController = require('abort-controller').default;\n\nconst preload = require('./runtime/preload-nodejs');\n\nconst log = Object.assign(debug('ipfs:preload'), {\n  error: debug('ipfs:preload:error')\n});\n\nmodule.exports = options => {\n  options = options || {};\n  options.enabled = Boolean(options.enabled);\n  options.addresses = options.addresses || [];\n\n  if (!options.enabled || !options.addresses.length) {\n    log('preload disabled');\n\n    const api = () => {};\n\n    return Object.assign(api, {\n      start: () => {},\n      stop: () => {}\n    });\n  }\n\n  let stopped = true;\n  let requests = [];\n  const apiUris = options.addresses.map(toUri);\n\n  const api = async path => {\n    try {\n      if (stopped) throw new Error(`preload ${path} but preloader is not started`);\n\n      if (typeof path !== 'string') {\n        path = new CID(path).toString();\n      }\n\n      const fallbackApiUris = shuffle(apiUris);\n      let success = false;\n      const now = Date.now();\n\n      for (const uri of fallbackApiUris) {\n        if (stopped) throw new Error(`preload aborted for ${path}`);\n        let controller;\n\n        try {\n          controller = new AbortController();\n          requests = requests.concat(controller);\n          await preload(`${uri}/api/v0/refs?r=true&arg=${encodeURIComponent(path)}`, {\n            signal: controller.signal\n          });\n          success = true;\n        } catch (err) {\n          if (err.type !== 'aborted') log.error(err);\n        } finally {\n          requests = requests.filter(r => r !== controller);\n        }\n\n        if (success) break;\n      }\n\n      log(`${success ? '' : 'un'}successfully preloaded ${path} in ${Date.now() - now}ms`);\n    } catch (err) {\n      log.error(err);\n    }\n  };\n\n  api.start = () => {\n    stopped = false;\n  };\n\n  api.stop = () => {\n    stopped = true;\n    log(`aborting ${requests.length} pending preload request(s)`);\n    requests.forEach(r => r.abort());\n    requests = [];\n  };\n\n  return api;\n};","map":{"version":3,"sources":["/home/user/orbit-playground/music-app/node_modules/ipfs/src/core/preload.js"],"names":["toUri","require","debug","CID","shuffle","AbortController","default","preload","log","Object","assign","error","module","exports","options","enabled","Boolean","addresses","length","api","start","stop","stopped","requests","apiUris","map","path","Error","toString","fallbackApiUris","success","now","Date","uri","controller","concat","encodeURIComponent","signal","err","type","filter","r","forEach","abort"],"mappings":"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","sourcesContent":["'use strict'\n\nconst toUri = require('multiaddr-to-uri')\nconst debug = require('debug')\nconst CID = require('cids')\nconst shuffle = require('array-shuffle')\nconst AbortController = require('abort-controller').default\nconst preload = require('./runtime/preload-nodejs')\n\nconst log = Object.assign(\n  debug('ipfs:preload'),\n  { error: debug('ipfs:preload:error') }\n)\n\nmodule.exports = options => {\n  options = options || {}\n  options.enabled = Boolean(options.enabled)\n  options.addresses = options.addresses || []\n\n  if (!options.enabled || !options.addresses.length) {\n    log('preload disabled')\n    const api = () => {}\n    return Object.assign(api, {\n      start: () => {},\n      stop: () => {}\n    })\n  }\n\n  let stopped = true\n  let requests = []\n  const apiUris = options.addresses.map(toUri)\n\n  const api = async path => {\n    try {\n      if (stopped) throw new Error(`preload ${path} but preloader is not started`)\n\n      if (typeof path !== 'string') {\n        path = new CID(path).toString()\n      }\n\n      const fallbackApiUris = shuffle(apiUris)\n      let success = false\n      const now = Date.now()\n\n      for (const uri of fallbackApiUris) {\n        if (stopped) throw new Error(`preload aborted for ${path}`)\n        let controller\n\n        try {\n          controller = new AbortController()\n          requests = requests.concat(controller)\n          await preload(`${uri}/api/v0/refs?r=true&arg=${encodeURIComponent(path)}`, { signal: controller.signal })\n          success = true\n        } catch (err) {\n          if (err.type !== 'aborted') log.error(err)\n        } finally {\n          requests = requests.filter(r => r !== controller)\n        }\n\n        if (success) break\n      }\n\n      log(`${success ? '' : 'un'}successfully preloaded ${path} in ${Date.now() - now}ms`)\n    } catch (err) {\n      log.error(err)\n    }\n  }\n\n  api.start = () => {\n    stopped = false\n  }\n\n  api.stop = () => {\n    stopped = true\n    log(`aborting ${requests.length} pending preload request(s)`)\n    requests.forEach(r => r.abort())\n    requests = []\n  }\n\n  return api\n}\n"]},"metadata":{},"sourceType":"script"}