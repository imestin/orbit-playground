{"ast":null,"code":"'use strict';\n\nconst loadMfsRoot = require('./with-mfs-root');\n\nconst toPathComponents = require('./to-path-components');\n\nconst exporter = require('ipfs-unixfs-exporter');\n\nconst errCode = require('err-code');\n\nconst CID = require('cids');\n\nconst IPFS_PREFIX = 'ipfs';\n\nconst toMfsPath = async (context, path, options) => {\n  const outputArray = Array.isArray(path);\n  let paths = Array.isArray(path) ? path : [path];\n  const root = await loadMfsRoot(context, options);\n  paths = paths.map(path => {\n    if (CID.isCID(path)) {\n      path = `/ipfs/${path}`;\n    }\n\n    path = (path || '').trim();\n    path = path.replace(/(\\/\\/+)/g, '/');\n\n    if (path.endsWith('/') && path.length > 1) {\n      path = path.substring(0, path.length - 1);\n    }\n\n    if (!path) {\n      throw errCode(new Error('paths must not be empty'), 'ERR_NO_PATH');\n    }\n\n    if (path.substring(0, 1) !== '/') {\n      throw errCode(new Error('paths must start with a leading slash'), 'ERR_INVALID_PATH');\n    }\n\n    if (path.substring(path.length - 1) === '/') {\n      path = path.substring(0, path.length - 1);\n    }\n\n    const pathComponents = toPathComponents(path);\n\n    if (pathComponents[0] === IPFS_PREFIX) {\n      // e.g. /ipfs/QMfoo or /ipfs/Qmfoo/sub/path\n      let mfsDirectory;\n\n      if (pathComponents.length === 2) {\n        mfsDirectory = `/${pathComponents.join('/')}`;\n      } else {\n        mfsDirectory = `/${pathComponents.slice(0, pathComponents.length - 1).join('/')}`;\n      }\n\n      return {\n        type: 'ipfs',\n        depth: pathComponents.length - 2,\n        mfsPath: `/${pathComponents.join('/')}`,\n        mfsDirectory,\n        parts: pathComponents,\n        path: `/${pathComponents.join('/')}`,\n        name: pathComponents[pathComponents.length - 1]\n      };\n    }\n\n    const mfsPath = `/${IPFS_PREFIX}/${root}${pathComponents.length ? '/' + pathComponents.join('/') : ''}`;\n    const mfsDirectory = `/${IPFS_PREFIX}/${root}/${pathComponents.slice(0, pathComponents.length - 1).join('/')}`;\n    return {\n      type: 'mfs',\n      depth: pathComponents.length,\n      mfsDirectory,\n      mfsPath,\n      parts: pathComponents,\n      path: `/${pathComponents.join('/')}`,\n      name: pathComponents[pathComponents.length - 1]\n    };\n  });\n  await Promise.all(paths.map(async path => {\n    const cidPath = path.type === 'mfs' ? path.mfsPath : path.path;\n\n    try {\n      const res = await exporter(cidPath, context.ipld);\n      path.cid = res.cid;\n      path.mfsPath = `/ipfs/${res.path}`;\n      path.unixfs = res.unixfs;\n      path.content = res.content;\n    } catch (err) {\n      if (err.code !== 'ERR_NOT_FOUND') {\n        throw err;\n      }\n    }\n\n    path.exists = Boolean(path.cid);\n  }));\n\n  if (outputArray) {\n    return paths;\n  }\n\n  return paths[0];\n};\n\nmodule.exports = toMfsPath;","map":{"version":3,"sources":["/home/user/orbit-playground/music-app/node_modules/ipfs/src/core/components/files/utils/to-mfs-path.js"],"names":["loadMfsRoot","require","toPathComponents","exporter","errCode","CID","IPFS_PREFIX","toMfsPath","context","path","options","outputArray","Array","isArray","paths","root","map","isCID","trim","replace","endsWith","length","substring","Error","pathComponents","mfsDirectory","join","slice","type","depth","mfsPath","parts","name","Promise","all","cidPath","res","ipld","cid","unixfs","content","err","code","exists","Boolean","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst loadMfsRoot = require('./with-mfs-root')\nconst toPathComponents = require('./to-path-components')\nconst exporter = require('ipfs-unixfs-exporter')\nconst errCode = require('err-code')\nconst CID = require('cids')\n\nconst IPFS_PREFIX = 'ipfs'\n\nconst toMfsPath = async (context, path, options) => {\n  const outputArray = Array.isArray(path)\n  let paths = Array.isArray(path) ? path : [path]\n  const root = await loadMfsRoot(context, options)\n\n  paths = paths.map(path => {\n    if (CID.isCID(path)) {\n      path = `/ipfs/${path}`\n    }\n\n    path = (path || '').trim()\n    path = path.replace(/(\\/\\/+)/g, '/')\n\n    if (path.endsWith('/') && path.length > 1) {\n      path = path.substring(0, path.length - 1)\n    }\n\n    if (!path) {\n      throw errCode(new Error('paths must not be empty'), 'ERR_NO_PATH')\n    }\n\n    if (path.substring(0, 1) !== '/') {\n      throw errCode(new Error('paths must start with a leading slash'), 'ERR_INVALID_PATH')\n    }\n\n    if (path.substring(path.length - 1) === '/') {\n      path = path.substring(0, path.length - 1)\n    }\n\n    const pathComponents = toPathComponents(path)\n\n    if (pathComponents[0] === IPFS_PREFIX) {\n      // e.g. /ipfs/QMfoo or /ipfs/Qmfoo/sub/path\n      let mfsDirectory\n\n      if (pathComponents.length === 2) {\n        mfsDirectory = `/${pathComponents.join('/')}`\n      } else {\n        mfsDirectory = `/${pathComponents.slice(0, pathComponents.length - 1).join('/')}`\n      }\n\n      return {\n        type: 'ipfs',\n        depth: pathComponents.length - 2,\n\n        mfsPath: `/${pathComponents.join('/')}`,\n        mfsDirectory,\n        parts: pathComponents,\n        path: `/${pathComponents.join('/')}`,\n        name: pathComponents[pathComponents.length - 1]\n      }\n    }\n\n    const mfsPath = `/${IPFS_PREFIX}/${root}${pathComponents.length ? '/' + pathComponents.join('/') : ''}`\n    const mfsDirectory = `/${IPFS_PREFIX}/${root}/${pathComponents.slice(0, pathComponents.length - 1).join('/')}`\n\n    return {\n      type: 'mfs',\n      depth: pathComponents.length,\n\n      mfsDirectory,\n      mfsPath,\n      parts: pathComponents,\n      path: `/${pathComponents.join('/')}`,\n      name: pathComponents[pathComponents.length - 1]\n    }\n  })\n\n  await Promise.all(\n    paths.map(async (path) => {\n      const cidPath = path.type === 'mfs' ? path.mfsPath : path.path\n\n      try {\n        const res = await exporter(cidPath, context.ipld)\n\n        path.cid = res.cid\n        path.mfsPath = `/ipfs/${res.path}`\n        path.unixfs = res.unixfs\n        path.content = res.content\n      } catch (err) {\n        if (err.code !== 'ERR_NOT_FOUND') {\n          throw err\n        }\n      }\n\n      path.exists = Boolean(path.cid)\n    })\n  )\n\n  if (outputArray) {\n    return paths\n  }\n\n  return paths[0]\n}\n\nmodule.exports = toMfsPath\n"]},"metadata":{},"sourceType":"script"}