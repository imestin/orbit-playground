{"ast":null,"code":"'use strict';\n\nconst sha = require('multihashing-async/src/sha');\n\nconst protobuf = require('protons');\n\nconst multibase = require('multibase');\n\nconst errcode = require('err-code');\n\nconst uint8ArrayEquals = require('uint8arrays/equals');\n\nconst crypto = require('./ed25519');\n\nconst pbm = protobuf(require('./keys.proto'));\n\nconst exporter = require('./exporter');\n\nclass Ed25519PublicKey {\n  constructor(key) {\n    this._key = ensureKey(key, crypto.publicKeyLength);\n  }\n\n  async verify(data, sig) {\n    // eslint-disable-line require-await\n    return crypto.hashAndVerify(this._key, sig, data);\n  }\n\n  marshal() {\n    return this._key;\n  }\n\n  get bytes() {\n    return pbm.PublicKey.encode({\n      Type: pbm.KeyType.Ed25519,\n      Data: this.marshal()\n    });\n  }\n\n  equals(key) {\n    return uint8ArrayEquals(this.bytes, key.bytes);\n  }\n\n  async hash() {\n    // eslint-disable-line require-await\n    return sha.multihashing(this.bytes, 'sha2-256');\n  }\n\n}\n\nclass Ed25519PrivateKey {\n  // key       - 64 byte Uint8Array containing private key\n  // publicKey - 32 byte Uint8Array containing public key\n  constructor(key, publicKey) {\n    this._key = ensureKey(key, crypto.privateKeyLength);\n    this._publicKey = ensureKey(publicKey, crypto.publicKeyLength);\n  }\n\n  async sign(message) {\n    // eslint-disable-line require-await\n    return crypto.hashAndSign(this._key, message);\n  }\n\n  get public() {\n    return new Ed25519PublicKey(this._publicKey);\n  }\n\n  marshal() {\n    return this._key;\n  }\n\n  get bytes() {\n    return pbm.PrivateKey.encode({\n      Type: pbm.KeyType.Ed25519,\n      Data: this.marshal()\n    });\n  }\n\n  equals(key) {\n    return uint8ArrayEquals(this.bytes, key.bytes);\n  }\n\n  async hash() {\n    // eslint-disable-line require-await\n    return sha.multihashing(this.bytes, 'sha2-256');\n  }\n  /**\n   * Gets the ID of the key.\n   *\n   * The key id is the base58 encoding of the SHA-256 multihash of its public key.\n   * The public key is a protobuf encoding containing a type and the DER encoding\n   * of the PKCS SubjectPublicKeyInfo.\n   *\n   * @returns {Promise<String>}\n   */\n\n\n  async id() {\n    const hash = await this.public.hash();\n    return multibase.encode('base58btc', hash).toString().slice(1);\n  }\n  /**\n   * Exports the key into a password protected `format`\n   *\n   * @param {string} password - The password to encrypt the key\n   * @param {string} [format=libp2p-key] - The format in which to export as\n   * @returns {Promise<Uint8Array>} The encrypted private key\n   */\n\n\n  async export(password, format = 'libp2p-key') {\n    // eslint-disable-line require-await\n    if (format === 'libp2p-key') {\n      return exporter.export(this.bytes, password);\n    } else {\n      throw errcode(new Error(`export format '${format}' is not supported`), 'ERR_INVALID_EXPORT_FORMAT');\n    }\n  }\n\n}\n\nfunction unmarshalEd25519PrivateKey(bytes) {\n  // Try the old, redundant public key version\n  if (bytes.length > crypto.privateKeyLength) {\n    bytes = ensureKey(bytes, crypto.privateKeyLength + crypto.publicKeyLength);\n    const privateKeyBytes = bytes.slice(0, crypto.privateKeyLength);\n    const publicKeyBytes = bytes.slice(crypto.privateKeyLength, bytes.length);\n    return new Ed25519PrivateKey(privateKeyBytes, publicKeyBytes);\n  }\n\n  bytes = ensureKey(bytes, crypto.privateKeyLength);\n  const privateKeyBytes = bytes.slice(0, crypto.privateKeyLength);\n  const publicKeyBytes = bytes.slice(crypto.publicKeyLength);\n  return new Ed25519PrivateKey(privateKeyBytes, publicKeyBytes);\n}\n\nfunction unmarshalEd25519PublicKey(bytes) {\n  bytes = ensureKey(bytes, crypto.publicKeyLength);\n  return new Ed25519PublicKey(bytes);\n}\n\nasync function generateKeyPair() {\n  const {\n    privateKey,\n    publicKey\n  } = await crypto.generateKey();\n  return new Ed25519PrivateKey(privateKey, publicKey);\n}\n\nasync function generateKeyPairFromSeed(seed) {\n  const {\n    privateKey,\n    publicKey\n  } = await crypto.generateKeyFromSeed(seed);\n  return new Ed25519PrivateKey(privateKey, publicKey);\n}\n\nfunction ensureKey(key, length) {\n  key = Uint8Array.from(key || []);\n\n  if (key.length !== length) {\n    throw errcode(new Error(`Key must be a Uint8Array of length ${length}, got ${key.length}`), 'ERR_INVALID_KEY_TYPE');\n  }\n\n  return key;\n}\n\nmodule.exports = {\n  Ed25519PublicKey,\n  Ed25519PrivateKey,\n  unmarshalEd25519PrivateKey,\n  unmarshalEd25519PublicKey,\n  generateKeyPair,\n  generateKeyPairFromSeed\n};","map":{"version":3,"sources":["/home/user/orbit-playground/music-app/node_modules/libp2p-secio/node_modules/libp2p-crypto/src/keys/ed25519-class.js"],"names":["sha","require","protobuf","multibase","errcode","uint8ArrayEquals","crypto","pbm","exporter","Ed25519PublicKey","constructor","key","_key","ensureKey","publicKeyLength","verify","data","sig","hashAndVerify","marshal","bytes","PublicKey","encode","Type","KeyType","Ed25519","Data","equals","hash","multihashing","Ed25519PrivateKey","publicKey","privateKeyLength","_publicKey","sign","message","hashAndSign","public","PrivateKey","id","toString","slice","export","password","format","Error","unmarshalEd25519PrivateKey","length","privateKeyBytes","publicKeyBytes","unmarshalEd25519PublicKey","generateKeyPair","privateKey","generateKey","generateKeyPairFromSeed","seed","generateKeyFromSeed","Uint8Array","from","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst sha = require('multihashing-async/src/sha')\nconst protobuf = require('protons')\nconst multibase = require('multibase')\nconst errcode = require('err-code')\nconst uint8ArrayEquals = require('uint8arrays/equals')\n\nconst crypto = require('./ed25519')\nconst pbm = protobuf(require('./keys.proto'))\nconst exporter = require('./exporter')\n\nclass Ed25519PublicKey {\n  constructor (key) {\n    this._key = ensureKey(key, crypto.publicKeyLength)\n  }\n\n  async verify (data, sig) { // eslint-disable-line require-await\n    return crypto.hashAndVerify(this._key, sig, data)\n  }\n\n  marshal () {\n    return this._key\n  }\n\n  get bytes () {\n    return pbm.PublicKey.encode({\n      Type: pbm.KeyType.Ed25519,\n      Data: this.marshal()\n    })\n  }\n\n  equals (key) {\n    return uint8ArrayEquals(this.bytes, key.bytes)\n  }\n\n  async hash () { // eslint-disable-line require-await\n    return sha.multihashing(this.bytes, 'sha2-256')\n  }\n}\n\nclass Ed25519PrivateKey {\n  // key       - 64 byte Uint8Array containing private key\n  // publicKey - 32 byte Uint8Array containing public key\n  constructor (key, publicKey) {\n    this._key = ensureKey(key, crypto.privateKeyLength)\n    this._publicKey = ensureKey(publicKey, crypto.publicKeyLength)\n  }\n\n  async sign (message) { // eslint-disable-line require-await\n    return crypto.hashAndSign(this._key, message)\n  }\n\n  get public () {\n    return new Ed25519PublicKey(this._publicKey)\n  }\n\n  marshal () {\n    return this._key\n  }\n\n  get bytes () {\n    return pbm.PrivateKey.encode({\n      Type: pbm.KeyType.Ed25519,\n      Data: this.marshal()\n    })\n  }\n\n  equals (key) {\n    return uint8ArrayEquals(this.bytes, key.bytes)\n  }\n\n  async hash () { // eslint-disable-line require-await\n    return sha.multihashing(this.bytes, 'sha2-256')\n  }\n\n  /**\n   * Gets the ID of the key.\n   *\n   * The key id is the base58 encoding of the SHA-256 multihash of its public key.\n   * The public key is a protobuf encoding containing a type and the DER encoding\n   * of the PKCS SubjectPublicKeyInfo.\n   *\n   * @returns {Promise<String>}\n   */\n  async id () {\n    const hash = await this.public.hash()\n    return multibase.encode('base58btc', hash).toString().slice(1)\n  }\n\n  /**\n   * Exports the key into a password protected `format`\n   *\n   * @param {string} password - The password to encrypt the key\n   * @param {string} [format=libp2p-key] - The format in which to export as\n   * @returns {Promise<Uint8Array>} The encrypted private key\n   */\n  async export (password, format = 'libp2p-key') { // eslint-disable-line require-await\n    if (format === 'libp2p-key') {\n      return exporter.export(this.bytes, password)\n    } else {\n      throw errcode(new Error(`export format '${format}' is not supported`), 'ERR_INVALID_EXPORT_FORMAT')\n    }\n  }\n}\n\nfunction unmarshalEd25519PrivateKey (bytes) {\n  // Try the old, redundant public key version\n  if (bytes.length > crypto.privateKeyLength) {\n    bytes = ensureKey(bytes, crypto.privateKeyLength + crypto.publicKeyLength)\n    const privateKeyBytes = bytes.slice(0, crypto.privateKeyLength)\n    const publicKeyBytes = bytes.slice(crypto.privateKeyLength, bytes.length)\n    return new Ed25519PrivateKey(privateKeyBytes, publicKeyBytes)\n  }\n\n  bytes = ensureKey(bytes, crypto.privateKeyLength)\n  const privateKeyBytes = bytes.slice(0, crypto.privateKeyLength)\n  const publicKeyBytes = bytes.slice(crypto.publicKeyLength)\n  return new Ed25519PrivateKey(privateKeyBytes, publicKeyBytes)\n}\n\nfunction unmarshalEd25519PublicKey (bytes) {\n  bytes = ensureKey(bytes, crypto.publicKeyLength)\n  return new Ed25519PublicKey(bytes)\n}\n\nasync function generateKeyPair () {\n  const { privateKey, publicKey } = await crypto.generateKey()\n  return new Ed25519PrivateKey(privateKey, publicKey)\n}\n\nasync function generateKeyPairFromSeed (seed) {\n  const { privateKey, publicKey } = await crypto.generateKeyFromSeed(seed)\n  return new Ed25519PrivateKey(privateKey, publicKey)\n}\n\nfunction ensureKey (key, length) {\n  key = Uint8Array.from(key || [])\n  if (key.length !== length) {\n    throw errcode(new Error(`Key must be a Uint8Array of length ${length}, got ${key.length}`), 'ERR_INVALID_KEY_TYPE')\n  }\n  return key\n}\n\nmodule.exports = {\n  Ed25519PublicKey,\n  Ed25519PrivateKey,\n  unmarshalEd25519PrivateKey,\n  unmarshalEd25519PublicKey,\n  generateKeyPair,\n  generateKeyPairFromSeed\n}\n"]},"metadata":{},"sourceType":"script"}