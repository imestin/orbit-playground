{"ast":null,"code":"'use strict';\n\nconst mh = require('multihashing-async');\n\nconst crypto = require('libp2p-crypto');\n\nconst uint8ArrayConcat = require('uint8arrays/concat');\n\nconst uint8ArrayCompare = require('uint8arrays/compare');\n\nconst {\n  InvalidCryptoExchangeError\n} = require('libp2p-interfaces/src/crypto/errors');\n\nexports.exchanges = ['P-256', 'P-384', 'P-521'];\nexports.ciphers = ['AES-256', 'AES-128'];\nexports.hashes = ['SHA256', 'SHA512']; // Determines which algorithm to use.  Note:  f(a, b) = f(b, a)\n\nexports.theBest = (order, p1, p2) => {\n  let first;\n  let second;\n\n  if (order < 0) {\n    first = p2;\n    second = p1;\n  } else if (order > 0) {\n    first = p1;\n    second = p2;\n  } else {\n    return p1[0];\n  }\n\n  for (const firstCandidate of first) {\n    for (const secondCandidate of second) {\n      if (firstCandidate === secondCandidate) {\n        return firstCandidate;\n      }\n    }\n  }\n\n  throw new InvalidCryptoExchangeError('No algorithms in common!');\n};\n\nexports.makeMacAndCipher = async target => {\n  [target.mac, target.cipher] = await Promise.all([makeMac(target.hashT, target.keys.macKey), makeCipher(target.cipherT, target.keys.iv, target.keys.cipherKey)]);\n};\n\nfunction makeMac(hash, key) {\n  return crypto.hmac.create(hash, key);\n}\n\nfunction makeCipher(cipherType, iv, key) {\n  if (cipherType === 'AES-128' || cipherType === 'AES-256') {\n    return crypto.aes.create(key, iv);\n  } // TODO: figure out if Blowfish is needed and if so find a library for it.\n\n\n  throw new InvalidCryptoExchangeError(`unrecognized cipher type: ${cipherType}`);\n}\n\nexports.selectBest = async (local, remote) => {\n  const oh1 = await exports.digest(uint8ArrayConcat([remote.pubKeyBytes, local.nonce]));\n  const oh2 = await exports.digest(uint8ArrayConcat([local.pubKeyBytes, remote.nonce]));\n  const order = uint8ArrayCompare(oh1, oh2);\n\n  if (order === 0) {\n    throw new InvalidCryptoExchangeError('you are trying to talk to yourself');\n  }\n\n  return {\n    curveT: exports.theBest(order, local.exchanges, remote.exchanges),\n    cipherT: exports.theBest(order, local.ciphers, remote.ciphers),\n    hashT: exports.theBest(order, local.hashes, remote.hashes),\n    order\n  };\n};\n\nexports.digest = buf => {\n  return mh.digest(buf, 'sha2-256', buf.length);\n};","map":{"version":3,"sources":["/home/user/orbit-playground/music-app/node_modules/libp2p-secio/src/support.js"],"names":["mh","require","crypto","uint8ArrayConcat","uint8ArrayCompare","InvalidCryptoExchangeError","exports","exchanges","ciphers","hashes","theBest","order","p1","p2","first","second","firstCandidate","secondCandidate","makeMacAndCipher","target","mac","cipher","Promise","all","makeMac","hashT","keys","macKey","makeCipher","cipherT","iv","cipherKey","hash","key","hmac","create","cipherType","aes","selectBest","local","remote","oh1","digest","pubKeyBytes","nonce","oh2","curveT","buf","length"],"mappings":"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","sourcesContent":["'use strict'\n\nconst mh = require('multihashing-async')\nconst crypto = require('libp2p-crypto')\nconst uint8ArrayConcat = require('uint8arrays/concat')\nconst uint8ArrayCompare = require('uint8arrays/compare')\n\nconst { InvalidCryptoExchangeError } = require('libp2p-interfaces/src/crypto/errors')\n\nexports.exchanges = [\n  'P-256',\n  'P-384',\n  'P-521'\n]\n\nexports.ciphers = [\n  'AES-256',\n  'AES-128'\n]\n\nexports.hashes = [\n  'SHA256',\n  'SHA512'\n]\n\n// Determines which algorithm to use.  Note:  f(a, b) = f(b, a)\nexports.theBest = (order, p1, p2) => {\n  let first\n  let second\n\n  if (order < 0) {\n    first = p2\n    second = p1\n  } else if (order > 0) {\n    first = p1\n    second = p2\n  } else {\n    return p1[0]\n  }\n\n  for (const firstCandidate of first) {\n    for (const secondCandidate of second) {\n      if (firstCandidate === secondCandidate) {\n        return firstCandidate\n      }\n    }\n  }\n\n  throw new InvalidCryptoExchangeError('No algorithms in common!')\n}\n\nexports.makeMacAndCipher = async (target) => {\n  [target.mac, target.cipher] = await Promise.all([\n    makeMac(target.hashT, target.keys.macKey),\n    makeCipher(target.cipherT, target.keys.iv, target.keys.cipherKey)\n  ])\n}\n\nfunction makeMac (hash, key) {\n  return crypto.hmac.create(hash, key)\n}\n\nfunction makeCipher (cipherType, iv, key) {\n  if (cipherType === 'AES-128' || cipherType === 'AES-256') {\n    return crypto.aes.create(key, iv)\n  }\n\n  // TODO: figure out if Blowfish is needed and if so find a library for it.\n  throw new InvalidCryptoExchangeError(`unrecognized cipher type: ${cipherType}`)\n}\n\nexports.selectBest = async (local, remote) => {\n  const oh1 = await exports.digest(uint8ArrayConcat([\n    remote.pubKeyBytes,\n    local.nonce\n  ]))\n  const oh2 = await exports.digest(uint8ArrayConcat([\n    local.pubKeyBytes,\n    remote.nonce\n  ]))\n\n  const order = uint8ArrayCompare(oh1, oh2)\n\n  if (order === 0) {\n    throw new InvalidCryptoExchangeError('you are trying to talk to yourself')\n  }\n\n  return {\n    curveT: exports.theBest(order, local.exchanges, remote.exchanges),\n    cipherT: exports.theBest(order, local.ciphers, remote.ciphers),\n    hashT: exports.theBest(order, local.hashes, remote.hashes),\n    order\n  }\n}\n\nexports.digest = (buf) => {\n  return mh.digest(buf, 'sha2-256', buf.length)\n}\n"]},"metadata":{},"sourceType":"script"}