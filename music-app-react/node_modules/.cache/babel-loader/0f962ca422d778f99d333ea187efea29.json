{"ast":null,"code":"'use strict';\n\nconst {\n  deepEqual\n} = require('./utils');\n\nconst sum = (acc, val) => acc + val;\n/**\n * G-Counter\n *\n * Operation-based Increment-Only Counter CRDT\n *\n * Sources: \n * \"A comprehensive study of Convergent and Commutative Replicated Data Types\"\n * http://hal.upmc.fr/inria-00555588/document, \"3.1.1 Op-based counter and 3.1.2  State-based increment-only Counter (G-Counter)\"\n */\n\n\nclass GCounter {\n  constructor(id, counter) {\n    this.id = id;\n    this._counters = counter ? counter : {};\n    this._counters[this.id] = this._counters[this.id] ? this._counters[this.id] : 0;\n  }\n\n  get value() {\n    return Object.values(this._counters).reduce(sum, 0);\n  }\n\n  increment(amount) {\n    if (amount && amount < 1) return;\n    if (amount === undefined || amount === null) amount = 1;\n    this._counters[this.id] = this._counters[this.id] + amount;\n  }\n\n  merge(other) {\n    // Go through each counter in the other counter\n    Object.entries(other._counters).forEach(([id, value]) => {\n      // Take the maximum of the counter value we have or the counter value they have\n      this._counters[id] = Math.max(this._counters[id] || 0, value);\n    });\n  }\n\n  toJSON() {\n    return {\n      id: this.id,\n      counters: this._counters\n    };\n  }\n\n  isEqual(other) {\n    return GCounter.isEqual(this, other);\n  }\n\n  static from(json) {\n    return new GCounter(json.id, json.counters);\n  }\n\n  static isEqual(a, b) {\n    if (a.id !== b.id) return false;\n    return deepEqual(a._counters, b._counters);\n  }\n\n}\n\nmodule.exports = GCounter;","map":{"version":3,"sources":["/home/user/orbit-playground/music-app/node_modules/crdts/src/G-Counter.js"],"names":["deepEqual","require","sum","acc","val","GCounter","constructor","id","counter","_counters","value","Object","values","reduce","increment","amount","undefined","merge","other","entries","forEach","Math","max","toJSON","counters","isEqual","from","json","a","b","module","exports"],"mappings":"AAAA;;AAEA,MAAM;AAAEA,EAAAA;AAAF,IAAgBC,OAAO,CAAC,SAAD,CAA7B;;AACA,MAAMC,GAAG,GAAG,CAACC,GAAD,EAAMC,GAAN,KAAcD,GAAG,GAAGC,GAAhC;AAEA;;;;;;;;;;;AAUA,MAAMC,QAAN,CAAe;AACbC,EAAAA,WAAW,CAAEC,EAAF,EAAMC,OAAN,EAAe;AACxB,SAAKD,EAAL,GAAUA,EAAV;AACA,SAAKE,SAAL,GAAiBD,OAAO,GAAGA,OAAH,GAAa,EAArC;AACA,SAAKC,SAAL,CAAe,KAAKF,EAApB,IAA0B,KAAKE,SAAL,CAAe,KAAKF,EAApB,IAA0B,KAAKE,SAAL,CAAe,KAAKF,EAApB,CAA1B,GAAoD,CAA9E;AACD;;AAED,MAAIG,KAAJ,GAAa;AACX,WAAOC,MAAM,CAACC,MAAP,CAAc,KAAKH,SAAnB,EAA8BI,MAA9B,CAAqCX,GAArC,EAA0C,CAA1C,CAAP;AACD;;AAEDY,EAAAA,SAAS,CAAEC,MAAF,EAAU;AACjB,QAAIA,MAAM,IAAIA,MAAM,GAAG,CAAvB,EACE;AAEF,QAAIA,MAAM,KAAKC,SAAX,IAAwBD,MAAM,KAAK,IAAvC,EACEA,MAAM,GAAG,CAAT;AAEF,SAAKN,SAAL,CAAe,KAAKF,EAApB,IAA0B,KAAKE,SAAL,CAAe,KAAKF,EAApB,IAA0BQ,MAApD;AACD;;AAEDE,EAAAA,KAAK,CAAEC,KAAF,EAAS;AACZ;AACAP,IAAAA,MAAM,CAACQ,OAAP,CAAeD,KAAK,CAACT,SAArB,EAAgCW,OAAhC,CAAwC,CAAC,CAACb,EAAD,EAAKG,KAAL,CAAD,KAAiB;AACvD;AACA,WAAKD,SAAL,CAAeF,EAAf,IAAqBc,IAAI,CAACC,GAAL,CAAS,KAAKb,SAAL,CAAeF,EAAf,KAAsB,CAA/B,EAAkCG,KAAlC,CAArB;AACD,KAHD;AAID;;AAEDa,EAAAA,MAAM,GAAI;AACR,WAAO;AACLhB,MAAAA,EAAE,EAAE,KAAKA,EADJ;AAELiB,MAAAA,QAAQ,EAAE,KAAKf;AAFV,KAAP;AAID;;AAEDgB,EAAAA,OAAO,CAAEP,KAAF,EAAS;AACd,WAAOb,QAAQ,CAACoB,OAAT,CAAiB,IAAjB,EAAuBP,KAAvB,CAAP;AACD;;AAED,SAAOQ,IAAP,CAAaC,IAAb,EAAmB;AACjB,WAAO,IAAItB,QAAJ,CAAasB,IAAI,CAACpB,EAAlB,EAAsBoB,IAAI,CAACH,QAA3B,CAAP;AACD;;AAED,SAAOC,OAAP,CAAgBG,CAAhB,EAAmBC,CAAnB,EAAsB;AACpB,QAAGD,CAAC,CAACrB,EAAF,KAASsB,CAAC,CAACtB,EAAd,EACE,OAAO,KAAP;AAEF,WAAOP,SAAS,CAAC4B,CAAC,CAACnB,SAAH,EAAcoB,CAAC,CAACpB,SAAhB,CAAhB;AACD;;AAjDY;;AAoDfqB,MAAM,CAACC,OAAP,GAAiB1B,QAAjB","sourcesContent":["'use strict'\n\nconst { deepEqual } = require('./utils')\nconst sum = (acc, val) => acc + val\n\n/**\n * G-Counter\n *\n * Operation-based Increment-Only Counter CRDT\n *\n * Sources: \n * \"A comprehensive study of Convergent and Commutative Replicated Data Types\"\n * http://hal.upmc.fr/inria-00555588/document, \"3.1.1 Op-based counter and 3.1.2  State-based increment-only Counter (G-Counter)\"\n */\n\nclass GCounter {\n  constructor (id, counter) {\n    this.id = id\n    this._counters = counter ? counter : {}\n    this._counters[this.id] = this._counters[this.id] ? this._counters[this.id] : 0\n  }\n\n  get value () {\n    return Object.values(this._counters).reduce(sum, 0)\n  }\n\n  increment (amount) {\n    if (amount && amount < 1) \n      return\n\n    if (amount === undefined || amount === null)\n      amount = 1\n\n    this._counters[this.id] = this._counters[this.id] + amount\n  }\n\n  merge (other) {\n    // Go through each counter in the other counter\n    Object.entries(other._counters).forEach(([id, value]) => {\n      // Take the maximum of the counter value we have or the counter value they have\n      this._counters[id] = Math.max(this._counters[id] || 0, value)\n    })\n  }\n\n  toJSON () {\n    return { \n      id: this.id, \n      counters: this._counters \n    }\n  }\n\n  isEqual (other) {\n    return GCounter.isEqual(this, other)\n  }\n\n  static from (json) {\n    return new GCounter(json.id, json.counters)\n  }\n\n  static isEqual (a, b) {\n    if(a.id !== b.id)\n      return false\n\n    return deepEqual(a._counters, b._counters)\n  }\n}\n\nmodule.exports = GCounter\n"]},"metadata":{},"sourceType":"script"}