{"ast":null,"code":"'use strict';\n\nconst CID = require('cids');\n\nconst log = require('debug')('ipfs:repo:gc');\n\nconst {\n  MFS_ROOT_KEY,\n  withTimeoutOption\n} = require('../../utils');\n\nconst {\n  Errors\n} = require('interface-datastore');\n\nconst ERR_NOT_FOUND = Errors.notFoundError().code;\n\nconst {\n  parallelMerge,\n  transform,\n  map\n} = require('streaming-iterables');\n\nconst multibase = require('multibase'); // Limit on the number of parallel block remove operations\n\n\nconst BLOCK_RM_CONCURRENCY = 256; // Perform mark and sweep garbage collection\n\nmodule.exports = ({\n  gcLock,\n  pin,\n  refs,\n  repo\n}) => {\n  return withTimeoutOption(async function* gc(options = {}) {\n    const start = Date.now();\n    log('Creating set of marked blocks');\n    const release = await gcLock.writeLock();\n\n    try {\n      // Mark all blocks that are being used\n      const markedSet = await createMarkedSet({\n        pin,\n        refs,\n        repo\n      }); // Get all blocks keys from the blockstore\n\n      const blockKeys = repo.blocks.query({\n        keysOnly: true\n      }); // Delete blocks that are not being used\n\n      yield* deleteUnmarkedBlocks({\n        repo,\n        refs\n      }, markedSet, blockKeys);\n      log(`Complete (${Date.now() - start}ms)`);\n    } finally {\n      release();\n    }\n  });\n}; // Get Set of CIDs of blocks to keep\n\n\nasync function createMarkedSet({\n  pin,\n  refs,\n  repo\n}) {\n  const pinsSource = map(({\n    cid\n  }) => cid, pin.ls());\n\n  const mfsSource = async function* () {\n    let mh;\n\n    try {\n      mh = await repo.root.get(MFS_ROOT_KEY);\n    } catch (err) {\n      if (err.code === ERR_NOT_FOUND) {\n        log('No blocks in MFS');\n        return;\n      }\n\n      throw err;\n    }\n\n    const rootCid = new CID(mh);\n    yield rootCid;\n\n    for await (const {\n      ref\n    } of refs(rootCid, {\n      recursive: true\n    })) {\n      yield new CID(ref);\n    }\n  }();\n\n  const output = new Set();\n\n  for await (const cid of parallelMerge(pinsSource, mfsSource)) {\n    output.add(multibase.encode('base32', cid.multihash).toString());\n  }\n\n  return output;\n} // Delete all blocks that are not marked as in use\n\n\nasync function* deleteUnmarkedBlocks({\n  repo,\n  refs\n}, markedSet, blockKeys) {\n  // Iterate through all blocks and find those that are not in the marked set\n  // blockKeys yields { key: Key() }\n  let blocksCount = 0;\n  let removedBlocksCount = 0;\n\n  const removeBlock = async cid => {\n    blocksCount++;\n\n    try {\n      const b32 = multibase.encode('base32', cid.multihash).toString();\n      if (markedSet.has(b32)) return null;\n      const res = {\n        cid\n      };\n\n      try {\n        await repo.blocks.delete(cid);\n        removedBlocksCount++;\n      } catch (err) {\n        res.err = new Error(`Could not delete block with CID ${cid}: ${err.message}`);\n      }\n\n      return res;\n    } catch (err) {\n      const msg = `Could delete block with CID ${cid}`;\n      log(msg, err);\n      return {\n        err: new Error(msg + `: ${err.message}`)\n      };\n    }\n  };\n\n  for await (const res of transform(BLOCK_RM_CONCURRENCY, removeBlock, blockKeys)) {\n    // filter nulls (blocks that were retained)\n    if (res) yield res;\n  }\n\n  log(`Marked set has ${markedSet.size} unique blocks. Blockstore has ${blocksCount} blocks. ` + `Deleted ${removedBlocksCount} blocks.`);\n}","map":{"version":3,"sources":["/home/user/orbit-playground/music-app/node_modules/ipfs/src/core/components/repo/gc.js"],"names":["CID","require","log","MFS_ROOT_KEY","withTimeoutOption","Errors","ERR_NOT_FOUND","notFoundError","code","parallelMerge","transform","map","multibase","BLOCK_RM_CONCURRENCY","module","exports","gcLock","pin","refs","repo","gc","options","start","Date","now","release","writeLock","markedSet","createMarkedSet","blockKeys","blocks","query","keysOnly","deleteUnmarkedBlocks","pinsSource","cid","ls","mfsSource","mh","root","get","err","rootCid","ref","recursive","output","Set","add","encode","multihash","toString","blocksCount","removedBlocksCount","removeBlock","b32","has","res","delete","Error","message","msg","size"],"mappings":"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","sourcesContent":["'use strict'\n\nconst CID = require('cids')\nconst log = require('debug')('ipfs:repo:gc')\nconst { MFS_ROOT_KEY, withTimeoutOption } = require('../../utils')\nconst { Errors } = require('interface-datastore')\nconst ERR_NOT_FOUND = Errors.notFoundError().code\nconst { parallelMerge, transform, map } = require('streaming-iterables')\nconst multibase = require('multibase')\n\n// Limit on the number of parallel block remove operations\nconst BLOCK_RM_CONCURRENCY = 256\n\n// Perform mark and sweep garbage collection\nmodule.exports = ({ gcLock, pin, refs, repo }) => {\n  return withTimeoutOption(async function * gc (options = {}) {\n    const start = Date.now()\n    log('Creating set of marked blocks')\n\n    const release = await gcLock.writeLock()\n\n    try {\n      // Mark all blocks that are being used\n      const markedSet = await createMarkedSet({ pin, refs, repo })\n      // Get all blocks keys from the blockstore\n      const blockKeys = repo.blocks.query({ keysOnly: true })\n\n      // Delete blocks that are not being used\n      yield * deleteUnmarkedBlocks({ repo, refs }, markedSet, blockKeys)\n\n      log(`Complete (${Date.now() - start}ms)`)\n    } finally {\n      release()\n    }\n  })\n}\n\n// Get Set of CIDs of blocks to keep\nasync function createMarkedSet ({ pin, refs, repo }) {\n  const pinsSource = map(({ cid }) => cid, pin.ls())\n\n  const mfsSource = (async function * () {\n    let mh\n    try {\n      mh = await repo.root.get(MFS_ROOT_KEY)\n    } catch (err) {\n      if (err.code === ERR_NOT_FOUND) {\n        log('No blocks in MFS')\n        return\n      }\n      throw err\n    }\n\n    const rootCid = new CID(mh)\n    yield rootCid\n\n    for await (const { ref } of refs(rootCid, { recursive: true })) {\n      yield new CID(ref)\n    }\n  })()\n\n  const output = new Set()\n  for await (const cid of parallelMerge(pinsSource, mfsSource)) {\n    output.add(multibase.encode('base32', cid.multihash).toString())\n  }\n  return output\n}\n\n// Delete all blocks that are not marked as in use\nasync function * deleteUnmarkedBlocks ({ repo, refs }, markedSet, blockKeys) {\n  // Iterate through all blocks and find those that are not in the marked set\n  // blockKeys yields { key: Key() }\n  let blocksCount = 0\n  let removedBlocksCount = 0\n\n  const removeBlock = async (cid) => {\n    blocksCount++\n\n    try {\n      const b32 = multibase.encode('base32', cid.multihash).toString()\n      if (markedSet.has(b32)) return null\n      const res = { cid }\n\n      try {\n        await repo.blocks.delete(cid)\n        removedBlocksCount++\n      } catch (err) {\n        res.err = new Error(`Could not delete block with CID ${cid}: ${err.message}`)\n      }\n\n      return res\n    } catch (err) {\n      const msg = `Could delete block with CID ${cid}`\n      log(msg, err)\n      return { err: new Error(msg + `: ${err.message}`) }\n    }\n  }\n\n  for await (const res of transform(BLOCK_RM_CONCURRENCY, removeBlock, blockKeys)) {\n    // filter nulls (blocks that were retained)\n    if (res) yield res\n  }\n\n  log(`Marked set has ${markedSet.size} unique blocks. Blockstore has ${blocksCount} blocks. ` +\n  `Deleted ${removedBlocksCount} blocks.`)\n}\n"]},"metadata":{},"sourceType":"script"}