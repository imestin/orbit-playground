{"ast":null,"code":"'use strict';\n\nconst sha = require('multihashing-async/src/sha');\n\nconst protobuf = require('protons');\n\nconst errcode = require('err-code');\n\nconst uint8ArrayEquals = require('uint8arrays/equals');\n\nconst uint8ArrayToString = require('uint8arrays/to-string');\n\nrequire('node-forge/lib/sha512');\n\nrequire('node-forge/lib/ed25519');\n\nconst forge = require('node-forge/lib/forge');\n\nconst crypto = require('./rsa');\n\nconst pbm = protobuf(require('./keys.proto'));\n\nconst exporter = require('./exporter');\n\nclass RsaPublicKey {\n  constructor(key) {\n    this._key = key;\n  }\n\n  async verify(data, sig) {\n    // eslint-disable-line require-await\n    return crypto.hashAndVerify(this._key, sig, data);\n  }\n\n  marshal() {\n    return crypto.utils.jwkToPkix(this._key);\n  }\n\n  get bytes() {\n    return pbm.PublicKey.encode({\n      Type: pbm.KeyType.RSA,\n      Data: this.marshal()\n    });\n  }\n\n  encrypt(bytes) {\n    return crypto.encrypt(this._key, bytes);\n  }\n\n  equals(key) {\n    return uint8ArrayEquals(this.bytes, key.bytes);\n  }\n\n  async hash() {\n    // eslint-disable-line require-await\n    return sha.multihashing(this.bytes, 'sha2-256');\n  }\n\n}\n\nclass RsaPrivateKey {\n  // key       - Object of the jwk format\n  // publicKey - Uint8Array of the spki format\n  constructor(key, publicKey) {\n    this._key = key;\n    this._publicKey = publicKey;\n  }\n\n  genSecret() {\n    return crypto.getRandomValues(16);\n  }\n\n  async sign(message) {\n    // eslint-disable-line require-await\n    return crypto.hashAndSign(this._key, message);\n  }\n\n  get public() {\n    if (!this._publicKey) {\n      throw errcode(new Error('public key not provided'), 'ERR_PUBKEY_NOT_PROVIDED');\n    }\n\n    return new RsaPublicKey(this._publicKey);\n  }\n\n  decrypt(bytes) {\n    return crypto.decrypt(this._key, bytes);\n  }\n\n  marshal() {\n    return crypto.utils.jwkToPkcs1(this._key);\n  }\n\n  get bytes() {\n    return pbm.PrivateKey.encode({\n      Type: pbm.KeyType.RSA,\n      Data: this.marshal()\n    });\n  }\n\n  equals(key) {\n    return uint8ArrayEquals(this.bytes, key.bytes);\n  }\n\n  async hash() {\n    // eslint-disable-line require-await\n    return sha.multihashing(this.bytes, 'sha2-256');\n  }\n  /**\n   * Gets the ID of the key.\n   *\n   * The key id is the base58 encoding of the SHA-256 multihash of its public key.\n   * The public key is a protobuf encoding containing a type and the DER encoding\n   * of the PKCS SubjectPublicKeyInfo.\n   *\n   * @returns {Promise<String>}\n   */\n\n\n  async id() {\n    const hash = await this.public.hash();\n    return uint8ArrayToString(hash, 'base58btc');\n  }\n  /**\n   * Exports the key into a password protected PEM format\n   *\n   * @param {string} password - The password to read the encrypted PEM\n   * @param {string} [format=pkcs-8] - The format in which to export as\n   */\n\n\n  async export(password, format = 'pkcs-8') {\n    // eslint-disable-line require-await\n    if (format === 'pkcs-8') {\n      const buffer = new forge.util.ByteBuffer(this.marshal());\n      const asn1 = forge.asn1.fromDer(buffer);\n      const privateKey = forge.pki.privateKeyFromAsn1(asn1);\n      const options = {\n        algorithm: 'aes256',\n        count: 10000,\n        saltSize: 128 / 8,\n        prfAlgorithm: 'sha512'\n      };\n      return forge.pki.encryptRsaPrivateKey(privateKey, password, options);\n    } else if (format === 'libp2p-key') {\n      return exporter.export(this.bytes, password);\n    } else {\n      throw errcode(new Error(`export format '${format}' is not supported`), 'ERR_INVALID_EXPORT_FORMAT');\n    }\n  }\n\n}\n\nasync function unmarshalRsaPrivateKey(bytes) {\n  const jwk = crypto.utils.pkcs1ToJwk(bytes);\n  const keys = await crypto.unmarshalPrivateKey(jwk);\n  return new RsaPrivateKey(keys.privateKey, keys.publicKey);\n}\n\nfunction unmarshalRsaPublicKey(bytes) {\n  const jwk = crypto.utils.pkixToJwk(bytes);\n  return new RsaPublicKey(jwk);\n}\n\nasync function fromJwk(jwk) {\n  const keys = await crypto.unmarshalPrivateKey(jwk);\n  return new RsaPrivateKey(keys.privateKey, keys.publicKey);\n}\n\nasync function generateKeyPair(bits) {\n  const keys = await crypto.generateKey(bits);\n  return new RsaPrivateKey(keys.privateKey, keys.publicKey);\n}\n\nmodule.exports = {\n  RsaPublicKey,\n  RsaPrivateKey,\n  unmarshalRsaPublicKey,\n  unmarshalRsaPrivateKey,\n  generateKeyPair,\n  fromJwk\n};","map":{"version":3,"sources":["/home/user/orbit-playground/music-app/node_modules/libp2p-noise/node_modules/libp2p-crypto/src/keys/rsa-class.js"],"names":["sha","require","protobuf","errcode","uint8ArrayEquals","uint8ArrayToString","forge","crypto","pbm","exporter","RsaPublicKey","constructor","key","_key","verify","data","sig","hashAndVerify","marshal","utils","jwkToPkix","bytes","PublicKey","encode","Type","KeyType","RSA","Data","encrypt","equals","hash","multihashing","RsaPrivateKey","publicKey","_publicKey","genSecret","getRandomValues","sign","message","hashAndSign","public","Error","decrypt","jwkToPkcs1","PrivateKey","id","export","password","format","buffer","util","ByteBuffer","asn1","fromDer","privateKey","pki","privateKeyFromAsn1","options","algorithm","count","saltSize","prfAlgorithm","encryptRsaPrivateKey","unmarshalRsaPrivateKey","jwk","pkcs1ToJwk","keys","unmarshalPrivateKey","unmarshalRsaPublicKey","pkixToJwk","fromJwk","generateKeyPair","bits","generateKey","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst sha = require('multihashing-async/src/sha')\nconst protobuf = require('protons')\nconst errcode = require('err-code')\nconst uint8ArrayEquals = require('uint8arrays/equals')\nconst uint8ArrayToString = require('uint8arrays/to-string')\n\nrequire('node-forge/lib/sha512')\nrequire('node-forge/lib/ed25519')\nconst forge = require('node-forge/lib/forge')\n\nconst crypto = require('./rsa')\nconst pbm = protobuf(require('./keys.proto'))\nconst exporter = require('./exporter')\n\nclass RsaPublicKey {\n  constructor (key) {\n    this._key = key\n  }\n\n  async verify (data, sig) { // eslint-disable-line require-await\n    return crypto.hashAndVerify(this._key, sig, data)\n  }\n\n  marshal () {\n    return crypto.utils.jwkToPkix(this._key)\n  }\n\n  get bytes () {\n    return pbm.PublicKey.encode({\n      Type: pbm.KeyType.RSA,\n      Data: this.marshal()\n    })\n  }\n\n  encrypt (bytes) {\n    return crypto.encrypt(this._key, bytes)\n  }\n\n  equals (key) {\n    return uint8ArrayEquals(this.bytes, key.bytes)\n  }\n\n  async hash () { // eslint-disable-line require-await\n    return sha.multihashing(this.bytes, 'sha2-256')\n  }\n}\n\nclass RsaPrivateKey {\n  // key       - Object of the jwk format\n  // publicKey - Uint8Array of the spki format\n  constructor (key, publicKey) {\n    this._key = key\n    this._publicKey = publicKey\n  }\n\n  genSecret () {\n    return crypto.getRandomValues(16)\n  }\n\n  async sign (message) { // eslint-disable-line require-await\n    return crypto.hashAndSign(this._key, message)\n  }\n\n  get public () {\n    if (!this._publicKey) {\n      throw errcode(new Error('public key not provided'), 'ERR_PUBKEY_NOT_PROVIDED')\n    }\n\n    return new RsaPublicKey(this._publicKey)\n  }\n\n  decrypt (bytes) {\n    return crypto.decrypt(this._key, bytes)\n  }\n\n  marshal () {\n    return crypto.utils.jwkToPkcs1(this._key)\n  }\n\n  get bytes () {\n    return pbm.PrivateKey.encode({\n      Type: pbm.KeyType.RSA,\n      Data: this.marshal()\n    })\n  }\n\n  equals (key) {\n    return uint8ArrayEquals(this.bytes, key.bytes)\n  }\n\n  async hash () { // eslint-disable-line require-await\n    return sha.multihashing(this.bytes, 'sha2-256')\n  }\n\n  /**\n   * Gets the ID of the key.\n   *\n   * The key id is the base58 encoding of the SHA-256 multihash of its public key.\n   * The public key is a protobuf encoding containing a type and the DER encoding\n   * of the PKCS SubjectPublicKeyInfo.\n   *\n   * @returns {Promise<String>}\n   */\n  async id () {\n    const hash = await this.public.hash()\n    return uint8ArrayToString(hash, 'base58btc')\n  }\n\n  /**\n   * Exports the key into a password protected PEM format\n   *\n   * @param {string} password - The password to read the encrypted PEM\n   * @param {string} [format=pkcs-8] - The format in which to export as\n   */\n  async export (password, format = 'pkcs-8') { // eslint-disable-line require-await\n    if (format === 'pkcs-8') {\n      const buffer = new forge.util.ByteBuffer(this.marshal())\n      const asn1 = forge.asn1.fromDer(buffer)\n      const privateKey = forge.pki.privateKeyFromAsn1(asn1)\n\n      const options = {\n        algorithm: 'aes256',\n        count: 10000,\n        saltSize: 128 / 8,\n        prfAlgorithm: 'sha512'\n      }\n      return forge.pki.encryptRsaPrivateKey(privateKey, password, options)\n    } else if (format === 'libp2p-key') {\n      return exporter.export(this.bytes, password)\n    } else {\n      throw errcode(new Error(`export format '${format}' is not supported`), 'ERR_INVALID_EXPORT_FORMAT')\n    }\n  }\n}\n\nasync function unmarshalRsaPrivateKey (bytes) {\n  const jwk = crypto.utils.pkcs1ToJwk(bytes)\n  const keys = await crypto.unmarshalPrivateKey(jwk)\n  return new RsaPrivateKey(keys.privateKey, keys.publicKey)\n}\n\nfunction unmarshalRsaPublicKey (bytes) {\n  const jwk = crypto.utils.pkixToJwk(bytes)\n  return new RsaPublicKey(jwk)\n}\n\nasync function fromJwk (jwk) {\n  const keys = await crypto.unmarshalPrivateKey(jwk)\n  return new RsaPrivateKey(keys.privateKey, keys.publicKey)\n}\n\nasync function generateKeyPair (bits) {\n  const keys = await crypto.generateKey(bits)\n  return new RsaPrivateKey(keys.privateKey, keys.publicKey)\n}\n\nmodule.exports = {\n  RsaPublicKey,\n  RsaPrivateKey,\n  unmarshalRsaPublicKey,\n  unmarshalRsaPrivateKey,\n  generateKeyPair,\n  fromJwk\n}\n"]},"metadata":{},"sourceType":"script"}