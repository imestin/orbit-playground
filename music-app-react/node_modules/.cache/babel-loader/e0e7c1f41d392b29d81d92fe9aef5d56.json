{"ast":null,"code":"'use strict';\n\nconst dagPB = require('ipld-dag-pb');\n\nconst DAGNode = dagPB.DAGNode;\nconst DAGLink = dagPB.DAGLink;\n\nconst mh = require('multihashing-async').multihash;\n\nconst multicodec = require('multicodec');\n\nconst {\n  withTimeoutOption\n} = require('../../utils');\n\nconst uint8ArrayToString = require('uint8arrays/to-string');\n\nconst uint8ArrayFromString = require('uint8arrays/from-string');\n\nfunction parseBuffer(buf, encoding) {\n  switch (encoding) {\n    case 'json':\n      return parseJSONBuffer(buf);\n\n    case 'protobuf':\n      return parseProtoBuffer(buf);\n\n    default:\n      throw new Error(`unkown encoding: ${encoding}`);\n  }\n}\n\nfunction parseJSONBuffer(buf) {\n  let data;\n  let links;\n\n  try {\n    const parsed = JSON.parse(uint8ArrayToString(buf));\n    links = (parsed.Links || []).map(link => {\n      return new DAGLink(link.Name || link.name, link.Size || link.size, mh.fromB58String(link.Hash || link.hash || link.multihash));\n    });\n    data = uint8ArrayFromString(parsed.Data);\n  } catch (err) {\n    throw new Error('failed to parse JSON: ' + err);\n  }\n\n  return new DAGNode(data, links);\n}\n\nfunction parseProtoBuffer(buf) {\n  return dagPB.util.deserialize(buf);\n}\n\nmodule.exports = ({\n  ipld,\n  gcLock,\n  preload\n}) => {\n  return withTimeoutOption(async function put(obj, options) {\n    options = options || {};\n    const encoding = options.enc;\n    let node;\n\n    if (obj instanceof Uint8Array) {\n      if (encoding) {\n        node = await parseBuffer(obj, encoding);\n      } else {\n        node = new DAGNode(obj);\n      }\n    } else if (DAGNode.isDAGNode(obj)) {\n      // already a dag node\n      node = obj;\n    } else if (typeof obj === 'object') {\n      node = new DAGNode(obj.Data, obj.Links);\n    } else {\n      throw new Error('obj not recognized');\n    }\n\n    const release = await gcLock.readLock();\n\n    try {\n      const cid = await ipld.put(node, multicodec.DAG_PB, {\n        cidVersion: 0,\n        hashAlg: multicodec.SHA2_256\n      });\n\n      if (options.preload !== false) {\n        preload(cid);\n      }\n\n      return cid;\n    } finally {\n      release();\n    }\n  });\n};","map":{"version":3,"sources":["/home/user/orbit-playground/music-app/node_modules/ipfs/src/core/components/object/put.js"],"names":["dagPB","require","DAGNode","DAGLink","mh","multihash","multicodec","withTimeoutOption","uint8ArrayToString","uint8ArrayFromString","parseBuffer","buf","encoding","parseJSONBuffer","parseProtoBuffer","Error","data","links","parsed","JSON","parse","Links","map","link","Name","name","Size","size","fromB58String","Hash","hash","Data","err","util","deserialize","module","exports","ipld","gcLock","preload","put","obj","options","enc","node","Uint8Array","isDAGNode","release","readLock","cid","DAG_PB","cidVersion","hashAlg","SHA2_256"],"mappings":"AAAA;;AAEA,MAAMA,KAAK,GAAGC,OAAO,CAAC,aAAD,CAArB;;AACA,MAAMC,OAAO,GAAGF,KAAK,CAACE,OAAtB;AACA,MAAMC,OAAO,GAAGH,KAAK,CAACG,OAAtB;;AACA,MAAMC,EAAE,GAAGH,OAAO,CAAC,oBAAD,CAAP,CAA8BI,SAAzC;;AACA,MAAMC,UAAU,GAAGL,OAAO,CAAC,YAAD,CAA1B;;AACA,MAAM;AAAEM,EAAAA;AAAF,IAAwBN,OAAO,CAAC,aAAD,CAArC;;AACA,MAAMO,kBAAkB,GAAGP,OAAO,CAAC,uBAAD,CAAlC;;AACA,MAAMQ,oBAAoB,GAAGR,OAAO,CAAC,yBAAD,CAApC;;AAEA,SAASS,WAAT,CAAsBC,GAAtB,EAA2BC,QAA3B,EAAqC;AACnC,UAAQA,QAAR;AACE,SAAK,MAAL;AACE,aAAOC,eAAe,CAACF,GAAD,CAAtB;;AACF,SAAK,UAAL;AACE,aAAOG,gBAAgB,CAACH,GAAD,CAAvB;;AACF;AACE,YAAM,IAAII,KAAJ,CAAW,oBAAmBH,QAAS,EAAvC,CAAN;AANJ;AAQD;;AAED,SAASC,eAAT,CAA0BF,GAA1B,EAA+B;AAC7B,MAAIK,IAAJ;AACA,MAAIC,KAAJ;;AAEA,MAAI;AACF,UAAMC,MAAM,GAAGC,IAAI,CAACC,KAAL,CAAWZ,kBAAkB,CAACG,GAAD,CAA7B,CAAf;AAEAM,IAAAA,KAAK,GAAG,CAACC,MAAM,CAACG,KAAP,IAAgB,EAAjB,EAAqBC,GAArB,CAA0BC,IAAD,IAAU;AACzC,aAAO,IAAIpB,OAAJ,CACLoB,IAAI,CAACC,IAAL,IAAaD,IAAI,CAACE,IADb,EAELF,IAAI,CAACG,IAAL,IAAaH,IAAI,CAACI,IAFb,EAGLvB,EAAE,CAACwB,aAAH,CAAiBL,IAAI,CAACM,IAAL,IAAaN,IAAI,CAACO,IAAlB,IAA0BP,IAAI,CAAClB,SAAhD,CAHK,CAAP;AAKD,KANO,CAAR;AAOAW,IAAAA,IAAI,GAAGP,oBAAoB,CAACS,MAAM,CAACa,IAAR,CAA3B;AACD,GAXD,CAWE,OAAOC,GAAP,EAAY;AACZ,UAAM,IAAIjB,KAAJ,CAAU,2BAA2BiB,GAArC,CAAN;AACD;;AAED,SAAO,IAAI9B,OAAJ,CAAYc,IAAZ,EAAkBC,KAAlB,CAAP;AACD;;AAED,SAASH,gBAAT,CAA2BH,GAA3B,EAAgC;AAC9B,SAAOX,KAAK,CAACiC,IAAN,CAAWC,WAAX,CAAuBvB,GAAvB,CAAP;AACD;;AAEDwB,MAAM,CAACC,OAAP,GAAiB,CAAC;AAAEC,EAAAA,IAAF;AAAQC,EAAAA,MAAR;AAAgBC,EAAAA;AAAhB,CAAD,KAA+B;AAC9C,SAAOhC,iBAAiB,CAAC,eAAeiC,GAAf,CAAoBC,GAApB,EAAyBC,OAAzB,EAAkC;AACzDA,IAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;AAEA,UAAM9B,QAAQ,GAAG8B,OAAO,CAACC,GAAzB;AACA,QAAIC,IAAJ;;AAEA,QAAIH,GAAG,YAAYI,UAAnB,EAA+B;AAC7B,UAAIjC,QAAJ,EAAc;AACZgC,QAAAA,IAAI,GAAG,MAAMlC,WAAW,CAAC+B,GAAD,EAAM7B,QAAN,CAAxB;AACD,OAFD,MAEO;AACLgC,QAAAA,IAAI,GAAG,IAAI1C,OAAJ,CAAYuC,GAAZ,CAAP;AACD;AACF,KAND,MAMO,IAAIvC,OAAO,CAAC4C,SAAR,CAAkBL,GAAlB,CAAJ,EAA4B;AACjC;AACAG,MAAAA,IAAI,GAAGH,GAAP;AACD,KAHM,MAGA,IAAI,OAAOA,GAAP,KAAe,QAAnB,EAA6B;AAClCG,MAAAA,IAAI,GAAG,IAAI1C,OAAJ,CAAYuC,GAAG,CAACV,IAAhB,EAAsBU,GAAG,CAACpB,KAA1B,CAAP;AACD,KAFM,MAEA;AACL,YAAM,IAAIN,KAAJ,CAAU,oBAAV,CAAN;AACD;;AAED,UAAMgC,OAAO,GAAG,MAAMT,MAAM,CAACU,QAAP,EAAtB;;AAEA,QAAI;AACF,YAAMC,GAAG,GAAG,MAAMZ,IAAI,CAACG,GAAL,CAASI,IAAT,EAAetC,UAAU,CAAC4C,MAA1B,EAAkC;AAClDC,QAAAA,UAAU,EAAE,CADsC;AAElDC,QAAAA,OAAO,EAAE9C,UAAU,CAAC+C;AAF8B,OAAlC,CAAlB;;AAKA,UAAIX,OAAO,CAACH,OAAR,KAAoB,KAAxB,EAA+B;AAC7BA,QAAAA,OAAO,CAACU,GAAD,CAAP;AACD;;AAED,aAAOA,GAAP;AACD,KAXD,SAWU;AACRF,MAAAA,OAAO;AACR;AACF,GArCuB,CAAxB;AAsCD,CAvCD","sourcesContent":["'use strict'\n\nconst dagPB = require('ipld-dag-pb')\nconst DAGNode = dagPB.DAGNode\nconst DAGLink = dagPB.DAGLink\nconst mh = require('multihashing-async').multihash\nconst multicodec = require('multicodec')\nconst { withTimeoutOption } = require('../../utils')\nconst uint8ArrayToString = require('uint8arrays/to-string')\nconst uint8ArrayFromString = require('uint8arrays/from-string')\n\nfunction parseBuffer (buf, encoding) {\n  switch (encoding) {\n    case 'json':\n      return parseJSONBuffer(buf)\n    case 'protobuf':\n      return parseProtoBuffer(buf)\n    default:\n      throw new Error(`unkown encoding: ${encoding}`)\n  }\n}\n\nfunction parseJSONBuffer (buf) {\n  let data\n  let links\n\n  try {\n    const parsed = JSON.parse(uint8ArrayToString(buf))\n\n    links = (parsed.Links || []).map((link) => {\n      return new DAGLink(\n        link.Name || link.name,\n        link.Size || link.size,\n        mh.fromB58String(link.Hash || link.hash || link.multihash)\n      )\n    })\n    data = uint8ArrayFromString(parsed.Data)\n  } catch (err) {\n    throw new Error('failed to parse JSON: ' + err)\n  }\n\n  return new DAGNode(data, links)\n}\n\nfunction parseProtoBuffer (buf) {\n  return dagPB.util.deserialize(buf)\n}\n\nmodule.exports = ({ ipld, gcLock, preload }) => {\n  return withTimeoutOption(async function put (obj, options) {\n    options = options || {}\n\n    const encoding = options.enc\n    let node\n\n    if (obj instanceof Uint8Array) {\n      if (encoding) {\n        node = await parseBuffer(obj, encoding)\n      } else {\n        node = new DAGNode(obj)\n      }\n    } else if (DAGNode.isDAGNode(obj)) {\n      // already a dag node\n      node = obj\n    } else if (typeof obj === 'object') {\n      node = new DAGNode(obj.Data, obj.Links)\n    } else {\n      throw new Error('obj not recognized')\n    }\n\n    const release = await gcLock.readLock()\n\n    try {\n      const cid = await ipld.put(node, multicodec.DAG_PB, {\n        cidVersion: 0,\n        hashAlg: multicodec.SHA2_256\n      })\n\n      if (options.preload !== false) {\n        preload(cid)\n      }\n\n      return cid\n    } finally {\n      release()\n    }\n  })\n}\n"]},"metadata":{},"sourceType":"script"}