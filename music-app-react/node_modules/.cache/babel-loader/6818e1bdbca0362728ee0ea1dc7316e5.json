{"ast":null,"code":"'use strict';\n\nconst path = require('path');\n\nconst EventEmitter = require('events');\n\nconst PROTOCOL = require('./protocol');\n\nconst encode = require('./encoding');\n\nconst waitForPeers = require('./wait-for-peers');\n\nconst getPeerID = require('./get-peer-id');\n/**\n * Communication channel over Pubsub between two IPFS nodes\n */\n\n\nclass DirectChannel extends EventEmitter {\n  constructor(ipfs, receiverID) {\n    super(); // IPFS instance to use internally\n\n    this._ipfs = ipfs;\n\n    if (!ipfs.pubsub) {\n      throw new Error('This IPFS node does not support pubsub.');\n    }\n\n    this._receiverID = receiverID;\n\n    if (!this._receiverID) {\n      throw new Error('Receiver ID was undefined');\n    } // See _setup() for more state initialization\n\n  }\n  /**\n   * Channel ID\n   * @return {[String]} Channel's ID\n   */\n\n\n  get id() {\n    return this._id;\n  }\n  /**\n   * Peers participating in this channel\n   * @return {[Array]} Array of peer IDs participating in this channel\n   */\n\n\n  get peers() {\n    return this._peers;\n  }\n\n  async connect() {\n    await waitForPeers(this._ipfs, [this._receiverID], this._id);\n  }\n  /**\n   * Send a message to the other peer\n   * @param  {[Any]} message Payload\n   */\n\n\n  async send(message) {\n    let m = encode(message);\n    await this._ipfs.pubsub.publish(this._id, m);\n  }\n  /**\n   * Close the channel\n   */\n\n\n  close() {\n    this.removeAllListeners('message');\n\n    this._ipfs.pubsub.unsubscribe(this._id, this._messageHandler);\n  }\n\n  async _setup() {\n    this._senderID = await getPeerID(this._ipfs); // Channel's participants\n\n    this._peers = Array.from([this._senderID, this._receiverID]).sort(); // ID of the channel is \"<peer1 id>/<peer 2 id>\"\"\n\n    this._id = '/' + PROTOCOL + '/' + this._peers.join('/'); // Function to use to handle incoming messages\n\n    this._messageHandler = message => {\n      // Make sure the message is coming from the correct peer\n      const isValid = message && message.from === this._receiverID; // Filter out all messages that didn't come from the second peer\n\n      if (isValid) {\n        this.emit('message', message);\n      }\n    };\n  }\n\n  async _openChannel() {\n    await this._setup();\n    await this._ipfs.pubsub.subscribe(this._id, this._messageHandler);\n  }\n\n  static async open(ipfs, receiverID) {\n    const channel = new DirectChannel(ipfs, receiverID);\n    await channel._openChannel();\n    return channel;\n  }\n\n}\n\nmodule.exports = DirectChannel;","map":{"version":3,"sources":["/home/user/orbit-playground/music-app/node_modules/ipfs-pubsub-1on1/src/direct-channel.js"],"names":["path","require","EventEmitter","PROTOCOL","encode","waitForPeers","getPeerID","DirectChannel","constructor","ipfs","receiverID","_ipfs","pubsub","Error","_receiverID","id","_id","peers","_peers","connect","send","message","m","publish","close","removeAllListeners","unsubscribe","_messageHandler","_setup","_senderID","Array","from","sort","join","isValid","emit","_openChannel","subscribe","open","channel","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst path = require('path')\nconst EventEmitter = require('events')\nconst PROTOCOL = require('./protocol')\nconst encode = require('./encoding')\nconst waitForPeers = require('./wait-for-peers')\nconst getPeerID = require('./get-peer-id')\n\n/**\n * Communication channel over Pubsub between two IPFS nodes\n */\nclass DirectChannel extends EventEmitter {\n  constructor (ipfs, receiverID) {\n    super()\n\n    // IPFS instance to use internally\n    this._ipfs = ipfs\n\n    if (!ipfs.pubsub) {\n      throw new Error('This IPFS node does not support pubsub.')\n    }\n\n    this._receiverID = receiverID\n\n    if (!this._receiverID) {\n      throw new Error('Receiver ID was undefined')\n    }\n    // See _setup() for more state initialization\n  }\n\n  /**\n   * Channel ID\n   * @return {[String]} Channel's ID\n   */\n  get id () {\n    return this._id\n  }\n\n  /**\n   * Peers participating in this channel\n   * @return {[Array]} Array of peer IDs participating in this channel\n   */\n  get peers () {\n    return this._peers\n  }\n\n  async connect () {\n    await waitForPeers(this._ipfs, [this._receiverID], this._id)\n  }\n\n  /**\n   * Send a message to the other peer\n   * @param  {[Any]} message Payload\n   */\n  async send (message) {\n    let m = encode(message)\n    await this._ipfs.pubsub.publish(this._id, m)\n  }\n\n  /**\n   * Close the channel\n   */\n  close () {\n    this.removeAllListeners('message')\n    this._ipfs.pubsub.unsubscribe(this._id, this._messageHandler)\n  }\n\n  async _setup () {\n    this._senderID = await getPeerID(this._ipfs)\n\n    // Channel's participants\n    this._peers = Array.from([this._senderID, this._receiverID]).sort()\n\n    // ID of the channel is \"<peer1 id>/<peer 2 id>\"\"\n    this._id = '/' + PROTOCOL + '/' + this._peers.join('/')\n\n    // Function to use to handle incoming messages\n    this._messageHandler = message => {\n      // Make sure the message is coming from the correct peer\n      const isValid = message && message.from === this._receiverID\n      // Filter out all messages that didn't come from the second peer\n      if (isValid) {\n        this.emit('message', message)\n      }\n    }\n  }\n\n  async _openChannel () {\n    await this._setup()\n    await this._ipfs.pubsub.subscribe(this._id, this._messageHandler)\n  }\n\n  static async open (ipfs, receiverID) {\n    const channel = new DirectChannel(ipfs, receiverID)\n    await channel._openChannel()\n    return channel\n  }\n}\n\nmodule.exports = DirectChannel\n"]},"metadata":{},"sourceType":"script"}