{"ast":null,"code":"'use strict';\n\nconst debug = require('debug');\n\nconst log = debug('libp2p:connection-manager');\nlog.error = debug('libp2p:connection-manager:error');\n\nconst errcode = require('err-code');\n\nconst mergeOptions = require('merge-options');\n\nconst LatencyMonitor = require('./latency-monitor');\n\nconst retimer = require('retimer');\n\nconst {\n  EventEmitter\n} = require('events');\n\nconst PeerId = require('peer-id');\n\nconst {\n  ERR_INVALID_PARAMETERS\n} = require('../errors');\n\nconst defaultOptions = {\n  maxConnections: Infinity,\n  minConnections: 0,\n  maxData: Infinity,\n  maxSentData: Infinity,\n  maxReceivedData: Infinity,\n  maxEventLoopDelay: Infinity,\n  pollInterval: 2000,\n  autoDialInterval: 10000,\n  movingAverageInterval: 60000,\n  defaultPeerValue: 1\n};\n/**\n * Responsible for managing known connections.\n * @fires ConnectionManager#peer:connect Emitted when a new peer is connected.\n * @fires ConnectionManager#peer:disconnect Emitted when a peer is disconnected.\n */\n\nclass ConnectionManager extends EventEmitter {\n  /**\n   * @constructor\n   * @param {Libp2p} libp2p\n   * @param {object} options\n   * @param {Number} options.maxConnections The maximum number of connections allowed. Default=Infinity\n   * @param {Number} options.minConnections The minimum number of connections to avoid pruning. Default=0\n   * @param {Number} options.maxData The max data (in and out), per average interval to allow. Default=Infinity\n   * @param {Number} options.maxSentData The max outgoing data, per average interval to allow. Default=Infinity\n   * @param {Number} options.maxReceivedData The max incoming data, per average interval to allow.. Default=Infinity\n   * @param {Number} options.maxEventLoopDelay The upper limit the event loop can take to run. Default=Infinity\n   * @param {Number} options.pollInterval How often, in milliseconds, metrics and latency should be checked. Default=2000\n   * @param {Number} options.movingAverageInterval How often, in milliseconds, to compute averages. Default=60000\n   * @param {Number} options.defaultPeerValue The value of the peer. Default=1\n   * @param {boolean} options.autoDial Should preemptively guarantee connections are above the low watermark. Default=true\n   * @param {Number} options.autoDialInterval How often, in milliseconds, it should preemptively guarantee connections are above the low watermark. Default=10000\n   */\n  constructor(libp2p, options) {\n    super();\n    this._libp2p = libp2p;\n    this._peerId = libp2p.peerId.toB58String();\n    this._options = mergeOptions.call({\n      ignoreUndefined: true\n    }, defaultOptions, options);\n\n    if (this._options.maxConnections < this._options.minConnections) {\n      throw errcode(new Error('Connection Manager maxConnections must be greater than minConnections'), ERR_INVALID_PARAMETERS);\n    }\n\n    log('options: %j', this._options);\n    this._libp2p = libp2p;\n    /**\n     * Map of peer identifiers to their peer value for pruning connections.\n     * @type {Map<string, number>}\n     */\n\n    this._peerValues = new Map();\n    /**\n     * Map of connections per peer\n     * @type {Map<string, Array<conn>>}\n     */\n\n    this.connections = new Map();\n    this._started = false;\n    this._timer = null;\n    this._autoDialTimeout = null;\n    this._checkMetrics = this._checkMetrics.bind(this);\n    this._autoDial = this._autoDial.bind(this);\n  }\n  /**\n   * Get current number of open connections.\n   */\n\n\n  get size() {\n    return Array.from(this.connections.values()).reduce((accumulator, value) => accumulator + value.length, 0);\n  }\n  /**\n   * Starts the Connection Manager. If Metrics are not enabled on libp2p\n   * only event loop and connection limits will be monitored.\n   */\n\n\n  start() {\n    if (this._libp2p.metrics) {\n      this._timer = this._timer || retimer(this._checkMetrics, this._options.pollInterval);\n    } // latency monitor\n\n\n    this._latencyMonitor = new LatencyMonitor({\n      latencyCheckIntervalMs: this._options.pollInterval,\n      dataEmitIntervalMs: this._options.pollInterval\n    });\n    this._onLatencyMeasure = this._onLatencyMeasure.bind(this);\n\n    this._latencyMonitor.on('data', this._onLatencyMeasure);\n\n    this._started = true;\n    log('started');\n    this._options.autoDial && this._autoDial();\n  }\n  /**\n   * Stops the Connection Manager\n   * @async\n   */\n\n\n  async stop() {\n    this._autoDialTimeout && this._autoDialTimeout.clear();\n    this._timer && this._timer.clear();\n    this._latencyMonitor && this._latencyMonitor.removeListener('data', this._onLatencyMeasure);\n    this._started = false;\n    await this._close();\n    log('stopped');\n  }\n  /**\n   * Cleans up the connections\n   * @async\n   */\n\n\n  async _close() {\n    // Close all connections we're tracking\n    const tasks = [];\n\n    for (const connectionList of this.connections.values()) {\n      for (const connection of connectionList) {\n        tasks.push(connection.close());\n      }\n    }\n\n    await tasks;\n    this.connections.clear();\n  }\n  /**\n   * Sets the value of the given peer. Peers with lower values\n   * will be disconnected first.\n   * @param {PeerId} peerId\n   * @param {number} value A number between 0 and 1\n   */\n\n\n  setPeerValue(peerId, value) {\n    if (value < 0 || value > 1) {\n      throw new Error('value should be a number between 0 and 1');\n    }\n\n    if (peerId.toB58String) {\n      peerId = peerId.toB58String();\n    }\n\n    this._peerValues.set(peerId, value);\n  }\n  /**\n   * Checks the libp2p metrics to determine if any values have exceeded\n   * the configured maximums.\n   * @private\n   */\n\n\n  _checkMetrics() {\n    const movingAverages = this._libp2p.metrics.global.movingAverages;\n\n    const received = movingAverages.dataReceived[this._options.movingAverageInterval].movingAverage();\n\n    this._checkMaxLimit('maxReceivedData', received);\n\n    const sent = movingAverages.dataSent[this._options.movingAverageInterval].movingAverage();\n\n    this._checkMaxLimit('maxSentData', sent);\n\n    const total = received + sent;\n\n    this._checkMaxLimit('maxData', total);\n\n    log('metrics update', total);\n    this._timer = retimer(this._checkMetrics, this._options.pollInterval);\n  }\n  /**\n   * Tracks the incoming connection and check the connection limit\n   * @param {Connection} connection\n   */\n\n\n  onConnect(connection) {\n    const peerId = connection.remotePeer;\n    const peerIdStr = peerId.toB58String();\n    const storedConn = this.connections.get(peerIdStr);\n    this.emit('peer:connect', connection);\n\n    if (storedConn) {\n      storedConn.push(connection);\n    } else {\n      this.connections.set(peerIdStr, [connection]);\n    }\n\n    this._libp2p.peerStore.keyBook.set(peerId, peerId.pubKey);\n\n    if (!this._peerValues.has(peerIdStr)) {\n      this._peerValues.set(peerIdStr, this._options.defaultPeerValue);\n    }\n\n    this._checkMaxLimit('maxConnections', this.size);\n  }\n  /**\n   * Removes the connection from tracking\n   * @param {Connection} connection\n   */\n\n\n  onDisconnect(connection) {\n    const peerId = connection.remotePeer.toB58String();\n    let storedConn = this.connections.get(peerId);\n\n    if (storedConn && storedConn.length > 1) {\n      storedConn = storedConn.filter(conn => conn.id !== connection.id);\n      this.connections.set(peerId, storedConn);\n    } else if (storedConn) {\n      this.connections.delete(peerId);\n\n      this._peerValues.delete(connection.remotePeer.toB58String());\n\n      this.emit('peer:disconnect', connection);\n    }\n  }\n  /**\n   * Get a connection with a peer.\n   * @param {PeerId} peerId\n   * @returns {Connection}\n   */\n\n\n  get(peerId) {\n    const connections = this.getAll(peerId);\n\n    if (connections.length) {\n      return connections[0];\n    }\n\n    return null;\n  }\n  /**\n   * Get all open connections with a peer.\n   * @param {PeerId} peerId\n   * @returns {Array<Connection>}\n   */\n\n\n  getAll(peerId) {\n    if (!PeerId.isPeerId(peerId)) {\n      throw errcode(new Error('peerId must be an instance of peer-id'), ERR_INVALID_PARAMETERS);\n    }\n\n    const id = peerId.toB58String();\n    const connections = this.connections.get(id); // Return all open connections\n\n    if (connections) {\n      return connections.filter(connection => connection.stat.status === 'open');\n    }\n\n    return [];\n  }\n  /**\n   * If the event loop is slow, maybe close a connection\n   * @private\n   * @param {*} summary The LatencyMonitor summary\n   */\n\n\n  _onLatencyMeasure(summary) {\n    this._checkMaxLimit('maxEventLoopDelay', summary.avgMs);\n  }\n  /**\n   * If the `value` of `name` has exceeded its limit, maybe close a connection\n   * @private\n   * @param {string} name The name of the field to check limits for\n   * @param {number} value The current value of the field\n   */\n\n\n  _checkMaxLimit(name, value) {\n    const limit = this._options[name];\n    log('checking limit of %s. current value: %d of %d', name, value, limit);\n\n    if (value > limit) {\n      log('%s: limit exceeded: %s, %d', this._peerId, name, value);\n\n      this._maybeDisconnectOne();\n    }\n  }\n  /**\n   * Proactively tries to connect to known peers stored in the PeerStore.\n   * It will keep the number of connections below the upper limit and sort\n   * the peers to connect based on wether we know their keys and protocols.\n   * @async\n   * @private\n   */\n\n\n  async _autoDial() {\n    const minConnections = this._options.minConnections; // Already has enough connections\n\n    if (this.size >= minConnections) {\n      this._autoDialTimeout = retimer(this._autoDial, this._options.autoDialInterval);\n      return;\n    } // Sort peers on wether we know protocols of public keys for them\n\n\n    const peers = Array.from(this._libp2p.peerStore.peers.values()).sort((a, b) => {\n      if (b.protocols && b.protocols.length && (!a.protocols || !a.protocols.length)) {\n        return 1;\n      } else if (b.id.pubKey && !a.id.pubKey) {\n        return 1;\n      }\n\n      return -1;\n    });\n\n    for (let i = 0; i < peers.length && this.size < minConnections; i++) {\n      if (!this.get(peers[i].id)) {\n        log('connecting to a peerStore stored peer %s', peers[i].id.toB58String());\n\n        try {\n          await this._libp2p.dialer.connectToPeer(peers[i].id); // Connection Manager was stopped\n\n          if (!this._started) {\n            return;\n          }\n        } catch (err) {\n          log.error('could not connect to peerStore stored peer', err);\n        }\n      }\n    }\n\n    this._autoDialTimeout = retimer(this._autoDial, this._options.autoDialInterval);\n  }\n  /**\n   * If we have more connections than our maximum, close a connection\n   * to the lowest valued peer.\n   * @private\n   */\n\n\n  _maybeDisconnectOne() {\n    if (this._options.minConnections < this.connections.size) {\n      const peerValues = Array.from(this._peerValues).sort(byPeerValue);\n      log('%s: sorted peer values: %j', this._peerId, peerValues);\n      const disconnectPeer = peerValues[0];\n\n      if (disconnectPeer) {\n        const peerId = disconnectPeer[0];\n        log('%s: lowest value peer is %s', this._peerId, peerId);\n        log('%s: closing a connection to %j', this._peerId, peerId);\n\n        for (const connections of this.connections.values()) {\n          if (connections[0].remotePeer.toB58String() === peerId) {\n            connections[0].close();\n            break;\n          }\n        }\n      }\n    }\n  }\n\n}\n\nmodule.exports = ConnectionManager;\n\nfunction byPeerValue(peerValueEntryA, peerValueEntryB) {\n  return peerValueEntryA[1] - peerValueEntryB[1];\n}","map":{"version":3,"sources":["/home/user/orbit-playground/music-app/node_modules/libp2p/src/connection-manager/index.js"],"names":["debug","require","log","error","errcode","mergeOptions","LatencyMonitor","retimer","EventEmitter","PeerId","ERR_INVALID_PARAMETERS","defaultOptions","maxConnections","Infinity","minConnections","maxData","maxSentData","maxReceivedData","maxEventLoopDelay","pollInterval","autoDialInterval","movingAverageInterval","defaultPeerValue","ConnectionManager","constructor","libp2p","options","_libp2p","_peerId","peerId","toB58String","_options","call","ignoreUndefined","Error","_peerValues","Map","connections","_started","_timer","_autoDialTimeout","_checkMetrics","bind","_autoDial","size","Array","from","values","reduce","accumulator","value","length","start","metrics","_latencyMonitor","latencyCheckIntervalMs","dataEmitIntervalMs","_onLatencyMeasure","on","autoDial","stop","clear","removeListener","_close","tasks","connectionList","connection","push","close","setPeerValue","set","movingAverages","global","received","dataReceived","movingAverage","_checkMaxLimit","sent","dataSent","total","onConnect","remotePeer","peerIdStr","storedConn","get","emit","peerStore","keyBook","pubKey","has","onDisconnect","filter","conn","id","delete","getAll","isPeerId","stat","status","summary","avgMs","name","limit","_maybeDisconnectOne","peers","sort","a","b","protocols","i","dialer","connectToPeer","err","peerValues","byPeerValue","disconnectPeer","module","exports","peerValueEntryA","peerValueEntryB"],"mappings":"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","sourcesContent":["'use strict'\n\nconst debug = require('debug')\nconst log = debug('libp2p:connection-manager')\nlog.error = debug('libp2p:connection-manager:error')\n\nconst errcode = require('err-code')\nconst mergeOptions = require('merge-options')\nconst LatencyMonitor = require('./latency-monitor')\nconst retimer = require('retimer')\n\nconst { EventEmitter } = require('events')\n\nconst PeerId = require('peer-id')\n\nconst {\n  ERR_INVALID_PARAMETERS\n} = require('../errors')\n\nconst defaultOptions = {\n  maxConnections: Infinity,\n  minConnections: 0,\n  maxData: Infinity,\n  maxSentData: Infinity,\n  maxReceivedData: Infinity,\n  maxEventLoopDelay: Infinity,\n  pollInterval: 2000,\n  autoDialInterval: 10000,\n  movingAverageInterval: 60000,\n  defaultPeerValue: 1\n}\n\n/**\n * Responsible for managing known connections.\n * @fires ConnectionManager#peer:connect Emitted when a new peer is connected.\n * @fires ConnectionManager#peer:disconnect Emitted when a peer is disconnected.\n */\nclass ConnectionManager extends EventEmitter {\n  /**\n   * @constructor\n   * @param {Libp2p} libp2p\n   * @param {object} options\n   * @param {Number} options.maxConnections The maximum number of connections allowed. Default=Infinity\n   * @param {Number} options.minConnections The minimum number of connections to avoid pruning. Default=0\n   * @param {Number} options.maxData The max data (in and out), per average interval to allow. Default=Infinity\n   * @param {Number} options.maxSentData The max outgoing data, per average interval to allow. Default=Infinity\n   * @param {Number} options.maxReceivedData The max incoming data, per average interval to allow.. Default=Infinity\n   * @param {Number} options.maxEventLoopDelay The upper limit the event loop can take to run. Default=Infinity\n   * @param {Number} options.pollInterval How often, in milliseconds, metrics and latency should be checked. Default=2000\n   * @param {Number} options.movingAverageInterval How often, in milliseconds, to compute averages. Default=60000\n   * @param {Number} options.defaultPeerValue The value of the peer. Default=1\n   * @param {boolean} options.autoDial Should preemptively guarantee connections are above the low watermark. Default=true\n   * @param {Number} options.autoDialInterval How often, in milliseconds, it should preemptively guarantee connections are above the low watermark. Default=10000\n   */\n  constructor (libp2p, options) {\n    super()\n\n    this._libp2p = libp2p\n    this._peerId = libp2p.peerId.toB58String()\n\n    this._options = mergeOptions.call({ ignoreUndefined: true }, defaultOptions, options)\n    if (this._options.maxConnections < this._options.minConnections) {\n      throw errcode(new Error('Connection Manager maxConnections must be greater than minConnections'), ERR_INVALID_PARAMETERS)\n    }\n\n    log('options: %j', this._options)\n\n    this._libp2p = libp2p\n\n    /**\n     * Map of peer identifiers to their peer value for pruning connections.\n     * @type {Map<string, number>}\n     */\n    this._peerValues = new Map()\n\n    /**\n     * Map of connections per peer\n     * @type {Map<string, Array<conn>>}\n     */\n    this.connections = new Map()\n\n    this._started = false\n    this._timer = null\n    this._autoDialTimeout = null\n    this._checkMetrics = this._checkMetrics.bind(this)\n    this._autoDial = this._autoDial.bind(this)\n  }\n\n  /**\n   * Get current number of open connections.\n   */\n  get size () {\n    return Array.from(this.connections.values())\n      .reduce((accumulator, value) => accumulator + value.length, 0)\n  }\n\n  /**\n   * Starts the Connection Manager. If Metrics are not enabled on libp2p\n   * only event loop and connection limits will be monitored.\n   */\n  start () {\n    if (this._libp2p.metrics) {\n      this._timer = this._timer || retimer(this._checkMetrics, this._options.pollInterval)\n    }\n\n    // latency monitor\n    this._latencyMonitor = new LatencyMonitor({\n      latencyCheckIntervalMs: this._options.pollInterval,\n      dataEmitIntervalMs: this._options.pollInterval\n    })\n    this._onLatencyMeasure = this._onLatencyMeasure.bind(this)\n    this._latencyMonitor.on('data', this._onLatencyMeasure)\n\n    this._started = true\n    log('started')\n\n    this._options.autoDial && this._autoDial()\n  }\n\n  /**\n   * Stops the Connection Manager\n   * @async\n   */\n  async stop () {\n    this._autoDialTimeout && this._autoDialTimeout.clear()\n    this._timer && this._timer.clear()\n    this._latencyMonitor && this._latencyMonitor.removeListener('data', this._onLatencyMeasure)\n\n    this._started = false\n    await this._close()\n    log('stopped')\n  }\n\n  /**\n   * Cleans up the connections\n   * @async\n   */\n  async _close () {\n    // Close all connections we're tracking\n    const tasks = []\n    for (const connectionList of this.connections.values()) {\n      for (const connection of connectionList) {\n        tasks.push(connection.close())\n      }\n    }\n\n    await tasks\n    this.connections.clear()\n  }\n\n  /**\n   * Sets the value of the given peer. Peers with lower values\n   * will be disconnected first.\n   * @param {PeerId} peerId\n   * @param {number} value A number between 0 and 1\n   */\n  setPeerValue (peerId, value) {\n    if (value < 0 || value > 1) {\n      throw new Error('value should be a number between 0 and 1')\n    }\n    if (peerId.toB58String) {\n      peerId = peerId.toB58String()\n    }\n    this._peerValues.set(peerId, value)\n  }\n\n  /**\n   * Checks the libp2p metrics to determine if any values have exceeded\n   * the configured maximums.\n   * @private\n   */\n  _checkMetrics () {\n    const movingAverages = this._libp2p.metrics.global.movingAverages\n    const received = movingAverages.dataReceived[this._options.movingAverageInterval].movingAverage()\n    this._checkMaxLimit('maxReceivedData', received)\n    const sent = movingAverages.dataSent[this._options.movingAverageInterval].movingAverage()\n    this._checkMaxLimit('maxSentData', sent)\n    const total = received + sent\n    this._checkMaxLimit('maxData', total)\n    log('metrics update', total)\n    this._timer = retimer(this._checkMetrics, this._options.pollInterval)\n  }\n\n  /**\n   * Tracks the incoming connection and check the connection limit\n   * @param {Connection} connection\n   */\n  onConnect (connection) {\n    const peerId = connection.remotePeer\n    const peerIdStr = peerId.toB58String()\n    const storedConn = this.connections.get(peerIdStr)\n\n    this.emit('peer:connect', connection)\n    if (storedConn) {\n      storedConn.push(connection)\n    } else {\n      this.connections.set(peerIdStr, [connection])\n    }\n\n    this._libp2p.peerStore.keyBook.set(peerId, peerId.pubKey)\n\n    if (!this._peerValues.has(peerIdStr)) {\n      this._peerValues.set(peerIdStr, this._options.defaultPeerValue)\n    }\n\n    this._checkMaxLimit('maxConnections', this.size)\n  }\n\n  /**\n   * Removes the connection from tracking\n   * @param {Connection} connection\n   */\n  onDisconnect (connection) {\n    const peerId = connection.remotePeer.toB58String()\n    let storedConn = this.connections.get(peerId)\n\n    if (storedConn && storedConn.length > 1) {\n      storedConn = storedConn.filter((conn) => conn.id !== connection.id)\n      this.connections.set(peerId, storedConn)\n    } else if (storedConn) {\n      this.connections.delete(peerId)\n      this._peerValues.delete(connection.remotePeer.toB58String())\n      this.emit('peer:disconnect', connection)\n    }\n  }\n\n  /**\n   * Get a connection with a peer.\n   * @param {PeerId} peerId\n   * @returns {Connection}\n   */\n  get (peerId) {\n    const connections = this.getAll(peerId)\n    if (connections.length) {\n      return connections[0]\n    }\n    return null\n  }\n\n  /**\n   * Get all open connections with a peer.\n   * @param {PeerId} peerId\n   * @returns {Array<Connection>}\n   */\n  getAll (peerId) {\n    if (!PeerId.isPeerId(peerId)) {\n      throw errcode(new Error('peerId must be an instance of peer-id'), ERR_INVALID_PARAMETERS)\n    }\n\n    const id = peerId.toB58String()\n    const connections = this.connections.get(id)\n\n    // Return all open connections\n    if (connections) {\n      return connections.filter(connection => connection.stat.status === 'open')\n    }\n    return []\n  }\n\n  /**\n   * If the event loop is slow, maybe close a connection\n   * @private\n   * @param {*} summary The LatencyMonitor summary\n   */\n  _onLatencyMeasure (summary) {\n    this._checkMaxLimit('maxEventLoopDelay', summary.avgMs)\n  }\n\n  /**\n   * If the `value` of `name` has exceeded its limit, maybe close a connection\n   * @private\n   * @param {string} name The name of the field to check limits for\n   * @param {number} value The current value of the field\n   */\n  _checkMaxLimit (name, value) {\n    const limit = this._options[name]\n    log('checking limit of %s. current value: %d of %d', name, value, limit)\n    if (value > limit) {\n      log('%s: limit exceeded: %s, %d', this._peerId, name, value)\n      this._maybeDisconnectOne()\n    }\n  }\n\n  /**\n   * Proactively tries to connect to known peers stored in the PeerStore.\n   * It will keep the number of connections below the upper limit and sort\n   * the peers to connect based on wether we know their keys and protocols.\n   * @async\n   * @private\n   */\n  async _autoDial () {\n    const minConnections = this._options.minConnections\n\n    // Already has enough connections\n    if (this.size >= minConnections) {\n      this._autoDialTimeout = retimer(this._autoDial, this._options.autoDialInterval)\n      return\n    }\n\n    // Sort peers on wether we know protocols of public keys for them\n    const peers = Array.from(this._libp2p.peerStore.peers.values())\n      .sort((a, b) => {\n        if (b.protocols && b.protocols.length && (!a.protocols || !a.protocols.length)) {\n          return 1\n        } else if (b.id.pubKey && !a.id.pubKey) {\n          return 1\n        }\n        return -1\n      })\n\n    for (let i = 0; i < peers.length && this.size < minConnections; i++) {\n      if (!this.get(peers[i].id)) {\n        log('connecting to a peerStore stored peer %s', peers[i].id.toB58String())\n        try {\n          await this._libp2p.dialer.connectToPeer(peers[i].id)\n\n          // Connection Manager was stopped\n          if (!this._started) {\n            return\n          }\n        } catch (err) {\n          log.error('could not connect to peerStore stored peer', err)\n        }\n      }\n    }\n\n    this._autoDialTimeout = retimer(this._autoDial, this._options.autoDialInterval)\n  }\n\n  /**\n   * If we have more connections than our maximum, close a connection\n   * to the lowest valued peer.\n   * @private\n   */\n  _maybeDisconnectOne () {\n    if (this._options.minConnections < this.connections.size) {\n      const peerValues = Array.from(this._peerValues).sort(byPeerValue)\n      log('%s: sorted peer values: %j', this._peerId, peerValues)\n      const disconnectPeer = peerValues[0]\n      if (disconnectPeer) {\n        const peerId = disconnectPeer[0]\n        log('%s: lowest value peer is %s', this._peerId, peerId)\n        log('%s: closing a connection to %j', this._peerId, peerId)\n        for (const connections of this.connections.values()) {\n          if (connections[0].remotePeer.toB58String() === peerId) {\n            connections[0].close()\n            break\n          }\n        }\n      }\n    }\n  }\n}\n\nmodule.exports = ConnectionManager\n\nfunction byPeerValue (peerValueEntryA, peerValueEntryB) {\n  return peerValueEntryA[1] - peerValueEntryB[1]\n}\n"]},"metadata":{},"sourceType":"script"}