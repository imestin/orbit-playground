{"ast":null,"code":"'use strict';\n\nconst debug = require('debug');\n\nconst log = debug('libp2p:envelope');\nlog.error = debug('libp2p:envelope:error');\n\nconst errCode = require('err-code');\n\nconst uint8arraysConcat = require('uint8arrays/concat');\n\nconst uint8arraysFromString = require('uint8arrays/from-string');\n\nconst cryptoKeys = require('libp2p-crypto/src/keys');\n\nconst PeerId = require('peer-id');\n\nconst varint = require('varint');\n\nconst uint8arraysEquals = require('uint8arrays/equals');\n\nconst {\n  codes\n} = require('../../errors');\n\nconst Protobuf = require('./envelope.proto');\n/**\n * The Envelope is responsible for keeping an arbitrary signed record\n * by a libp2p peer.\n */\n\n\nclass Envelope {\n  /**\n   * @constructor\n   * @param {object} params\n   * @param {PeerId} params.peerId\n   * @param {Uint8Array} params.payloadType\n   * @param {Uint8Array} params.payload marshaled record\n   * @param {Uint8Array} params.signature signature of the domain string :: type hint :: payload.\n   */\n  constructor({\n    peerId,\n    payloadType,\n    payload,\n    signature\n  }) {\n    this.peerId = peerId;\n    this.payloadType = payloadType;\n    this.payload = payload;\n    this.signature = signature; // Cache\n\n    this._marshal = undefined;\n  }\n  /**\n   * Marshal the envelope content.\n   * @return {Uint8Array}\n   */\n\n\n  marshal() {\n    if (this._marshal) {\n      return this._marshal;\n    }\n\n    const publicKey = cryptoKeys.marshalPublicKey(this.peerId.pubKey);\n    this._marshal = Protobuf.encode({\n      public_key: publicKey,\n      payload_type: this.payloadType,\n      payload: this.payload,\n      signature: this.signature\n    });\n    return this._marshal;\n  }\n  /**\n   * Verifies if the other Envelope is identical to this one.\n   * @param {Envelope} other\n   * @return {boolean}\n   */\n\n\n  equals(other) {\n    return uint8arraysEquals(this.peerId.pubKey.bytes, other.peerId.pubKey.bytes) && uint8arraysEquals(this.payloadType, other.payloadType) && uint8arraysEquals(this.payload, other.payload) && uint8arraysEquals(this.signature, other.signature);\n  }\n  /**\n   * Validate envelope data signature for the given domain.\n   * @param {string} domain\n   * @return {Promise<boolean>}\n   */\n\n\n  validate(domain) {\n    const signData = formatSignaturePayload(domain, this.payloadType, this.payload);\n    return this.peerId.pubKey.verify(signData, this.signature);\n  }\n\n}\n/**\n * Helper function that prepares a Uint8Array to sign or verify a signature.\n * @param {string} domain\n * @param {Uint8Array} payloadType\n * @param {Uint8Array} payload\n * @return {Uint8Array}\n */\n\n\nconst formatSignaturePayload = (domain, payloadType, payload) => {\n  // When signing, a peer will prepare a Uint8Array by concatenating the following:\n  // - The length of the domain separation string string in bytes\n  // - The domain separation string, encoded as UTF-8\n  // - The length of the payload_type field in bytes\n  // - The value of the payload_type field\n  // - The length of the payload field in bytes\n  // - The value of the payload field\n  domain = uint8arraysFromString(domain);\n  const domainLength = varint.encode(domain.byteLength);\n  const payloadTypeLength = varint.encode(payloadType.length);\n  const payloadLength = varint.encode(payload.length);\n  return uint8arraysConcat([new Uint8Array(domainLength), domain, new Uint8Array(payloadTypeLength), payloadType, new Uint8Array(payloadLength), payload]);\n};\n/**\n * Unmarshal a serialized Envelope protobuf message.\n * @param {Uint8Array} data\n * @return {Promise<Envelope>}\n */\n\n\nEnvelope.createFromProtobuf = async data => {\n  const envelopeData = Protobuf.decode(data);\n  const peerId = await PeerId.createFromPubKey(envelopeData.public_key);\n  return new Envelope({\n    peerId,\n    payloadType: envelopeData.payload_type,\n    payload: envelopeData.payload,\n    signature: envelopeData.signature\n  });\n};\n/**\n* Seal marshals the given Record, places the marshaled bytes inside an Envelope\n* and signs it with the given peerId's private key.\n* @async\n* @param {Record} record\n* @param {PeerId} peerId\n* @return {Envelope}\n*/\n\n\nEnvelope.seal = async (record, peerId) => {\n  const domain = record.domain;\n  const payloadType = record.codec;\n  const payload = record.marshal();\n  const signData = formatSignaturePayload(domain, payloadType, payload);\n  const signature = await peerId.privKey.sign(signData);\n  return new Envelope({\n    peerId,\n    payloadType,\n    payload,\n    signature\n  });\n};\n/**\n * Open and certify a given marshalled envelope.\n * Data is unmarshalled and the signature validated for the given domain.\n * @param {Uint8Array} data\n * @param {string} domain\n * @return {Envelope}\n */\n\n\nEnvelope.openAndCertify = async (data, domain) => {\n  const envelope = await Envelope.createFromProtobuf(data);\n  const valid = await envelope.validate(domain);\n\n  if (!valid) {\n    throw errCode(new Error('envelope signature is not valid for the given domain'), codes.ERR_SIGNATURE_NOT_VALID);\n  }\n\n  return envelope;\n};\n\nmodule.exports = Envelope;","map":{"version":3,"sources":["/home/user/orbit-playground/music-app/node_modules/libp2p/src/record/envelope/index.js"],"names":["debug","require","log","error","errCode","uint8arraysConcat","uint8arraysFromString","cryptoKeys","PeerId","varint","uint8arraysEquals","codes","Protobuf","Envelope","constructor","peerId","payloadType","payload","signature","_marshal","undefined","marshal","publicKey","marshalPublicKey","pubKey","encode","public_key","payload_type","equals","other","bytes","validate","domain","signData","formatSignaturePayload","verify","domainLength","byteLength","payloadTypeLength","length","payloadLength","Uint8Array","createFromProtobuf","data","envelopeData","decode","createFromPubKey","seal","record","codec","privKey","sign","openAndCertify","envelope","valid","Error","ERR_SIGNATURE_NOT_VALID","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst debug = require('debug')\nconst log = debug('libp2p:envelope')\nlog.error = debug('libp2p:envelope:error')\nconst errCode = require('err-code')\nconst uint8arraysConcat = require('uint8arrays/concat')\nconst uint8arraysFromString = require('uint8arrays/from-string')\nconst cryptoKeys = require('libp2p-crypto/src/keys')\nconst PeerId = require('peer-id')\nconst varint = require('varint')\nconst uint8arraysEquals = require('uint8arrays/equals')\n\nconst { codes } = require('../../errors')\nconst Protobuf = require('./envelope.proto')\n\n/**\n * The Envelope is responsible for keeping an arbitrary signed record\n * by a libp2p peer.\n */\nclass Envelope {\n  /**\n   * @constructor\n   * @param {object} params\n   * @param {PeerId} params.peerId\n   * @param {Uint8Array} params.payloadType\n   * @param {Uint8Array} params.payload marshaled record\n   * @param {Uint8Array} params.signature signature of the domain string :: type hint :: payload.\n   */\n  constructor ({ peerId, payloadType, payload, signature }) {\n    this.peerId = peerId\n    this.payloadType = payloadType\n    this.payload = payload\n    this.signature = signature\n\n    // Cache\n    this._marshal = undefined\n  }\n\n  /**\n   * Marshal the envelope content.\n   * @return {Uint8Array}\n   */\n  marshal () {\n    if (this._marshal) {\n      return this._marshal\n    }\n\n    const publicKey = cryptoKeys.marshalPublicKey(this.peerId.pubKey)\n\n    this._marshal = Protobuf.encode({\n      public_key: publicKey,\n      payload_type: this.payloadType,\n      payload: this.payload,\n      signature: this.signature\n    })\n\n    return this._marshal\n  }\n\n  /**\n   * Verifies if the other Envelope is identical to this one.\n   * @param {Envelope} other\n   * @return {boolean}\n   */\n  equals (other) {\n    return uint8arraysEquals(this.peerId.pubKey.bytes, other.peerId.pubKey.bytes) &&\n      uint8arraysEquals(this.payloadType, other.payloadType) &&\n      uint8arraysEquals(this.payload, other.payload) &&\n      uint8arraysEquals(this.signature, other.signature)\n  }\n\n  /**\n   * Validate envelope data signature for the given domain.\n   * @param {string} domain\n   * @return {Promise<boolean>}\n   */\n  validate (domain) {\n    const signData = formatSignaturePayload(domain, this.payloadType, this.payload)\n\n    return this.peerId.pubKey.verify(signData, this.signature)\n  }\n}\n\n/**\n * Helper function that prepares a Uint8Array to sign or verify a signature.\n * @param {string} domain\n * @param {Uint8Array} payloadType\n * @param {Uint8Array} payload\n * @return {Uint8Array}\n */\nconst formatSignaturePayload = (domain, payloadType, payload) => {\n  // When signing, a peer will prepare a Uint8Array by concatenating the following:\n  // - The length of the domain separation string string in bytes\n  // - The domain separation string, encoded as UTF-8\n  // - The length of the payload_type field in bytes\n  // - The value of the payload_type field\n  // - The length of the payload field in bytes\n  // - The value of the payload field\n\n  domain = uint8arraysFromString(domain)\n  const domainLength = varint.encode(domain.byteLength)\n  const payloadTypeLength = varint.encode(payloadType.length)\n  const payloadLength = varint.encode(payload.length)\n\n  return uint8arraysConcat([\n    new Uint8Array(domainLength),\n    domain,\n    new Uint8Array(payloadTypeLength),\n    payloadType,\n    new Uint8Array(payloadLength),\n    payload\n  ])\n}\n\n/**\n * Unmarshal a serialized Envelope protobuf message.\n * @param {Uint8Array} data\n * @return {Promise<Envelope>}\n */\nEnvelope.createFromProtobuf = async (data) => {\n  const envelopeData = Protobuf.decode(data)\n  const peerId = await PeerId.createFromPubKey(envelopeData.public_key)\n\n  return new Envelope({\n    peerId,\n    payloadType: envelopeData.payload_type,\n    payload: envelopeData.payload,\n    signature: envelopeData.signature\n  })\n}\n\n/**\n* Seal marshals the given Record, places the marshaled bytes inside an Envelope\n* and signs it with the given peerId's private key.\n* @async\n* @param {Record} record\n* @param {PeerId} peerId\n* @return {Envelope}\n*/\nEnvelope.seal = async (record, peerId) => {\n  const domain = record.domain\n  const payloadType = record.codec\n  const payload = record.marshal()\n\n  const signData = formatSignaturePayload(domain, payloadType, payload)\n  const signature = await peerId.privKey.sign(signData)\n\n  return new Envelope({\n    peerId,\n    payloadType,\n    payload,\n    signature\n  })\n}\n\n/**\n * Open and certify a given marshalled envelope.\n * Data is unmarshalled and the signature validated for the given domain.\n * @param {Uint8Array} data\n * @param {string} domain\n * @return {Envelope}\n */\nEnvelope.openAndCertify = async (data, domain) => {\n  const envelope = await Envelope.createFromProtobuf(data)\n  const valid = await envelope.validate(domain)\n\n  if (!valid) {\n    throw errCode(new Error('envelope signature is not valid for the given domain'), codes.ERR_SIGNATURE_NOT_VALID)\n  }\n\n  return envelope\n}\n\nmodule.exports = Envelope\n"]},"metadata":{},"sourceType":"script"}