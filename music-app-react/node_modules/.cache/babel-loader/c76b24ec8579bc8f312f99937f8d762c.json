{"ast":null,"code":"'use strict';\n\nconst repoInit = require('./init');\n\nconst {\n  MissingRepoOptionsError,\n  NotInitializedRepoError\n} = require('../errors');\n\nconst {\n  VERSION_KEY,\n  createStore\n} = require('../utils');\n\nconst uint8ArrayFromString = require('uint8arrays/from-string');\n\nexports.getVersion = getVersion;\n/**\n * Function that has responsibility to retrieve version of repo from its root datastore's instance.\n * This function needs to be cross-repo-version functional to be able to fetch any version number,\n * even in case of change of repo's versioning.\n *\n * @param {string} path\n * @param {Object} repoOptions Options used to create a repo, the same as pased to ipfs-repo\n * @returns {Promise<int>}\n */\n\nasync function getVersion(path, repoOptions) {\n  if (!(await repoInit.isRepoInitialized(path, repoOptions))) {\n    throw new NotInitializedRepoError(`Repo in path ${path} is not initialized!`);\n  }\n\n  if (!repoOptions) {\n    throw new MissingRepoOptionsError('Please pass repo options when trying to open a repo');\n  }\n\n  const store = await createStore(path, 'root', repoOptions);\n  await store.open();\n  const version = parseInt(await store.get(VERSION_KEY));\n  await store.close();\n  return version;\n}\n/**\n * Function for setting a version in cross-repo-version manner.\n *\n * @param {string} path\n * @param {int} version\n * @param {Object} repoOptions Options used to create a repo, the same as pased to ipfs-repo\n * @returns {Promise<void>}\n */\n\n\nasync function setVersion(path, version, repoOptions) {\n  if (!repoOptions) {\n    throw new MissingRepoOptionsError('Please pass repo options when trying to open a repo');\n  }\n\n  const store = await createStore(path, 'root', repoOptions);\n  await store.open();\n  await store.put(VERSION_KEY, uint8ArrayFromString(String(version)));\n  await store.close();\n}\n\nexports.setVersion = setVersion;","map":{"version":3,"sources":["/home/user/orbit-playground/music-app/node_modules/ipfs-repo-migrations/src/repo/version.js"],"names":["repoInit","require","MissingRepoOptionsError","NotInitializedRepoError","VERSION_KEY","createStore","uint8ArrayFromString","exports","getVersion","path","repoOptions","isRepoInitialized","store","open","version","parseInt","get","close","setVersion","put","String"],"mappings":"AAAA;;AAEA,MAAMA,QAAQ,GAAGC,OAAO,CAAC,QAAD,CAAxB;;AACA,MAAM;AAAEC,EAAAA,uBAAF;AAA2BC,EAAAA;AAA3B,IAAuDF,OAAO,CAAC,WAAD,CAApE;;AACA,MAAM;AAAEG,EAAAA,WAAF;AAAeC,EAAAA;AAAf,IAA+BJ,OAAO,CAAC,UAAD,CAA5C;;AACA,MAAMK,oBAAoB,GAAGL,OAAO,CAAC,yBAAD,CAApC;;AAEAM,OAAO,CAACC,UAAR,GAAqBA,UAArB;AAEA;;;;;;;;;;AASA,eAAeA,UAAf,CAA2BC,IAA3B,EAAiCC,WAAjC,EAA8C;AAC5C,MAAI,EAAE,MAAMV,QAAQ,CAACW,iBAAT,CAA2BF,IAA3B,EAAiCC,WAAjC,CAAR,CAAJ,EAA4D;AAC1D,UAAM,IAAIP,uBAAJ,CAA6B,gBAAeM,IAAK,sBAAjD,CAAN;AACD;;AAED,MAAI,CAACC,WAAL,EAAkB;AAChB,UAAM,IAAIR,uBAAJ,CAA4B,qDAA5B,CAAN;AACD;;AAED,QAAMU,KAAK,GAAG,MAAMP,WAAW,CAACI,IAAD,EAAO,MAAP,EAAeC,WAAf,CAA/B;AACA,QAAME,KAAK,CAACC,IAAN,EAAN;AAEA,QAAMC,OAAO,GAAGC,QAAQ,CAAC,MAAMH,KAAK,CAACI,GAAN,CAAUZ,WAAV,CAAP,CAAxB;AACA,QAAMQ,KAAK,CAACK,KAAN,EAAN;AAEA,SAAOH,OAAP;AACD;AAED;;;;;;;;;;AAQA,eAAeI,UAAf,CAA2BT,IAA3B,EAAiCK,OAAjC,EAA0CJ,WAA1C,EAAuD;AACrD,MAAI,CAACA,WAAL,EAAkB;AAChB,UAAM,IAAIR,uBAAJ,CAA4B,qDAA5B,CAAN;AACD;;AAED,QAAMU,KAAK,GAAG,MAAMP,WAAW,CAACI,IAAD,EAAO,MAAP,EAAeC,WAAf,CAA/B;AACA,QAAME,KAAK,CAACC,IAAN,EAAN;AACA,QAAMD,KAAK,CAACO,GAAN,CAAUf,WAAV,EAAuBE,oBAAoB,CAACc,MAAM,CAACN,OAAD,CAAP,CAA3C,CAAN;AACA,QAAMF,KAAK,CAACK,KAAN,EAAN;AACD;;AAEDV,OAAO,CAACW,UAAR,GAAqBA,UAArB","sourcesContent":["'use strict'\n\nconst repoInit = require('./init')\nconst { MissingRepoOptionsError, NotInitializedRepoError } = require('../errors')\nconst { VERSION_KEY, createStore } = require('../utils')\nconst uint8ArrayFromString = require('uint8arrays/from-string')\n\nexports.getVersion = getVersion\n\n/**\n * Function that has responsibility to retrieve version of repo from its root datastore's instance.\n * This function needs to be cross-repo-version functional to be able to fetch any version number,\n * even in case of change of repo's versioning.\n *\n * @param {string} path\n * @param {Object} repoOptions Options used to create a repo, the same as pased to ipfs-repo\n * @returns {Promise<int>}\n */\nasync function getVersion (path, repoOptions) {\n  if (!(await repoInit.isRepoInitialized(path, repoOptions))) {\n    throw new NotInitializedRepoError(`Repo in path ${path} is not initialized!`)\n  }\n\n  if (!repoOptions) {\n    throw new MissingRepoOptionsError('Please pass repo options when trying to open a repo')\n  }\n\n  const store = await createStore(path, 'root', repoOptions)\n  await store.open()\n\n  const version = parseInt(await store.get(VERSION_KEY))\n  await store.close()\n\n  return version\n}\n\n/**\n * Function for setting a version in cross-repo-version manner.\n *\n * @param {string} path\n * @param {int} version\n * @param {Object} repoOptions Options used to create a repo, the same as pased to ipfs-repo\n * @returns {Promise<void>}\n */\nasync function setVersion (path, version, repoOptions) {\n  if (!repoOptions) {\n    throw new MissingRepoOptionsError('Please pass repo options when trying to open a repo')\n  }\n\n  const store = await createStore(path, 'root', repoOptions)\n  await store.open()\n  await store.put(VERSION_KEY, uint8ArrayFromString(String(version)))\n  await store.close()\n}\n\nexports.setVersion = setVersion\n"]},"metadata":{},"sourceType":"script"}