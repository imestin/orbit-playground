{"ast":null,"code":"'use strict';\n\nconst stream = require('stream');\n\nconst util = require('util');\n\nconst utils = require('./utils');\n\nconst Simple = require('./simple');\n\nconst Decoder = require('./decoder');\n\nconst constants = require('./constants');\n\nconst bignumber = require('bignumber.js').BigNumber;\n\nconst NoFilter = require('nofilter');\n\nconst MT = constants.MT;\nconst NUMBYTES = constants.NUMBYTES;\nconst SYMS = constants.SYMS;\n\nfunction plural(c) {\n  if (c > 1) {\n    return 's';\n  } else {\n    return '';\n  }\n}\n/**\n * Generate the expanded format of RFC 7049, section 2.2.1\n *\n * @extends {stream.Transform}\n */\n\n\nclass Commented extends stream.Transform {\n  /**\n   * Create a CBOR commenter.\n   *\n   * @param {object} [options={}] - Stream options\n   * @param {number} [options.max_depth=10] - how many times to indent\n   *   the dashes\n   */\n  constructor(options) {\n    const opts = Object.assign({\n      max_depth: 10\n    }, options, {\n      readableObjectMode: false,\n      writableObjectMode: false\n    });\n    const max_depth = opts.max_depth;\n    delete opts.max_depth;\n    super(opts);\n    this.depth = 1;\n    this.max_depth = max_depth;\n    this.all = new NoFilter();\n    this.parser = new Decoder(opts);\n    this.parser.on('value', this._on_value.bind(this));\n    this.parser.on('start', this._on_start.bind(this));\n    this.parser.on('start-string', this._on_start_string.bind(this));\n    this.parser.on('stop', this._on_stop.bind(this));\n    this.parser.on('more-bytes', this._on_more.bind(this));\n    this.parser.on('error', this._on_error.bind(this));\n    this.parser.on('data', this._on_data.bind(this));\n    this.parser.bs.on('read', this._on_read.bind(this));\n  }\n  /**\n   * @private\n   */\n\n\n  _transform(fresh, encoding, cb) {\n    this.parser.write(fresh, encoding, cb);\n  }\n  /**\n   * @private\n   */\n\n\n  _flush(cb) {\n    // TODO: find the test that covers this, and look at the return value\n    return this.parser._flush(cb);\n  }\n  /**\n   * @callback commentCallback\n   * @param {Error} [error] - if one was generated\n   * @param {string} [commented] - the comment string\n   */\n\n  /**\n   * @typedef CommentOptions\n   * @property {number} [max_depth=10] how many times to indent the dashes\n   * @property {string} [encoding='hex'] encoding of the input\n   */\n\n  /**\n   * Comment on an input Buffer or string, creating a string passed to the\n   * callback.  If callback not specified, a promise is returned.\n   *\n   * @static\n   * @param {string|Buffer} input\n   * @param {CommentOptions|commentCallback|string} [options] or callback\n   * @param {commentCallback=} cb\n   * @returns {Promise} if cb not specified\n   */\n\n\n  static comment(input, options, cb) {\n    if (input == null) {\n      throw new Error('input required');\n    }\n\n    let encoding = typeof input === 'string' ? 'hex' : void 0;\n    let max_depth = 10;\n\n    switch (typeof options) {\n      case 'function':\n        cb = options;\n        break;\n\n      case 'string':\n        encoding = options;\n        break;\n\n      case 'number':\n        max_depth = options;\n        break;\n\n      case 'object':\n        const ref1 = options.encoding;\n        const ref2 = options.max_depth;\n        encoding = ref1 != null ? ref1 : encoding;\n        max_depth = ref2 != null ? ref2 : max_depth;\n        break;\n\n      case 'undefined':\n        break;\n\n      default:\n        throw new Error('Unknown option type');\n    }\n\n    const bs = new NoFilter();\n    const d = new Commented({\n      max_depth\n    });\n    let p = null;\n\n    if (typeof cb === 'function') {\n      d.on('end', () => {\n        cb(null, bs.toString('utf8'));\n      });\n      d.on('error', cb);\n    } else {\n      p = new Promise((resolve, reject) => {\n        d.on('end', () => {\n          resolve(bs.toString('utf8'));\n        });\n        return d.on('error', reject);\n      });\n    }\n\n    d.pipe(bs);\n    d.end(input, encoding);\n    return p;\n  }\n  /**\n   * @private\n   */\n\n\n  _on_error(er) {\n    return this.push('ERROR: ') && this.push(er.toString()) && this.push('\\n');\n  }\n  /**\n   * @private\n   */\n\n\n  _on_read(buf) {\n    this.all.write(buf);\n    const hex = buf.toString('hex');\n    this.push(new Array(this.depth + 1).join('  '));\n    this.push(hex);\n    let ind = (this.max_depth - this.depth) * 2;\n    ind -= hex.length;\n\n    if (ind < 1) {\n      ind = 1;\n    }\n\n    this.push(new Array(ind + 1).join(' '));\n    return this.push('-- ');\n  }\n  /**\n   * @private\n   */\n\n\n  _on_more(mt, len, parent_mt, pos) {\n    this.depth++;\n    let desc = '';\n\n    switch (mt) {\n      case MT.POS_INT:\n        desc = 'Positive number,';\n        break;\n\n      case MT.NEG_INT:\n        desc = 'Negative number,';\n        break;\n\n      case MT.ARRAY:\n        desc = 'Array, length';\n        break;\n\n      case MT.MAP:\n        desc = 'Map, count';\n        break;\n\n      case MT.BYTE_STRING:\n        desc = 'Bytes, length';\n        break;\n\n      case MT.UTF8_STRING:\n        desc = 'String, length';\n        break;\n\n      case MT.SIMPLE_FLOAT:\n        if (len === 1) {\n          desc = 'Simple value,';\n        } else {\n          desc = 'Float,';\n        }\n\n        break;\n    }\n\n    return this.push(desc + ' next ' + len + ' byte' + plural(len) + '\\n');\n  }\n  /**\n   * @private\n   */\n\n\n  _on_start_string(mt, tag, parent_mt, pos) {\n    this.depth++;\n    let desc = '';\n\n    switch (mt) {\n      case MT.BYTE_STRING:\n        desc = 'Bytes, length: ' + tag;\n        break;\n\n      case MT.UTF8_STRING:\n        desc = 'String, length: ' + tag.toString();\n        break;\n    }\n\n    return this.push(desc + '\\n');\n  }\n  /**\n   * @private\n   */\n\n\n  _on_start(mt, tag, parent_mt, pos) {\n    this.depth++;\n\n    if (tag !== SYMS.BREAK) {\n      switch (parent_mt) {\n        case MT.ARRAY:\n          this.push(`[${pos}], `);\n          break;\n\n        case MT.MAP:\n          if (pos % 2) {\n            this.push(`{Val:${Math.floor(pos / 2)}}, `);\n          } else {\n            this.push(`{Key:${Math.floor(pos / 2)}}, `);\n          }\n\n          break;\n      }\n    }\n\n    switch (mt) {\n      case MT.TAG:\n        this.push(`Tag #${tag}`);\n        break;\n\n      case MT.ARRAY:\n        if (tag === SYMS.STREAM) {\n          this.push('Array (streaming)');\n        } else {\n          this.push(`Array, ${tag} item${plural(tag)}`);\n        }\n\n        break;\n\n      case MT.MAP:\n        if (tag === SYMS.STREAM) {\n          this.push('Map (streaming)');\n        } else {\n          this.push(`Map, ${tag} pair${plural(tag)}`);\n        }\n\n        break;\n\n      case MT.BYTE_STRING:\n        this.push('Bytes (streaming)');\n        break;\n\n      case MT.UTF8_STRING:\n        this.push('String (streaming)');\n        break;\n    }\n\n    return this.push('\\n');\n  }\n  /**\n   * @private\n   */\n\n\n  _on_stop(mt) {\n    return this.depth--;\n  }\n  /**\n   * @private\n   */\n\n\n  _on_value(val, parent_mt, pos, ai) {\n    if (val !== SYMS.BREAK) {\n      switch (parent_mt) {\n        case MT.ARRAY:\n          this.push(`[${pos}], `);\n          break;\n\n        case MT.MAP:\n          if (pos % 2) {\n            this.push(`{Val:${Math.floor(pos / 2)}}, `);\n          } else {\n            this.push(`{Key:${Math.floor(pos / 2)}}, `);\n          }\n\n          break;\n      }\n    }\n\n    if (val === SYMS.BREAK) {\n      this.push('BREAK\\n');\n    } else if (val === SYMS.NULL) {\n      this.push('null\\n');\n    } else if (val === SYMS.UNDEFINED) {\n      this.push('undefined\\n');\n    } else if (typeof val === 'string') {\n      this.depth--;\n\n      if (val.length > 0) {\n        this.push(JSON.stringify(val));\n        this.push('\\n');\n      }\n    } else if (Buffer.isBuffer(val)) {\n      this.depth--;\n\n      if (val.length > 0) {\n        this.push(val.toString('hex'));\n        this.push('\\n');\n      }\n    } else if (val instanceof bignumber) {\n      this.push(val.toString());\n      this.push('\\n');\n    } else {\n      this.push(util.inspect(val));\n      this.push('\\n');\n    }\n\n    switch (ai) {\n      case NUMBYTES.ONE:\n      case NUMBYTES.TWO:\n      case NUMBYTES.FOUR:\n      case NUMBYTES.EIGHT:\n        this.depth--;\n    }\n  }\n  /**\n   * @private\n   */\n\n\n  _on_data() {\n    this.push('0x');\n    this.push(this.all.read().toString('hex'));\n    return this.push('\\n');\n  }\n\n}\n\nmodule.exports = Commented;","map":{"version":3,"sources":["/home/user/orbit-playground/music-app/node_modules/cbor/lib/commented.js"],"names":["stream","require","util","utils","Simple","Decoder","constants","bignumber","BigNumber","NoFilter","MT","NUMBYTES","SYMS","plural","c","Commented","Transform","constructor","options","opts","Object","assign","max_depth","readableObjectMode","writableObjectMode","depth","all","parser","on","_on_value","bind","_on_start","_on_start_string","_on_stop","_on_more","_on_error","_on_data","bs","_on_read","_transform","fresh","encoding","cb","write","_flush","comment","input","Error","ref1","ref2","d","p","toString","Promise","resolve","reject","pipe","end","er","push","buf","hex","Array","join","ind","length","mt","len","parent_mt","pos","desc","POS_INT","NEG_INT","ARRAY","MAP","BYTE_STRING","UTF8_STRING","SIMPLE_FLOAT","tag","BREAK","Math","floor","TAG","STREAM","val","ai","NULL","UNDEFINED","JSON","stringify","Buffer","isBuffer","inspect","ONE","TWO","FOUR","EIGHT","read","module","exports"],"mappings":"AAAA;;AAEA,MAAMA,MAAM,GAAGC,OAAO,CAAC,QAAD,CAAtB;;AACA,MAAMC,IAAI,GAAGD,OAAO,CAAC,MAAD,CAApB;;AACA,MAAME,KAAK,GAAGF,OAAO,CAAC,SAAD,CAArB;;AACA,MAAMG,MAAM,GAAGH,OAAO,CAAC,UAAD,CAAtB;;AACA,MAAMI,OAAO,GAAGJ,OAAO,CAAC,WAAD,CAAvB;;AACA,MAAMK,SAAS,GAAGL,OAAO,CAAC,aAAD,CAAzB;;AACA,MAAMM,SAAS,GAAGN,OAAO,CAAC,cAAD,CAAP,CAAwBO,SAA1C;;AACA,MAAMC,QAAQ,GAAGR,OAAO,CAAC,UAAD,CAAxB;;AAEA,MAAMS,EAAE,GAAGJ,SAAS,CAACI,EAArB;AACA,MAAMC,QAAQ,GAAGL,SAAS,CAACK,QAA3B;AACA,MAAMC,IAAI,GAAGN,SAAS,CAACM,IAAvB;;AAEA,SAASC,MAAT,CAAgBC,CAAhB,EAAmB;AACjB,MAAIA,CAAC,GAAG,CAAR,EAAW;AACT,WAAO,GAAP;AACD,GAFD,MAEO;AACL,WAAO,EAAP;AACD;AACF;AAED;;;;;;;AAKA,MAAMC,SAAN,SAAwBf,MAAM,CAACgB,SAA/B,CAAyC;AACvC;;;;;;;AAOAC,EAAAA,WAAW,CAACC,OAAD,EAAU;AACnB,UAAMC,IAAI,GAAGC,MAAM,CAACC,MAAP,CAAc;AACzBC,MAAAA,SAAS,EAAE;AADc,KAAd,EAEVJ,OAFU,EAED;AACVK,MAAAA,kBAAkB,EAAE,KADV;AAEVC,MAAAA,kBAAkB,EAAE;AAFV,KAFC,CAAb;AAMA,UAAMF,SAAS,GAAGH,IAAI,CAACG,SAAvB;AACA,WAAOH,IAAI,CAACG,SAAZ;AACA,UAAMH,IAAN;AAEA,SAAKM,KAAL,GAAa,CAAb;AACA,SAAKH,SAAL,GAAiBA,SAAjB;AACA,SAAKI,GAAL,GAAW,IAAIjB,QAAJ,EAAX;AACA,SAAKkB,MAAL,GAAc,IAAItB,OAAJ,CAAYc,IAAZ,CAAd;AACA,SAAKQ,MAAL,CAAYC,EAAZ,CAAe,OAAf,EAAwB,KAAKC,SAAL,CAAeC,IAAf,CAAoB,IAApB,CAAxB;AACA,SAAKH,MAAL,CAAYC,EAAZ,CAAe,OAAf,EAAwB,KAAKG,SAAL,CAAeD,IAAf,CAAoB,IAApB,CAAxB;AACA,SAAKH,MAAL,CAAYC,EAAZ,CAAe,cAAf,EAA+B,KAAKI,gBAAL,CAAsBF,IAAtB,CAA2B,IAA3B,CAA/B;AACA,SAAKH,MAAL,CAAYC,EAAZ,CAAe,MAAf,EAAuB,KAAKK,QAAL,CAAcH,IAAd,CAAmB,IAAnB,CAAvB;AACA,SAAKH,MAAL,CAAYC,EAAZ,CAAe,YAAf,EAA6B,KAAKM,QAAL,CAAcJ,IAAd,CAAmB,IAAnB,CAA7B;AACA,SAAKH,MAAL,CAAYC,EAAZ,CAAe,OAAf,EAAwB,KAAKO,SAAL,CAAeL,IAAf,CAAoB,IAApB,CAAxB;AACA,SAAKH,MAAL,CAAYC,EAAZ,CAAe,MAAf,EAAuB,KAAKQ,QAAL,CAAcN,IAAd,CAAmB,IAAnB,CAAvB;AACA,SAAKH,MAAL,CAAYU,EAAZ,CAAeT,EAAf,CAAkB,MAAlB,EAA0B,KAAKU,QAAL,CAAcR,IAAd,CAAmB,IAAnB,CAA1B;AACD;AAED;;;;;AAGAS,EAAAA,UAAU,CAACC,KAAD,EAAQC,QAAR,EAAkBC,EAAlB,EAAsB;AAC9B,SAAKf,MAAL,CAAYgB,KAAZ,CAAkBH,KAAlB,EAAyBC,QAAzB,EAAmCC,EAAnC;AACD;AAED;;;;;AAGAE,EAAAA,MAAM,CAACF,EAAD,EAAK;AACT;AACA,WAAO,KAAKf,MAAL,CAAYiB,MAAZ,CAAmBF,EAAnB,CAAP;AACD;AAED;;;;;;AAMA;;;;;;AAKA;;;;;;;;;;;;AAUA,SAAOG,OAAP,CAAeC,KAAf,EAAsB5B,OAAtB,EAA+BwB,EAA/B,EAAmC;AACjC,QAAII,KAAK,IAAI,IAAb,EAAmB;AACjB,YAAM,IAAIC,KAAJ,CAAU,gBAAV,CAAN;AACD;;AACD,QAAIN,QAAQ,GAAI,OAAOK,KAAP,KAAiB,QAAlB,GAA8B,KAA9B,GAAsC,KAAK,CAA1D;AACA,QAAIxB,SAAS,GAAG,EAAhB;;AACA,YAAQ,OAAOJ,OAAf;AACE,WAAK,UAAL;AACEwB,QAAAA,EAAE,GAAGxB,OAAL;AACA;;AACF,WAAK,QAAL;AACEuB,QAAAA,QAAQ,GAAGvB,OAAX;AACA;;AACF,WAAK,QAAL;AACEI,QAAAA,SAAS,GAAGJ,OAAZ;AACA;;AACF,WAAK,QAAL;AACE,cAAM8B,IAAI,GAAG9B,OAAO,CAACuB,QAArB;AACA,cAAMQ,IAAI,GAAG/B,OAAO,CAACI,SAArB;AACAmB,QAAAA,QAAQ,GAAIO,IAAI,IAAI,IAAT,GAAiBA,IAAjB,GAAwBP,QAAnC;AACAnB,QAAAA,SAAS,GAAI2B,IAAI,IAAI,IAAT,GAAiBA,IAAjB,GAAwB3B,SAApC;AACA;;AACF,WAAK,WAAL;AACE;;AACF;AACE,cAAM,IAAIyB,KAAJ,CAAU,qBAAV,CAAN;AAnBJ;;AAqBA,UAAMV,EAAE,GAAG,IAAI5B,QAAJ,EAAX;AACA,UAAMyC,CAAC,GAAG,IAAInC,SAAJ,CAAc;AACtBO,MAAAA;AADsB,KAAd,CAAV;AAGA,QAAI6B,CAAC,GAAG,IAAR;;AACA,QAAI,OAAOT,EAAP,KAAc,UAAlB,EAA8B;AAC5BQ,MAAAA,CAAC,CAACtB,EAAF,CAAK,KAAL,EAAY,MAAM;AAChBc,QAAAA,EAAE,CAAC,IAAD,EAAOL,EAAE,CAACe,QAAH,CAAY,MAAZ,CAAP,CAAF;AACD,OAFD;AAGAF,MAAAA,CAAC,CAACtB,EAAF,CAAK,OAAL,EAAcc,EAAd;AACD,KALD,MAKO;AACLS,MAAAA,CAAC,GAAG,IAAIE,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACnCL,QAAAA,CAAC,CAACtB,EAAF,CAAK,KAAL,EAAY,MAAM;AAChB0B,UAAAA,OAAO,CAACjB,EAAE,CAACe,QAAH,CAAY,MAAZ,CAAD,CAAP;AACD,SAFD;AAGA,eAAOF,CAAC,CAACtB,EAAF,CAAK,OAAL,EAAc2B,MAAd,CAAP;AACD,OALG,CAAJ;AAMD;;AACDL,IAAAA,CAAC,CAACM,IAAF,CAAOnB,EAAP;AACAa,IAAAA,CAAC,CAACO,GAAF,CAAMX,KAAN,EAAaL,QAAb;AACA,WAAOU,CAAP;AACD;AAED;;;;;AAGAhB,EAAAA,SAAS,CAACuB,EAAD,EAAK;AACZ,WAAO,KAAKC,IAAL,CAAU,SAAV,KACL,KAAKA,IAAL,CAAUD,EAAE,CAACN,QAAH,EAAV,CADK,IAEL,KAAKO,IAAL,CAAU,IAAV,CAFF;AAGD;AAED;;;;;AAGArB,EAAAA,QAAQ,CAACsB,GAAD,EAAM;AACZ,SAAKlC,GAAL,CAASiB,KAAT,CAAeiB,GAAf;AACA,UAAMC,GAAG,GAAGD,GAAG,CAACR,QAAJ,CAAa,KAAb,CAAZ;AACA,SAAKO,IAAL,CAAU,IAAIG,KAAJ,CAAU,KAAKrC,KAAL,GAAa,CAAvB,EAA0BsC,IAA1B,CAA+B,IAA/B,CAAV;AACA,SAAKJ,IAAL,CAAUE,GAAV;AACA,QAAIG,GAAG,GAAG,CAAC,KAAK1C,SAAL,GAAiB,KAAKG,KAAvB,IAAgC,CAA1C;AACAuC,IAAAA,GAAG,IAAIH,GAAG,CAACI,MAAX;;AACA,QAAID,GAAG,GAAG,CAAV,EAAa;AACXA,MAAAA,GAAG,GAAG,CAAN;AACD;;AACD,SAAKL,IAAL,CAAU,IAAIG,KAAJ,CAAUE,GAAG,GAAG,CAAhB,EAAmBD,IAAnB,CAAwB,GAAxB,CAAV;AACA,WAAO,KAAKJ,IAAL,CAAU,KAAV,CAAP;AACD;AAED;;;;;AAGAzB,EAAAA,QAAQ,CAACgC,EAAD,EAAKC,GAAL,EAAUC,SAAV,EAAqBC,GAArB,EAA0B;AAChC,SAAK5C,KAAL;AACA,QAAI6C,IAAI,GAAG,EAAX;;AACA,YAAQJ,EAAR;AACE,WAAKxD,EAAE,CAAC6D,OAAR;AACED,QAAAA,IAAI,GAAG,kBAAP;AACA;;AACF,WAAK5D,EAAE,CAAC8D,OAAR;AACEF,QAAAA,IAAI,GAAG,kBAAP;AACA;;AACF,WAAK5D,EAAE,CAAC+D,KAAR;AACEH,QAAAA,IAAI,GAAG,eAAP;AACA;;AACF,WAAK5D,EAAE,CAACgE,GAAR;AACEJ,QAAAA,IAAI,GAAG,YAAP;AACA;;AACF,WAAK5D,EAAE,CAACiE,WAAR;AACEL,QAAAA,IAAI,GAAG,eAAP;AACA;;AACF,WAAK5D,EAAE,CAACkE,WAAR;AACEN,QAAAA,IAAI,GAAG,gBAAP;AACA;;AACF,WAAK5D,EAAE,CAACmE,YAAR;AACE,YAAIV,GAAG,KAAK,CAAZ,EAAe;AACbG,UAAAA,IAAI,GAAG,eAAP;AACD,SAFD,MAEO;AACLA,UAAAA,IAAI,GAAG,QAAP;AACD;;AACD;AAzBJ;;AA2BA,WAAO,KAAKX,IAAL,CAAUW,IAAI,GAAG,QAAP,GAAkBH,GAAlB,GAAwB,OAAxB,GAAmCtD,MAAM,CAACsD,GAAD,CAAzC,GAAkD,IAA5D,CAAP;AACD;AAED;;;;;AAGAnC,EAAAA,gBAAgB,CAACkC,EAAD,EAAKY,GAAL,EAAUV,SAAV,EAAqBC,GAArB,EAA0B;AACxC,SAAK5C,KAAL;AACA,QAAI6C,IAAI,GAAG,EAAX;;AACA,YAAQJ,EAAR;AACE,WAAKxD,EAAE,CAACiE,WAAR;AACEL,QAAAA,IAAI,GAAG,oBAAoBQ,GAA3B;AACA;;AACF,WAAKpE,EAAE,CAACkE,WAAR;AACEN,QAAAA,IAAI,GAAG,qBAAsBQ,GAAG,CAAC1B,QAAJ,EAA7B;AACA;AANJ;;AAQA,WAAO,KAAKO,IAAL,CAAUW,IAAI,GAAG,IAAjB,CAAP;AACD;AAED;;;;;AAGAvC,EAAAA,SAAS,CAACmC,EAAD,EAAKY,GAAL,EAAUV,SAAV,EAAqBC,GAArB,EAA0B;AACjC,SAAK5C,KAAL;;AACA,QAAIqD,GAAG,KAAKlE,IAAI,CAACmE,KAAjB,EAAwB;AACtB,cAAQX,SAAR;AACE,aAAK1D,EAAE,CAAC+D,KAAR;AACE,eAAKd,IAAL,CAAW,IAAGU,GAAI,KAAlB;AACA;;AACF,aAAK3D,EAAE,CAACgE,GAAR;AACE,cAAIL,GAAG,GAAG,CAAV,EAAa;AACX,iBAAKV,IAAL,CAAW,QAAOqB,IAAI,CAACC,KAAL,CAAWZ,GAAG,GAAG,CAAjB,CAAoB,KAAtC;AACD,WAFD,MAEO;AACL,iBAAKV,IAAL,CAAW,QAAOqB,IAAI,CAACC,KAAL,CAAWZ,GAAG,GAAG,CAAjB,CAAoB,KAAtC;AACD;;AACD;AAVJ;AAYD;;AACD,YAAQH,EAAR;AACE,WAAKxD,EAAE,CAACwE,GAAR;AACE,aAAKvB,IAAL,CAAW,QAAOmB,GAAI,EAAtB;AACA;;AACF,WAAKpE,EAAE,CAAC+D,KAAR;AACE,YAAIK,GAAG,KAAKlE,IAAI,CAACuE,MAAjB,EAAyB;AACvB,eAAKxB,IAAL,CAAU,mBAAV;AACD,SAFD,MAEO;AACL,eAAKA,IAAL,CAAW,UAASmB,GAAI,QAAOjE,MAAM,CAACiE,GAAD,CAAM,EAA3C;AACD;;AACD;;AACF,WAAKpE,EAAE,CAACgE,GAAR;AACE,YAAII,GAAG,KAAKlE,IAAI,CAACuE,MAAjB,EAAyB;AACvB,eAAKxB,IAAL,CAAU,iBAAV;AACD,SAFD,MAEO;AACL,eAAKA,IAAL,CAAW,QAAOmB,GAAI,QAAOjE,MAAM,CAACiE,GAAD,CAAM,EAAzC;AACD;;AACD;;AACF,WAAKpE,EAAE,CAACiE,WAAR;AACE,aAAKhB,IAAL,CAAU,mBAAV;AACA;;AACF,WAAKjD,EAAE,CAACkE,WAAR;AACE,aAAKjB,IAAL,CAAU,oBAAV;AACA;AAvBJ;;AAyBA,WAAO,KAAKA,IAAL,CAAU,IAAV,CAAP;AACD;AAED;;;;;AAGA1B,EAAAA,QAAQ,CAACiC,EAAD,EAAK;AACX,WAAO,KAAKzC,KAAL,EAAP;AACD;AAED;;;;;AAGAI,EAAAA,SAAS,CAACuD,GAAD,EAAMhB,SAAN,EAAiBC,GAAjB,EAAsBgB,EAAtB,EAA0B;AACjC,QAAID,GAAG,KAAKxE,IAAI,CAACmE,KAAjB,EAAwB;AACtB,cAAQX,SAAR;AACE,aAAK1D,EAAE,CAAC+D,KAAR;AACE,eAAKd,IAAL,CAAW,IAAGU,GAAI,KAAlB;AACA;;AACF,aAAK3D,EAAE,CAACgE,GAAR;AACE,cAAIL,GAAG,GAAG,CAAV,EAAa;AACX,iBAAKV,IAAL,CAAW,QAAOqB,IAAI,CAACC,KAAL,CAAWZ,GAAG,GAAG,CAAjB,CAAoB,KAAtC;AACD,WAFD,MAEO;AACL,iBAAKV,IAAL,CAAW,QAAOqB,IAAI,CAACC,KAAL,CAAWZ,GAAG,GAAG,CAAjB,CAAoB,KAAtC;AACD;;AACD;AAVJ;AAYD;;AAED,QAAIe,GAAG,KAAKxE,IAAI,CAACmE,KAAjB,EAAwB;AACtB,WAAKpB,IAAL,CAAU,SAAV;AACD,KAFD,MAEO,IAAIyB,GAAG,KAAKxE,IAAI,CAAC0E,IAAjB,EAAuB;AAC5B,WAAK3B,IAAL,CAAU,QAAV;AACD,KAFM,MAEA,IAAIyB,GAAG,KAAKxE,IAAI,CAAC2E,SAAjB,EAA4B;AACjC,WAAK5B,IAAL,CAAU,aAAV;AACD,KAFM,MAEA,IAAI,OAAOyB,GAAP,KAAe,QAAnB,EAA6B;AAClC,WAAK3D,KAAL;;AACA,UAAI2D,GAAG,CAACnB,MAAJ,GAAa,CAAjB,EAAqB;AACnB,aAAKN,IAAL,CAAU6B,IAAI,CAACC,SAAL,CAAeL,GAAf,CAAV;AACA,aAAKzB,IAAL,CAAU,IAAV;AACD;AACF,KANM,MAMA,IAAI+B,MAAM,CAACC,QAAP,CAAgBP,GAAhB,CAAJ,EAA0B;AAC/B,WAAK3D,KAAL;;AACA,UAAI2D,GAAG,CAACnB,MAAJ,GAAa,CAAjB,EAAoB;AAClB,aAAKN,IAAL,CAAUyB,GAAG,CAAChC,QAAJ,CAAa,KAAb,CAAV;AACA,aAAKO,IAAL,CAAU,IAAV;AACD;AACF,KANM,MAMA,IAAIyB,GAAG,YAAY7E,SAAnB,EAA8B;AACnC,WAAKoD,IAAL,CAAUyB,GAAG,CAAChC,QAAJ,EAAV;AACA,WAAKO,IAAL,CAAU,IAAV;AACD,KAHM,MAGA;AACL,WAAKA,IAAL,CAAUzD,IAAI,CAAC0F,OAAL,CAAaR,GAAb,CAAV;AACA,WAAKzB,IAAL,CAAU,IAAV;AACD;;AAED,YAAQ0B,EAAR;AACE,WAAK1E,QAAQ,CAACkF,GAAd;AACA,WAAKlF,QAAQ,CAACmF,GAAd;AACA,WAAKnF,QAAQ,CAACoF,IAAd;AACA,WAAKpF,QAAQ,CAACqF,KAAd;AACE,aAAKvE,KAAL;AALJ;AAOD;AAED;;;;;AAGAW,EAAAA,QAAQ,GAAG;AACT,SAAKuB,IAAL,CAAU,IAAV;AACA,SAAKA,IAAL,CAAU,KAAKjC,GAAL,CAASuE,IAAT,GAAgB7C,QAAhB,CAAyB,KAAzB,CAAV;AACA,WAAO,KAAKO,IAAL,CAAU,IAAV,CAAP;AACD;;AAzTsC;;AA4TzCuC,MAAM,CAACC,OAAP,GAAiBpF,SAAjB","sourcesContent":["'use strict'\n\nconst stream = require('stream')\nconst util = require('util')\nconst utils = require('./utils')\nconst Simple = require('./simple')\nconst Decoder = require('./decoder')\nconst constants = require('./constants')\nconst bignumber = require('bignumber.js').BigNumber\nconst NoFilter = require('nofilter')\n\nconst MT = constants.MT\nconst NUMBYTES = constants.NUMBYTES\nconst SYMS = constants.SYMS\n\nfunction plural(c) {\n  if (c > 1) {\n    return 's'\n  } else {\n    return ''\n  }\n}\n\n/**\n * Generate the expanded format of RFC 7049, section 2.2.1\n *\n * @extends {stream.Transform}\n */\nclass Commented extends stream.Transform {\n  /**\n   * Create a CBOR commenter.\n   *\n   * @param {object} [options={}] - Stream options\n   * @param {number} [options.max_depth=10] - how many times to indent\n   *   the dashes\n   */\n  constructor(options) {\n    const opts = Object.assign({\n      max_depth: 10\n    }, options, {\n      readableObjectMode: false,\n      writableObjectMode: false\n    })\n    const max_depth = opts.max_depth\n    delete opts.max_depth\n    super(opts)\n\n    this.depth = 1\n    this.max_depth = max_depth\n    this.all = new NoFilter()\n    this.parser = new Decoder(opts)\n    this.parser.on('value', this._on_value.bind(this))\n    this.parser.on('start', this._on_start.bind(this))\n    this.parser.on('start-string', this._on_start_string.bind(this))\n    this.parser.on('stop', this._on_stop.bind(this))\n    this.parser.on('more-bytes', this._on_more.bind(this))\n    this.parser.on('error', this._on_error.bind(this))\n    this.parser.on('data', this._on_data.bind(this))\n    this.parser.bs.on('read', this._on_read.bind(this))\n  }\n\n  /**\n   * @private\n   */\n  _transform(fresh, encoding, cb) {\n    this.parser.write(fresh, encoding, cb)\n  }\n\n  /**\n   * @private\n   */\n  _flush(cb) {\n    // TODO: find the test that covers this, and look at the return value\n    return this.parser._flush(cb)\n  }\n\n  /**\n   * @callback commentCallback\n   * @param {Error} [error] - if one was generated\n   * @param {string} [commented] - the comment string\n   */\n\n  /**\n   * @typedef CommentOptions\n   * @property {number} [max_depth=10] how many times to indent the dashes\n   * @property {string} [encoding='hex'] encoding of the input\n   */\n  /**\n   * Comment on an input Buffer or string, creating a string passed to the\n   * callback.  If callback not specified, a promise is returned.\n   *\n   * @static\n   * @param {string|Buffer} input\n   * @param {CommentOptions|commentCallback|string} [options] or callback\n   * @param {commentCallback=} cb\n   * @returns {Promise} if cb not specified\n   */\n  static comment(input, options, cb) {\n    if (input == null) {\n      throw new Error('input required')\n    }\n    let encoding = (typeof input === 'string') ? 'hex' : void 0\n    let max_depth = 10\n    switch (typeof options) {\n      case 'function':\n        cb = options\n        break\n      case 'string':\n        encoding = options\n        break\n      case 'number':\n        max_depth = options\n        break\n      case 'object':\n        const ref1 = options.encoding\n        const ref2 = options.max_depth\n        encoding = (ref1 != null) ? ref1 : encoding\n        max_depth = (ref2 != null) ? ref2 : max_depth\n        break\n      case 'undefined':\n        break\n      default:\n        throw new Error('Unknown option type')\n    }\n    const bs = new NoFilter()\n    const d = new Commented({\n      max_depth\n    })\n    let p = null\n    if (typeof cb === 'function') {\n      d.on('end', () => {\n        cb(null, bs.toString('utf8'))\n      })\n      d.on('error', cb)\n    } else {\n      p = new Promise((resolve, reject) => {\n        d.on('end', () => {\n          resolve(bs.toString('utf8'))\n        })\n        return d.on('error', reject)\n      })\n    }\n    d.pipe(bs)\n    d.end(input, encoding)\n    return p\n  }\n\n  /**\n   * @private\n   */\n  _on_error(er) {\n    return this.push('ERROR: ') &&\n      this.push(er.toString()) &&\n      this.push('\\n')\n  }\n\n  /**\n   * @private\n   */\n  _on_read(buf) {\n    this.all.write(buf)\n    const hex = buf.toString('hex')\n    this.push(new Array(this.depth + 1).join('  '))\n    this.push(hex)\n    let ind = (this.max_depth - this.depth) * 2\n    ind -= hex.length\n    if (ind < 1) {\n      ind = 1\n    }\n    this.push(new Array(ind + 1).join(' '))\n    return this.push('-- ')\n  }\n\n  /**\n   * @private\n   */\n  _on_more(mt, len, parent_mt, pos) {\n    this.depth++\n    let desc = ''\n    switch (mt) {\n      case MT.POS_INT:\n        desc = 'Positive number,'\n        break\n      case MT.NEG_INT:\n        desc = 'Negative number,'\n        break\n      case MT.ARRAY:\n        desc = 'Array, length'\n        break\n      case MT.MAP:\n        desc = 'Map, count'\n        break\n      case MT.BYTE_STRING:\n        desc = 'Bytes, length'\n        break\n      case MT.UTF8_STRING:\n        desc = 'String, length'\n        break\n      case MT.SIMPLE_FLOAT:\n        if (len === 1) {\n          desc = 'Simple value,'\n        } else {\n          desc = 'Float,'\n        }\n        break\n    }\n    return this.push(desc + ' next ' + len + ' byte' + (plural(len)) + '\\n')\n  }\n\n  /**\n   * @private\n   */\n  _on_start_string(mt, tag, parent_mt, pos) {\n    this.depth++\n    let desc = ''\n    switch (mt) {\n      case MT.BYTE_STRING:\n        desc = 'Bytes, length: ' + tag\n        break\n      case MT.UTF8_STRING:\n        desc = 'String, length: ' + (tag.toString())\n        break\n    }\n    return this.push(desc + '\\n')\n  }\n\n  /**\n   * @private\n   */\n  _on_start(mt, tag, parent_mt, pos) {\n    this.depth++\n    if (tag !== SYMS.BREAK) {\n      switch (parent_mt) {\n        case MT.ARRAY:\n          this.push(`[${pos}], `)\n          break\n        case MT.MAP:\n          if (pos % 2) {\n            this.push(`{Val:${Math.floor(pos / 2)}}, `)\n          } else {\n            this.push(`{Key:${Math.floor(pos / 2)}}, `)\n          }\n          break\n      }\n    }\n    switch (mt) {\n      case MT.TAG:\n        this.push(`Tag #${tag}`)\n        break\n      case MT.ARRAY:\n        if (tag === SYMS.STREAM) {\n          this.push('Array (streaming)')\n        } else {\n          this.push(`Array, ${tag} item${plural(tag)}`)\n        }\n        break\n      case MT.MAP:\n        if (tag === SYMS.STREAM) {\n          this.push('Map (streaming)')\n        } else {\n          this.push(`Map, ${tag} pair${plural(tag)}`)\n        }\n        break\n      case MT.BYTE_STRING:\n        this.push('Bytes (streaming)')\n        break\n      case MT.UTF8_STRING:\n        this.push('String (streaming)')\n        break\n    }\n    return this.push('\\n')\n  }\n\n  /**\n   * @private\n   */\n  _on_stop(mt) {\n    return this.depth--\n  }\n\n  /**\n   * @private\n   */\n  _on_value(val, parent_mt, pos, ai) {\n    if (val !== SYMS.BREAK) {\n      switch (parent_mt) {\n        case MT.ARRAY:\n          this.push(`[${pos}], `)\n          break\n        case MT.MAP:\n          if (pos % 2) {\n            this.push(`{Val:${Math.floor(pos / 2)}}, `)\n          } else {\n            this.push(`{Key:${Math.floor(pos / 2)}}, `)\n          }\n          break\n      }\n    }\n\n    if (val === SYMS.BREAK) {\n      this.push('BREAK\\n')\n    } else if (val === SYMS.NULL) {\n      this.push('null\\n')\n    } else if (val === SYMS.UNDEFINED) {\n      this.push('undefined\\n')\n    } else if (typeof val === 'string') {\n      this.depth--\n      if (val.length > 0 ) {\n        this.push(JSON.stringify(val))\n        this.push('\\n')\n      }\n    } else if (Buffer.isBuffer(val)) {\n      this.depth--\n      if (val.length > 0) {\n        this.push(val.toString('hex'))\n        this.push('\\n')\n      }\n    } else if (val instanceof bignumber) {\n      this.push(val.toString())\n      this.push('\\n')\n    } else {\n      this.push(util.inspect(val))\n      this.push('\\n')\n    }\n\n    switch (ai) {\n      case NUMBYTES.ONE:\n      case NUMBYTES.TWO:\n      case NUMBYTES.FOUR:\n      case NUMBYTES.EIGHT:\n        this.depth--\n    }\n  }\n\n  /**\n   * @private\n   */\n  _on_data() {\n    this.push('0x')\n    this.push(this.all.read().toString('hex'))\n    return this.push('\\n')\n  }\n}\n\nmodule.exports = Commented\n"]},"metadata":{},"sourceType":"script"}