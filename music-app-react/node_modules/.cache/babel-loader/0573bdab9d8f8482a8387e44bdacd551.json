{"ast":null,"code":"'use strict';\n\nconst Channel = require('ipfs-pubsub-1on1');\n\nconst Logger = require('logplease');\n\nconst logger = Logger.create('exchange-heads', {\n  color: Logger.Colors.Yellow\n});\nLogger.setLogLevel('ERROR');\n\nconst getHeadsForDatabase = async store => {\n  if (!(store && store._cache)) return [];\n  const localHeads = (await store._cache.get(store.localHeadsPath)) || [];\n  const remoteHeads = (await store._cache.get(store.remoteHeadsPath)) || [];\n  return [...localHeads, ...remoteHeads];\n};\n\nconst exchangeHeads = async (ipfs, address, peer, getStore, getDirectConnection, onMessage, onChannelCreated) => {\n  const _handleMessage = message => {\n    const msg = JSON.parse(Buffer.from(message.data).toString());\n    const {\n      address,\n      heads\n    } = msg;\n    onMessage(address, heads);\n  };\n\n  let channel = getDirectConnection(peer);\n\n  if (!channel) {\n    try {\n      logger.debug(`Create a channel to ${peer}`);\n      channel = await Channel.open(ipfs, peer);\n      channel.on('message', _handleMessage);\n      logger.debug(`Channel created to ${peer}`);\n      onChannelCreated(channel);\n    } catch (e) {\n      logger.error(e);\n    }\n  } // Wait for the direct channel to be fully connected\n\n\n  await channel.connect();\n  logger.debug(`Connected to ${peer}`); // Send the heads if we have any\n\n  const heads = await getHeadsForDatabase(getStore(address));\n  logger.debug(`Send latest heads of '${address}':\\n`, JSON.stringify(heads.map(e => e.hash), null, 2));\n\n  if (heads) {\n    await channel.send(JSON.stringify({\n      address: address,\n      heads: heads\n    }));\n  }\n\n  return channel;\n};\n\nmodule.exports = exchangeHeads;","map":{"version":3,"sources":["/home/user/orbit-playground/music-app/node_modules/orbit-db/src/exchange-heads.js"],"names":["Channel","require","Logger","logger","create","color","Colors","Yellow","setLogLevel","getHeadsForDatabase","store","_cache","localHeads","get","localHeadsPath","remoteHeads","remoteHeadsPath","exchangeHeads","ipfs","address","peer","getStore","getDirectConnection","onMessage","onChannelCreated","_handleMessage","message","msg","JSON","parse","Buffer","from","data","toString","heads","channel","debug","open","on","e","error","connect","stringify","map","hash","send","module","exports"],"mappings":"AAAA;;AAEA,MAAMA,OAAO,GAAGC,OAAO,CAAC,kBAAD,CAAvB;;AAEA,MAAMC,MAAM,GAAGD,OAAO,CAAC,WAAD,CAAtB;;AACA,MAAME,MAAM,GAAGD,MAAM,CAACE,MAAP,CAAc,gBAAd,EAAgC;AAAEC,EAAAA,KAAK,EAAEH,MAAM,CAACI,MAAP,CAAcC;AAAvB,CAAhC,CAAf;AACAL,MAAM,CAACM,WAAP,CAAmB,OAAnB;;AAEA,MAAMC,mBAAmB,GAAG,MAAMC,KAAN,IAAe;AACzC,MAAI,EAAEA,KAAK,IAAIA,KAAK,CAACC,MAAjB,CAAJ,EAA8B,OAAO,EAAP;AAC9B,QAAMC,UAAU,GAAG,OAAMF,KAAK,CAACC,MAAN,CAAaE,GAAb,CAAiBH,KAAK,CAACI,cAAvB,CAAN,KAAgD,EAAnE;AACA,QAAMC,WAAW,GAAG,OAAML,KAAK,CAACC,MAAN,CAAaE,GAAb,CAAiBH,KAAK,CAACM,eAAvB,CAAN,KAAiD,EAArE;AACA,SAAO,CAAC,GAAGJ,UAAJ,EAAgB,GAAGG,WAAnB,CAAP;AACD,CALD;;AAOA,MAAME,aAAa,GAAG,OAAOC,IAAP,EAAaC,OAAb,EAAsBC,IAAtB,EAA4BC,QAA5B,EAAsCC,mBAAtC,EAA2DC,SAA3D,EAAsEC,gBAAtE,KAA2F;AAC/G,QAAMC,cAAc,GAAGC,OAAO,IAAI;AAChC,UAAMC,GAAG,GAAGC,IAAI,CAACC,KAAL,CAAWC,MAAM,CAACC,IAAP,CAAYL,OAAO,CAACM,IAApB,EAA0BC,QAA1B,EAAX,CAAZ;AACA,UAAM;AAAEd,MAAAA,OAAF;AAAWe,MAAAA;AAAX,QAAqBP,GAA3B;AACAJ,IAAAA,SAAS,CAACJ,OAAD,EAAUe,KAAV,CAAT;AACD,GAJD;;AAMA,MAAIC,OAAO,GAAGb,mBAAmB,CAACF,IAAD,CAAjC;;AACA,MAAI,CAACe,OAAL,EAAc;AACZ,QAAI;AACFhC,MAAAA,MAAM,CAACiC,KAAP,CAAc,uBAAsBhB,IAAK,EAAzC;AACAe,MAAAA,OAAO,GAAG,MAAMnC,OAAO,CAACqC,IAAR,CAAanB,IAAb,EAAmBE,IAAnB,CAAhB;AACAe,MAAAA,OAAO,CAACG,EAAR,CAAW,SAAX,EAAsBb,cAAtB;AACAtB,MAAAA,MAAM,CAACiC,KAAP,CAAc,sBAAqBhB,IAAK,EAAxC;AACAI,MAAAA,gBAAgB,CAACW,OAAD,CAAhB;AACD,KAND,CAME,OAAOI,CAAP,EAAU;AACVpC,MAAAA,MAAM,CAACqC,KAAP,CAAaD,CAAb;AACD;AACF,GAlB8G,CAoB/G;;;AACA,QAAMJ,OAAO,CAACM,OAAR,EAAN;AACAtC,EAAAA,MAAM,CAACiC,KAAP,CAAc,gBAAehB,IAAK,EAAlC,EAtB+G,CAwB/G;;AACA,QAAMc,KAAK,GAAG,MAAMzB,mBAAmB,CAACY,QAAQ,CAACF,OAAD,CAAT,CAAvC;AACAhB,EAAAA,MAAM,CAACiC,KAAP,CAAc,yBAAwBjB,OAAQ,MAA9C,EAAqDS,IAAI,CAACc,SAAL,CAAeR,KAAK,CAACS,GAAN,CAAUJ,CAAC,IAAIA,CAAC,CAACK,IAAjB,CAAf,EAAuC,IAAvC,EAA6C,CAA7C,CAArD;;AACA,MAAIV,KAAJ,EAAW;AACT,UAAMC,OAAO,CAACU,IAAR,CAAajB,IAAI,CAACc,SAAL,CAAe;AAAEvB,MAAAA,OAAO,EAAEA,OAAX;AAAoBe,MAAAA,KAAK,EAAEA;AAA3B,KAAf,CAAb,CAAN;AACD;;AAED,SAAOC,OAAP;AACD,CAhCD;;AAkCAW,MAAM,CAACC,OAAP,GAAiB9B,aAAjB","sourcesContent":["'use strict'\n\nconst Channel = require('ipfs-pubsub-1on1')\n\nconst Logger = require('logplease')\nconst logger = Logger.create('exchange-heads', { color: Logger.Colors.Yellow })\nLogger.setLogLevel('ERROR')\n\nconst getHeadsForDatabase = async store => {\n  if (!(store && store._cache)) return []\n  const localHeads = await store._cache.get(store.localHeadsPath) || []\n  const remoteHeads = await store._cache.get(store.remoteHeadsPath) || []\n  return [...localHeads, ...remoteHeads]\n}\n\nconst exchangeHeads = async (ipfs, address, peer, getStore, getDirectConnection, onMessage, onChannelCreated) => {\n  const _handleMessage = message => {\n    const msg = JSON.parse(Buffer.from(message.data).toString())\n    const { address, heads } = msg\n    onMessage(address, heads)\n  }\n\n  let channel = getDirectConnection(peer)\n  if (!channel) {\n    try {\n      logger.debug(`Create a channel to ${peer}`)\n      channel = await Channel.open(ipfs, peer)\n      channel.on('message', _handleMessage)\n      logger.debug(`Channel created to ${peer}`)\n      onChannelCreated(channel)\n    } catch (e) {\n      logger.error(e)\n    }\n  }\n\n  // Wait for the direct channel to be fully connected\n  await channel.connect()\n  logger.debug(`Connected to ${peer}`)\n\n  // Send the heads if we have any\n  const heads = await getHeadsForDatabase(getStore(address))\n  logger.debug(`Send latest heads of '${address}':\\n`, JSON.stringify(heads.map(e => e.hash), null, 2))\n  if (heads) {\n    await channel.send(JSON.stringify({ address: address, heads: heads }))\n  }\n\n  return channel\n}\n\nmodule.exports = exchangeHeads\n"]},"metadata":{},"sourceType":"script"}