{"ast":null,"code":"'use strict';\n\nconst isIpfs = require('is-ipfs');\n\nconst CID = require('cids');\n\nconst TimeoutController = require('timeout-abort-controller');\n\nconst anySignal = require('any-signal');\n\nconst parseDuration = require('parse-duration').default;\n\nconst Key = require('interface-datastore').Key;\n\nconst {\n  TimeoutError\n} = require('./errors');\n\nconst errCode = require('err-code');\n\nconst toCidAndPath = require('ipfs-core-utils/src/to-cid-and-path');\n\nconst ERR_BAD_PATH = 'ERR_BAD_PATH';\nexports.OFFLINE_ERROR = 'This command must be run in online mode. Try running \\'ipfs daemon\\' first.';\nexports.MFS_FILE_TYPES = {\n  file: 0,\n  directory: 1,\n  'hamt-sharded-directory': 1\n};\nexports.MFS_ROOT_KEY = new Key('/local/filesroot');\nexports.MFS_MAX_CHUNK_SIZE = 262144;\nexports.MFS_MAX_LINKS = 174;\n/**\n * Returns a well-formed ipfs Path.\n * The returned path will always be prefixed with /ipfs/ or /ipns/.\n *\n * @param  {String} pathStr An ipfs-path, or ipns-path or a cid\n * @return {String} ipfs-path or ipns-path\n * @throws on an invalid @param ipfsPath\n */\n\nconst normalizePath = pathStr => {\n  if (isIpfs.cid(pathStr)) {\n    return `/ipfs/${new CID(pathStr)}`;\n  } else if (isIpfs.path(pathStr)) {\n    return pathStr;\n  } else {\n    throw errCode(new Error(`invalid path: ${pathStr}`), ERR_BAD_PATH);\n  }\n}; // TODO: do we need both normalizePath and normalizeCidPath?\n\n\nconst normalizeCidPath = path => {\n  if (path instanceof Uint8Array) {\n    return new CID(path).toString();\n  }\n\n  if (CID.isCID(path)) {\n    return path.toString();\n  }\n\n  if (path.indexOf('/ipfs/') === 0) {\n    path = path.substring('/ipfs/'.length);\n  }\n\n  if (path.charAt(path.length - 1) === '/') {\n    path = path.substring(0, path.length - 1);\n  }\n\n  return path;\n};\n/**\n * Resolve various styles of an ipfs-path to the hash of the target node.\n * Follows links in the path.\n *\n * Accepts formats:\n *  - <base58 string>\n *  - <base58 string>/link/to/venus\n *  - /ipfs/<base58 string>/link/to/pluto\n *  - multihash Buffer\n *\n * @param {Dag} dag The IPFS dag api\n * @param {CID|String} ipfsPath A CID or IPFS path\n * @param {Object} [options] Optional options passed directly to dag.resolve\n * @return {CID}\n */\n\n\nconst resolvePath = async function (dag, ipfsPath, options) {\n  options = options || {};\n\n  if (isIpfs.cid(ipfsPath)) {\n    return new CID(ipfsPath);\n  }\n\n  const {\n    cid,\n    path\n  } = toCidAndPath(ipfsPath);\n\n  if (!path) {\n    return cid;\n  }\n\n  const result = await dag.resolve(cid, { ...options,\n    path\n  });\n  return result.cid;\n};\n\nconst mapFile = (file, options) => {\n  options = options || {};\n  const output = {\n    cid: file.cid,\n    path: file.path,\n    name: file.name,\n    depth: file.path.split('/').length,\n    size: 0,\n    type: 'file'\n  };\n\n  if (file.unixfs) {\n    output.type = file.unixfs.type === 'directory' ? 'dir' : 'file';\n\n    if (file.unixfs.type === 'file') {\n      output.size = file.unixfs.fileSize();\n\n      if (options.includeContent) {\n        output.content = file.content();\n      }\n    }\n\n    output.mode = file.unixfs.mode;\n    output.mtime = file.unixfs.mtime;\n  }\n\n  return output;\n};\n/**\n * @template {any[]} ARGS\n * @template R\n * @typedef {(...args: ARGS) => R} Fn\n */\n\n/**\n * @typedef {object} AbortOptions\n * @property {number} [timeout] - A timeout in ms\n * @property {AbortSignal} [signal] - Can be used to cancel any long running requests started as a result of this call\n */\n\n/**\n * @template {any[]} ARGS\n * @template {Promise<any> | AsyncIterable} R - The return type of `fn`\n * @param {Fn<ARGS, R>} fn\n * @param {number} [optionsArgIndex]\n * @returns {Fn<ARGS, R>}\n */\n\n\nfunction withTimeoutOption(fn, optionsArgIndex) {\n  // eslint-disable-next-line valid-jsdoc\n  return (\n    /** @returns {R} */\n    (\n    /** @type {ARGS} */\n    ...args) => {\n      const options = args[optionsArgIndex == null ? args.length - 1 : optionsArgIndex];\n      if (!options || !options.timeout) return fn(...args);\n      const timeout = typeof options.timeout === 'string' ? parseDuration(options.timeout) : options.timeout;\n      const controller = new TimeoutController(timeout);\n      options.signal = anySignal([options.signal, controller.signal]);\n      const fnRes = fn(...args);\n      const timeoutPromise = new Promise((resolve, reject) => {\n        controller.signal.addEventListener('abort', () => {\n          reject(new TimeoutError());\n        });\n      });\n      const start = Date.now();\n\n      const maybeThrowTimeoutError = () => {\n        if (controller.signal.aborted) {\n          throw new TimeoutError();\n        }\n\n        const timeTaken = Date.now() - start; // if we have starved the event loop by adding microtasks, we could have\n        // timed out already but the TimeoutController will never know because it's\n        // setTimeout will not fire until we stop adding microtasks\n\n        if (timeTaken > timeout) {\n          controller.abort();\n          throw new TimeoutError();\n        }\n      };\n\n      if (fnRes[Symbol.asyncIterator]) {\n        // @ts-ignore\n        return async function* () {\n          const it = fnRes[Symbol.asyncIterator]();\n\n          try {\n            while (true) {\n              const {\n                value,\n                done\n              } = await Promise.race([it.next(), timeoutPromise]);\n\n              if (done) {\n                break;\n              }\n\n              maybeThrowTimeoutError();\n              yield value;\n            }\n          } catch (err) {\n            maybeThrowTimeoutError();\n            throw err;\n          } finally {\n            controller.clear();\n\n            if (it.return) {\n              it.return();\n            }\n          }\n        }();\n      } // @ts-ignore\n\n\n      return (async () => {\n        try {\n          const res = await Promise.race([fnRes, timeoutPromise]);\n          maybeThrowTimeoutError();\n          return res;\n        } catch (err) {\n          maybeThrowTimeoutError();\n          throw err;\n        } finally {\n          controller.clear();\n        }\n      })();\n    }\n  );\n}\n\nexports.normalizePath = normalizePath;\nexports.normalizeCidPath = normalizeCidPath;\nexports.resolvePath = resolvePath;\nexports.mapFile = mapFile;\nexports.withTimeoutOption = withTimeoutOption;","map":{"version":3,"sources":["/home/user/orbit-playground/music-app/node_modules/ipfs/src/core/utils.js"],"names":["isIpfs","require","CID","TimeoutController","anySignal","parseDuration","default","Key","TimeoutError","errCode","toCidAndPath","ERR_BAD_PATH","exports","OFFLINE_ERROR","MFS_FILE_TYPES","file","directory","MFS_ROOT_KEY","MFS_MAX_CHUNK_SIZE","MFS_MAX_LINKS","normalizePath","pathStr","cid","path","Error","normalizeCidPath","Uint8Array","toString","isCID","indexOf","substring","length","charAt","resolvePath","dag","ipfsPath","options","result","resolve","mapFile","output","name","depth","split","size","type","unixfs","fileSize","includeContent","content","mode","mtime","withTimeoutOption","fn","optionsArgIndex","args","timeout","controller","signal","fnRes","timeoutPromise","Promise","reject","addEventListener","start","Date","now","maybeThrowTimeoutError","aborted","timeTaken","abort","Symbol","asyncIterator","it","value","done","race","next","err","clear","return","res"],"mappings":"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","sourcesContent":["'use strict'\n\nconst isIpfs = require('is-ipfs')\nconst CID = require('cids')\nconst TimeoutController = require('timeout-abort-controller')\nconst anySignal = require('any-signal')\nconst parseDuration = require('parse-duration').default\nconst Key = require('interface-datastore').Key\nconst { TimeoutError } = require('./errors')\nconst errCode = require('err-code')\nconst toCidAndPath = require('ipfs-core-utils/src/to-cid-and-path')\n\nconst ERR_BAD_PATH = 'ERR_BAD_PATH'\n\nexports.OFFLINE_ERROR = 'This command must be run in online mode. Try running \\'ipfs daemon\\' first.'\n\nexports.MFS_FILE_TYPES = {\n  file: 0,\n  directory: 1,\n  'hamt-sharded-directory': 1\n}\nexports.MFS_ROOT_KEY = new Key('/local/filesroot')\nexports.MFS_MAX_CHUNK_SIZE = 262144\nexports.MFS_MAX_LINKS = 174\n\n/**\n * Returns a well-formed ipfs Path.\n * The returned path will always be prefixed with /ipfs/ or /ipns/.\n *\n * @param  {String} pathStr An ipfs-path, or ipns-path or a cid\n * @return {String} ipfs-path or ipns-path\n * @throws on an invalid @param ipfsPath\n */\nconst normalizePath = (pathStr) => {\n  if (isIpfs.cid(pathStr)) {\n    return `/ipfs/${new CID(pathStr)}`\n  } else if (isIpfs.path(pathStr)) {\n    return pathStr\n  } else {\n    throw errCode(new Error(`invalid path: ${pathStr}`), ERR_BAD_PATH)\n  }\n}\n\n// TODO: do we need both normalizePath and normalizeCidPath?\nconst normalizeCidPath = (path) => {\n  if (path instanceof Uint8Array) {\n    return new CID(path).toString()\n  }\n  if (CID.isCID(path)) {\n    return path.toString()\n  }\n  if (path.indexOf('/ipfs/') === 0) {\n    path = path.substring('/ipfs/'.length)\n  }\n  if (path.charAt(path.length - 1) === '/') {\n    path = path.substring(0, path.length - 1)\n  }\n  return path\n}\n\n/**\n * Resolve various styles of an ipfs-path to the hash of the target node.\n * Follows links in the path.\n *\n * Accepts formats:\n *  - <base58 string>\n *  - <base58 string>/link/to/venus\n *  - /ipfs/<base58 string>/link/to/pluto\n *  - multihash Buffer\n *\n * @param {Dag} dag The IPFS dag api\n * @param {CID|String} ipfsPath A CID or IPFS path\n * @param {Object} [options] Optional options passed directly to dag.resolve\n * @return {CID}\n */\nconst resolvePath = async function (dag, ipfsPath, options) {\n  options = options || {}\n\n  if (isIpfs.cid(ipfsPath)) {\n    return new CID(ipfsPath)\n  }\n\n  const {\n    cid,\n    path\n  } = toCidAndPath(ipfsPath)\n\n  if (!path) {\n    return cid\n  }\n\n  const result = await dag.resolve(cid, {\n    ...options,\n    path\n  })\n\n  return result.cid\n}\n\nconst mapFile = (file, options) => {\n  options = options || {}\n\n  const output = {\n    cid: file.cid,\n    path: file.path,\n    name: file.name,\n    depth: file.path.split('/').length,\n    size: 0,\n    type: 'file'\n  }\n\n  if (file.unixfs) {\n    output.type = file.unixfs.type === 'directory' ? 'dir' : 'file'\n\n    if (file.unixfs.type === 'file') {\n      output.size = file.unixfs.fileSize()\n\n      if (options.includeContent) {\n        output.content = file.content()\n      }\n    }\n\n    output.mode = file.unixfs.mode\n    output.mtime = file.unixfs.mtime\n  }\n\n  return output\n}\n\n/**\n * @template {any[]} ARGS\n * @template R\n * @typedef {(...args: ARGS) => R} Fn\n */\n\n/**\n * @typedef {object} AbortOptions\n * @property {number} [timeout] - A timeout in ms\n * @property {AbortSignal} [signal] - Can be used to cancel any long running requests started as a result of this call\n */\n\n/**\n * @template {any[]} ARGS\n * @template {Promise<any> | AsyncIterable} R - The return type of `fn`\n * @param {Fn<ARGS, R>} fn\n * @param {number} [optionsArgIndex]\n * @returns {Fn<ARGS, R>}\n */\nfunction withTimeoutOption (fn, optionsArgIndex) {\n  // eslint-disable-next-line valid-jsdoc\n  return /** @returns {R} */(/** @type {ARGS} */...args) => {\n    const options = args[optionsArgIndex == null ? args.length - 1 : optionsArgIndex]\n    if (!options || !options.timeout) return fn(...args)\n\n    const timeout = typeof options.timeout === 'string'\n      ? parseDuration(options.timeout)\n      : options.timeout\n\n    const controller = new TimeoutController(timeout)\n\n    options.signal = anySignal([options.signal, controller.signal])\n\n    const fnRes = fn(...args)\n    const timeoutPromise = new Promise((resolve, reject) => {\n      controller.signal.addEventListener('abort', () => {\n        reject(new TimeoutError())\n      })\n    })\n\n    const start = Date.now()\n\n    const maybeThrowTimeoutError = () => {\n      if (controller.signal.aborted) {\n        throw new TimeoutError()\n      }\n\n      const timeTaken = Date.now() - start\n\n      // if we have starved the event loop by adding microtasks, we could have\n      // timed out already but the TimeoutController will never know because it's\n      // setTimeout will not fire until we stop adding microtasks\n      if (timeTaken > timeout) {\n        controller.abort()\n        throw new TimeoutError()\n      }\n    }\n\n    if (fnRes[Symbol.asyncIterator]) {\n      // @ts-ignore\n      return (async function * () {\n        const it = fnRes[Symbol.asyncIterator]()\n\n        try {\n          while (true) {\n            const { value, done } = await Promise.race([it.next(), timeoutPromise])\n\n            if (done) {\n              break\n            }\n\n            maybeThrowTimeoutError()\n\n            yield value\n          }\n        } catch (err) {\n          maybeThrowTimeoutError()\n\n          throw err\n        } finally {\n          controller.clear()\n\n          if (it.return) {\n            it.return()\n          }\n        }\n      })()\n    }\n\n    // @ts-ignore\n    return (async () => {\n      try {\n        const res = await Promise.race([fnRes, timeoutPromise])\n\n        maybeThrowTimeoutError()\n\n        return res\n      } catch (err) {\n        maybeThrowTimeoutError()\n\n        throw err\n      } finally {\n        controller.clear()\n      }\n    })()\n  }\n}\n\nexports.normalizePath = normalizePath\nexports.normalizeCidPath = normalizeCidPath\nexports.resolvePath = resolvePath\nexports.mapFile = mapFile\nexports.withTimeoutOption = withTimeoutOption\n"]},"metadata":{},"sourceType":"script"}