{"ast":null,"code":"'use strict';\n\nconst CID = require('cids');\n\nconst protobuf = require('protons');\n\nconst fnv1a = require('fnv1a');\n\nconst varint = require('varint');\n\nconst dagpb = require('ipld-dag-pb');\n\nconst {\n  DAGNode,\n  DAGLink\n} = dagpb;\n\nconst multicodec = require('multicodec');\n\nconst pbSchema = require('./pin.proto');\n\nconst {\n  cidToKey,\n  DEFAULT_FANOUT,\n  MAX_ITEMS,\n  EMPTY_KEY\n} = require('./utils');\n\nconst uint8ArrayConcat = require('uint8arrays/concat');\n\nconst uint8ArrayCompare = require('uint8arrays/compare');\n\nconst uint8ArrayToString = require('uint8arrays/to-string');\n\nconst uint8ArrayFromString = require('uint8arrays/from-string');\n\nconst uint8ArrayEquals = require('uint8arrays/equals');\n\nconst pb = protobuf(pbSchema);\n\nfunction toB58String(hash) {\n  return new CID(hash).toBaseEncodedString();\n}\n\nfunction readHeader(rootNode) {\n  // rootNode.data should be a buffer of the format:\n  // < varint(headerLength) | header | itemData... >\n  const rootData = rootNode.Data;\n  const hdrLength = varint.decode(rootData);\n  const vBytes = varint.decode.bytes;\n\n  if (vBytes <= 0) {\n    throw new Error('Invalid Set header length');\n  }\n\n  if (vBytes + hdrLength > rootData.length) {\n    throw new Error('Impossibly large set header length');\n  }\n\n  const hdrSlice = rootData.slice(vBytes, hdrLength + vBytes);\n  const header = pb.Set.decode(hdrSlice);\n\n  if (header.version !== 1) {\n    throw new Error(`Unsupported Set version: ${header.version}`);\n  }\n\n  if (header.fanout > rootNode.Links.length) {\n    throw new Error('Impossibly large fanout');\n  }\n\n  return {\n    header: header,\n    data: rootData.slice(hdrLength + vBytes)\n  };\n}\n\nfunction hash(seed, key) {\n  const buffer = new Uint8Array(4);\n  const dataView = new DataView(buffer.buffer);\n  dataView.setUint32(0, seed, true);\n  const encodedKey = uint8ArrayFromString(toB58String(key));\n  const data = uint8ArrayConcat([buffer, encodedKey], buffer.byteLength + encodedKey.byteLength);\n  return fnv1a(uint8ArrayToString(data));\n}\n\nasync function* walkItems(blockstore, node) {\n  const pbh = readHeader(node);\n  let idx = 0;\n\n  for (const link of node.Links) {\n    if (idx < pbh.header.fanout) {\n      // the first pbh.header.fanout links are fanout bins\n      // if a fanout bin is not 'empty', dig into and walk its DAGLinks\n      const linkHash = link.Hash;\n\n      if (!uint8ArrayEquals(EMPTY_KEY, linkHash.bytes)) {\n        // walk the links of this fanout bin\n        const buf = await blockstore.get(cidToKey(linkHash));\n        const node = dagpb.util.deserialize(buf);\n        yield* walkItems(blockstore, node);\n      }\n    } else {\n      // otherwise, the link is a pin\n      yield link.Hash;\n    }\n\n    idx++;\n  }\n}\n\nasync function* loadSet(blockstore, rootNode, name) {\n  const link = rootNode.Links.find(l => l.Name === name);\n\n  if (!link) {\n    throw new Error('No link found with name ' + name);\n  }\n\n  const buf = await blockstore.get(cidToKey(link.Hash));\n  const node = dagpb.util.deserialize(buf);\n  yield* walkItems(blockstore, node);\n}\n\nfunction storeItems(blockstore, items) {\n  return storePins(items, 0);\n\n  async function storePins(pins, depth) {\n    const pbHeader = pb.Set.encode({\n      version: 1,\n      fanout: DEFAULT_FANOUT,\n      seed: depth\n    });\n    const header = varint.encode(pbHeader.length);\n    const headerBuf = uint8ArrayConcat([header, pbHeader]);\n    const fanoutLinks = [];\n\n    for (let i = 0; i < DEFAULT_FANOUT; i++) {\n      fanoutLinks.push(new DAGLink('', 1, EMPTY_KEY));\n    }\n\n    if (pins.length <= MAX_ITEMS) {\n      const nodes = pins.map(item => {\n        return {\n          link: new DAGLink('', 1, item.key),\n          data: item.data || new Uint8Array()\n        };\n      }) // sorting makes any ordering of `pins` produce the same DAGNode\n      .sort((a, b) => {\n        return uint8ArrayCompare(a.link.Hash.bytes, b.link.Hash.bytes);\n      });\n      const rootLinks = fanoutLinks.concat(nodes.map(item => item.link));\n      const rootData = uint8ArrayConcat([headerBuf, ...nodes.map(item => item.data)]);\n      return new DAGNode(rootData, rootLinks);\n    } else {\n      // If the array of pins is > MAX_ITEMS, we:\n      //  - distribute the pins among `DEFAULT_FANOUT` bins\n      //    - create a DAGNode for each bin\n      //      - add each pin as a DAGLink to that bin\n      //  - create a root DAGNode\n      //    - add each bin as a DAGLink\n      //  - send that root DAGNode via callback\n      // (using go-ipfs' \"wasteful but simple\" approach for consistency)\n      // https://github.com/ipfs/go-ipfs/blob/master/pin/set.go#L57\n      const bins = pins.reduce((bins, pin) => {\n        const n = hash(depth, pin.key) % DEFAULT_FANOUT;\n        bins[n] = n in bins ? bins[n].concat([pin]) : [pin];\n        return bins;\n      }, []);\n      let idx = 0;\n\n      for (const bin of bins) {\n        const child = await storePins(bin, depth + 1);\n        await storeChild(child, idx);\n        idx++;\n      }\n\n      return new DAGNode(headerBuf, fanoutLinks);\n    }\n\n    async function storeChild(child, binIdx) {\n      const buf = dagpb.util.serialize(child);\n      const cid = await dagpb.util.cid(buf, {\n        cidVersion: 0,\n        hashAlg: multicodec.SHA2_256\n      });\n      await blockstore.put(cidToKey(cid), buf);\n      fanoutLinks[binIdx] = new DAGLink('', child.size, cid);\n    }\n  }\n}\n\nasync function storeSet(blockstore, type, cids) {\n  const rootNode = await storeItems(blockstore, cids.map(cid => {\n    return {\n      key: cid,\n      data: null\n    };\n  }));\n  const buf = rootNode.serialize(rootNode);\n  const cid = await dagpb.util.cid(buf, {\n    cidVersion: 0,\n    hashAlg: multicodec.SHA2_256\n  });\n  await blockstore.put(cidToKey(cid), buf);\n  return new DAGLink(type, rootNode.size, cid);\n}\n\nmodule.exports = {\n  loadSet,\n  storeSet\n};","map":{"version":3,"sources":["/home/user/orbit-playground/music-app/node_modules/ipfs-repo-migrations/migrations/migration-9/pin-set.js"],"names":["CID","require","protobuf","fnv1a","varint","dagpb","DAGNode","DAGLink","multicodec","pbSchema","cidToKey","DEFAULT_FANOUT","MAX_ITEMS","EMPTY_KEY","uint8ArrayConcat","uint8ArrayCompare","uint8ArrayToString","uint8ArrayFromString","uint8ArrayEquals","pb","toB58String","hash","toBaseEncodedString","readHeader","rootNode","rootData","Data","hdrLength","decode","vBytes","bytes","Error","length","hdrSlice","slice","header","Set","version","fanout","Links","data","seed","key","buffer","Uint8Array","dataView","DataView","setUint32","encodedKey","byteLength","walkItems","blockstore","node","pbh","idx","link","linkHash","Hash","buf","get","util","deserialize","loadSet","name","find","l","Name","storeItems","items","storePins","pins","depth","pbHeader","encode","headerBuf","fanoutLinks","i","push","nodes","map","item","sort","a","b","rootLinks","concat","bins","reduce","pin","n","bin","child","storeChild","binIdx","serialize","cid","cidVersion","hashAlg","SHA2_256","put","size","storeSet","type","cids","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst CID = require('cids')\nconst protobuf = require('protons')\nconst fnv1a = require('fnv1a')\nconst varint = require('varint')\nconst dagpb = require('ipld-dag-pb')\nconst { DAGNode, DAGLink } = dagpb\nconst multicodec = require('multicodec')\nconst pbSchema = require('./pin.proto')\nconst { cidToKey, DEFAULT_FANOUT, MAX_ITEMS, EMPTY_KEY } = require('./utils')\nconst uint8ArrayConcat = require('uint8arrays/concat')\nconst uint8ArrayCompare = require('uint8arrays/compare')\nconst uint8ArrayToString = require('uint8arrays/to-string')\nconst uint8ArrayFromString = require('uint8arrays/from-string')\nconst uint8ArrayEquals = require('uint8arrays/equals')\n\nconst pb = protobuf(pbSchema)\n\nfunction toB58String (hash) {\n  return new CID(hash).toBaseEncodedString()\n}\n\nfunction readHeader (rootNode) {\n  // rootNode.data should be a buffer of the format:\n  // < varint(headerLength) | header | itemData... >\n  const rootData = rootNode.Data\n  const hdrLength = varint.decode(rootData)\n  const vBytes = varint.decode.bytes\n\n  if (vBytes <= 0) {\n    throw new Error('Invalid Set header length')\n  }\n\n  if (vBytes + hdrLength > rootData.length) {\n    throw new Error('Impossibly large set header length')\n  }\n\n  const hdrSlice = rootData.slice(vBytes, hdrLength + vBytes)\n  const header = pb.Set.decode(hdrSlice)\n\n  if (header.version !== 1) {\n    throw new Error(`Unsupported Set version: ${header.version}`)\n  }\n\n  if (header.fanout > rootNode.Links.length) {\n    throw new Error('Impossibly large fanout')\n  }\n\n  return {\n    header: header,\n    data: rootData.slice(hdrLength + vBytes)\n  }\n}\n\nfunction hash (seed, key) {\n  const buffer = new Uint8Array(4)\n  const dataView = new DataView(buffer.buffer)\n  dataView.setUint32(0, seed, true)\n  const encodedKey = uint8ArrayFromString(toB58String(key))\n  const data = uint8ArrayConcat([buffer, encodedKey], buffer.byteLength + encodedKey.byteLength)\n\n  return fnv1a(uint8ArrayToString(data))\n}\n\nasync function * walkItems (blockstore, node) {\n  const pbh = readHeader(node)\n  let idx = 0\n\n  for (const link of node.Links) {\n    if (idx < pbh.header.fanout) {\n      // the first pbh.header.fanout links are fanout bins\n      // if a fanout bin is not 'empty', dig into and walk its DAGLinks\n      const linkHash = link.Hash\n\n      if (!uint8ArrayEquals(EMPTY_KEY, linkHash.bytes)) {\n        // walk the links of this fanout bin\n        const buf = await blockstore.get(cidToKey(linkHash))\n        const node = dagpb.util.deserialize(buf)\n\n        yield * walkItems(blockstore, node)\n      }\n    } else {\n      // otherwise, the link is a pin\n      yield link.Hash\n    }\n\n    idx++\n  }\n}\n\nasync function * loadSet (blockstore, rootNode, name) {\n  const link = rootNode.Links.find(l => l.Name === name)\n\n  if (!link) {\n    throw new Error('No link found with name ' + name)\n  }\n\n  const buf = await blockstore.get(cidToKey(link.Hash))\n  const node = dagpb.util.deserialize(buf)\n\n  yield * walkItems(blockstore, node)\n}\n\nfunction storeItems (blockstore, items) {\n  return storePins(items, 0)\n\n  async function storePins (pins, depth) {\n    const pbHeader = pb.Set.encode({\n      version: 1,\n      fanout: DEFAULT_FANOUT,\n      seed: depth\n    })\n\n    const header = varint.encode(pbHeader.length)\n    const headerBuf = uint8ArrayConcat([header, pbHeader])\n    const fanoutLinks = []\n\n    for (let i = 0; i < DEFAULT_FANOUT; i++) {\n      fanoutLinks.push(new DAGLink('', 1, EMPTY_KEY))\n    }\n\n    if (pins.length <= MAX_ITEMS) {\n      const nodes = pins\n        .map(item => {\n          return ({\n            link: new DAGLink('', 1, item.key),\n            data: item.data || new Uint8Array()\n          })\n        })\n        // sorting makes any ordering of `pins` produce the same DAGNode\n        .sort((a, b) => {\n          return uint8ArrayCompare(a.link.Hash.bytes, b.link.Hash.bytes)\n        })\n\n      const rootLinks = fanoutLinks.concat(nodes.map(item => item.link))\n      const rootData = uint8ArrayConcat([headerBuf, ...nodes.map(item => item.data)])\n\n      return new DAGNode(rootData, rootLinks)\n    } else {\n      // If the array of pins is > MAX_ITEMS, we:\n      //  - distribute the pins among `DEFAULT_FANOUT` bins\n      //    - create a DAGNode for each bin\n      //      - add each pin as a DAGLink to that bin\n      //  - create a root DAGNode\n      //    - add each bin as a DAGLink\n      //  - send that root DAGNode via callback\n      // (using go-ipfs' \"wasteful but simple\" approach for consistency)\n      // https://github.com/ipfs/go-ipfs/blob/master/pin/set.go#L57\n\n      const bins = pins.reduce((bins, pin) => {\n        const n = hash(depth, pin.key) % DEFAULT_FANOUT\n        bins[n] = n in bins ? bins[n].concat([pin]) : [pin]\n        return bins\n      }, [])\n\n      let idx = 0\n      for (const bin of bins) {\n        const child = await storePins(bin, depth + 1)\n\n        await storeChild(child, idx)\n\n        idx++\n      }\n\n      return new DAGNode(headerBuf, fanoutLinks)\n    }\n\n    async function storeChild (child, binIdx) {\n      const buf = dagpb.util.serialize(child)\n      const cid = await dagpb.util.cid(buf, {\n        cidVersion: 0,\n        hashAlg: multicodec.SHA2_256,\n      })\n      await blockstore.put(cidToKey(cid), buf)\n\n      fanoutLinks[binIdx] = new DAGLink('', child.size, cid)\n    }\n  }\n}\n\nasync function storeSet (blockstore, type, cids) {\n  const rootNode = await storeItems(blockstore, cids.map(cid => {\n    return {\n      key: cid,\n      data: null\n    }\n  }))\n  const buf = rootNode.serialize(rootNode)\n  const cid = await dagpb.util.cid(buf, {\n    cidVersion: 0,\n    hashAlg: multicodec.SHA2_256\n  })\n\n  await blockstore.put(cidToKey(cid), buf)\n\n  return new DAGLink(type, rootNode.size, cid)\n}\n\nmodule.exports = {\n  loadSet,\n  storeSet\n}\n"]},"metadata":{},"sourceType":"script"}