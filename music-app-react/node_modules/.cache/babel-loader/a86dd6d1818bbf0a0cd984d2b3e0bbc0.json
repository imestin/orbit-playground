{"ast":null,"code":"'use strict';\n\nconst PeerId = require('peer-id');\n\nconst crypto = require('libp2p-crypto');\n\nconst debug = require('debug');\n\nconst uint8ArrayConcat = require('uint8arrays/concat');\n\nconst uint8ArrayEquals = require('uint8arrays/equals');\n\nconst uint8ArrayToString = require('uint8arrays/to-string');\n\nconst log = debug('libp2p:secio');\nlog.error = debug('libp2p:secio:error');\n\nconst pbm = require('./secio.proto');\n\nconst support = require('../support');\n\nconst {\n  UnexpectedPeerError\n} = require('libp2p-interfaces/src/crypto/errors'); // nonceSize is the size of our nonces (in bytes)\n\n\nconst nonceSize = 16;\n\nexports.createProposal = state => {\n  state.proposal.out = {\n    rand: crypto.randomBytes(nonceSize),\n    pubkey: state.key.local.public.bytes,\n    exchanges: support.exchanges.join(','),\n    ciphers: support.ciphers.join(','),\n    hashes: support.hashes.join(',')\n  };\n  state.proposalEncoded.out = pbm.Propose.encode(state.proposal.out);\n  return state.proposalEncoded.out;\n};\n\nexports.createExchange = async state => {\n  const res = await crypto.keys.generateEphemeralKeyPair(state.protocols.local.curveT);\n  state.ephemeralKey.local = res.key;\n  state.shared.generate = res.genSharedKey; // Gather corpus to sign.\n\n  const selectionOut = uint8ArrayConcat([state.proposalEncoded.out, state.proposalEncoded.in, state.ephemeralKey.local]);\n  const sig = await state.key.local.sign(selectionOut);\n  state.exchange.out = {\n    epubkey: state.ephemeralKey.local,\n    signature: sig\n  };\n  return pbm.Exchange.encode(state.exchange.out);\n};\n\nexports.identify = async (state, msg) => {\n  log('1.1 identify');\n  state.proposalEncoded.in = msg;\n  state.proposal.in = pbm.Propose.decode(msg);\n  const pubkey = state.proposal.in.pubkey;\n  state.key.remote = crypto.keys.unmarshalPublicKey(pubkey);\n  const remoteId = await PeerId.createFromPubKey(uint8ArrayToString(pubkey, 'base64pad')); // If we know who we are dialing to, double check\n\n  if (state.id.remote) {\n    if (state.id.remote.toString() !== remoteId.toString()) {\n      throw new UnexpectedPeerError('Dialed to the wrong peer: IDs do not match!');\n    }\n\n    state.id.remote.pubKey = state.key.remote;\n  } else {\n    state.id.remote = remoteId;\n  }\n\n  log('1.1 identify - %s - identified remote peer as %s', state.id.local.toB58String(), state.id.remote.toB58String());\n};\n\nexports.selectProtocols = async state => {\n  log('1.2 selection');\n  const local = {\n    pubKeyBytes: state.key.local.public.bytes,\n    exchanges: support.exchanges,\n    hashes: support.hashes,\n    ciphers: support.ciphers,\n    nonce: state.proposal.out.rand\n  };\n  const remote = {\n    pubKeyBytes: state.proposal.in.pubkey,\n    exchanges: state.proposal.in.exchanges.split(','),\n    hashes: state.proposal.in.hashes.split(','),\n    ciphers: state.proposal.in.ciphers.split(','),\n    nonce: state.proposal.in.rand\n  };\n  const selected = await support.selectBest(local, remote); // we use the same params for both directions (must choose same curve)\n  // WARNING: if they dont SelectBest the same way, this won't work...\n\n  state.protocols.remote = {\n    order: selected.order,\n    curveT: selected.curveT,\n    cipherT: selected.cipherT,\n    hashT: selected.hashT\n  };\n  state.protocols.local = {\n    order: selected.order,\n    curveT: selected.curveT,\n    cipherT: selected.cipherT,\n    hashT: selected.hashT\n  };\n};\n\nexports.verify = async (state, msg) => {\n  log('2.1. verify');\n  state.exchange.in = pbm.Exchange.decode(msg);\n  state.ephemeralKey.remote = state.exchange.in.epubkey;\n  const selectionIn = uint8ArrayConcat([state.proposalEncoded.in, state.proposalEncoded.out, state.ephemeralKey.remote]);\n  const sigOk = await state.key.remote.verify(selectionIn, state.exchange.in.signature);\n\n  if (!sigOk) {\n    throw new Error('Bad signature');\n  }\n\n  log('2.1. verify - signature verified');\n};\n\nexports.generateKeys = async state => {\n  log('2.2. keys');\n  const secret = await state.shared.generate(state.exchange.in.epubkey);\n  state.shared.secret = secret;\n  const keys = await crypto.keys.keyStretcher(state.protocols.local.cipherT, state.protocols.local.hashT, state.shared.secret); // use random nonces to decide order.\n\n  if (state.protocols.local.order > 0) {\n    state.protocols.local.keys = keys.k1;\n    state.protocols.remote.keys = keys.k2;\n  } else if (state.protocols.local.order < 0) {\n    // swap\n    state.protocols.local.keys = keys.k2;\n    state.protocols.remote.keys = keys.k1;\n  } else {\n    // we should've bailed before state. but if not, bail here.\n    throw new Error('you are trying to talk to yourself');\n  }\n\n  log('2.3. mac + cipher');\n  await Promise.all([state.protocols.local, state.protocols.remote].map(data => support.makeMacAndCipher(data)));\n};\n\nexports.verifyNonce = (state, n2) => {\n  const n1 = state.proposal.out.rand;\n  if (uint8ArrayEquals(n1, n2)) return;\n  throw new Error(`Failed to read our encrypted nonce: ${uint8ArrayToString(n1, 'base16')} != ${uint8ArrayToString(n2, 'base16')}`);\n};","map":{"version":3,"sources":["/home/user/orbit-playground/music-app/node_modules/libp2p-secio/src/handshake/crypto.js"],"names":["PeerId","require","crypto","debug","uint8ArrayConcat","uint8ArrayEquals","uint8ArrayToString","log","error","pbm","support","UnexpectedPeerError","nonceSize","exports","createProposal","state","proposal","out","rand","randomBytes","pubkey","key","local","public","bytes","exchanges","join","ciphers","hashes","proposalEncoded","Propose","encode","createExchange","res","keys","generateEphemeralKeyPair","protocols","curveT","ephemeralKey","shared","generate","genSharedKey","selectionOut","in","sig","sign","exchange","epubkey","signature","Exchange","identify","msg","decode","remote","unmarshalPublicKey","remoteId","createFromPubKey","id","toString","pubKey","toB58String","selectProtocols","pubKeyBytes","nonce","split","selected","selectBest","order","cipherT","hashT","verify","selectionIn","sigOk","Error","generateKeys","secret","keyStretcher","k1","k2","Promise","all","map","data","makeMacAndCipher","verifyNonce","n2","n1"],"mappings":"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","sourcesContent":["'use strict'\n\nconst PeerId = require('peer-id')\nconst crypto = require('libp2p-crypto')\nconst debug = require('debug')\nconst uint8ArrayConcat = require('uint8arrays/concat')\nconst uint8ArrayEquals = require('uint8arrays/equals')\nconst uint8ArrayToString = require('uint8arrays/to-string')\nconst log = debug('libp2p:secio')\nlog.error = debug('libp2p:secio:error')\n\nconst pbm = require('./secio.proto')\n\nconst support = require('../support')\n\nconst { UnexpectedPeerError } = require('libp2p-interfaces/src/crypto/errors')\n\n// nonceSize is the size of our nonces (in bytes)\nconst nonceSize = 16\n\nexports.createProposal = (state) => {\n  state.proposal.out = {\n    rand: crypto.randomBytes(nonceSize),\n    pubkey: state.key.local.public.bytes,\n    exchanges: support.exchanges.join(','),\n    ciphers: support.ciphers.join(','),\n    hashes: support.hashes.join(',')\n  }\n\n  state.proposalEncoded.out = pbm.Propose.encode(state.proposal.out)\n  return state.proposalEncoded.out\n}\n\nexports.createExchange = async (state) => {\n  const res = await crypto.keys.generateEphemeralKeyPair(state.protocols.local.curveT)\n\n  state.ephemeralKey.local = res.key\n  state.shared.generate = res.genSharedKey\n\n  // Gather corpus to sign.\n  const selectionOut = uint8ArrayConcat([\n    state.proposalEncoded.out,\n    state.proposalEncoded.in,\n    state.ephemeralKey.local\n  ])\n\n  const sig = await state.key.local.sign(selectionOut)\n\n  state.exchange.out = {\n    epubkey: state.ephemeralKey.local,\n    signature: sig\n  }\n\n  return pbm.Exchange.encode(state.exchange.out)\n}\n\nexports.identify = async (state, msg) => {\n  log('1.1 identify')\n\n  state.proposalEncoded.in = msg\n  state.proposal.in = pbm.Propose.decode(msg)\n  const pubkey = state.proposal.in.pubkey\n\n  state.key.remote = crypto.keys.unmarshalPublicKey(pubkey)\n\n  const remoteId = await PeerId.createFromPubKey(uint8ArrayToString(pubkey, 'base64pad'))\n\n  // If we know who we are dialing to, double check\n  if (state.id.remote) {\n    if (state.id.remote.toString() !== remoteId.toString()) {\n      throw new UnexpectedPeerError('Dialed to the wrong peer: IDs do not match!')\n    }\n    state.id.remote.pubKey = state.key.remote\n  } else {\n    state.id.remote = remoteId\n  }\n\n  log('1.1 identify - %s - identified remote peer as %s', state.id.local.toB58String(), state.id.remote.toB58String())\n}\n\nexports.selectProtocols = async (state) => {\n  log('1.2 selection')\n\n  const local = {\n    pubKeyBytes: state.key.local.public.bytes,\n    exchanges: support.exchanges,\n    hashes: support.hashes,\n    ciphers: support.ciphers,\n    nonce: state.proposal.out.rand\n  }\n\n  const remote = {\n    pubKeyBytes: state.proposal.in.pubkey,\n    exchanges: state.proposal.in.exchanges.split(','),\n    hashes: state.proposal.in.hashes.split(','),\n    ciphers: state.proposal.in.ciphers.split(','),\n    nonce: state.proposal.in.rand\n  }\n\n  const selected = await support.selectBest(local, remote)\n\n  // we use the same params for both directions (must choose same curve)\n  // WARNING: if they dont SelectBest the same way, this won't work...\n  state.protocols.remote = {\n    order: selected.order,\n    curveT: selected.curveT,\n    cipherT: selected.cipherT,\n    hashT: selected.hashT\n  }\n\n  state.protocols.local = {\n    order: selected.order,\n    curveT: selected.curveT,\n    cipherT: selected.cipherT,\n    hashT: selected.hashT\n  }\n}\n\nexports.verify = async (state, msg) => {\n  log('2.1. verify')\n\n  state.exchange.in = pbm.Exchange.decode(msg)\n  state.ephemeralKey.remote = state.exchange.in.epubkey\n\n  const selectionIn = uint8ArrayConcat([\n    state.proposalEncoded.in,\n    state.proposalEncoded.out,\n    state.ephemeralKey.remote\n  ])\n\n  const sigOk = await state.key.remote.verify(selectionIn, state.exchange.in.signature)\n\n  if (!sigOk) {\n    throw new Error('Bad signature')\n  }\n\n  log('2.1. verify - signature verified')\n}\n\nexports.generateKeys = async (state) => {\n  log('2.2. keys')\n\n  const secret = await state.shared.generate(state.exchange.in.epubkey)\n\n  state.shared.secret = secret\n\n  const keys = await crypto.keys.keyStretcher(\n    state.protocols.local.cipherT,\n    state.protocols.local.hashT,\n    state.shared.secret)\n\n  // use random nonces to decide order.\n  if (state.protocols.local.order > 0) {\n    state.protocols.local.keys = keys.k1\n    state.protocols.remote.keys = keys.k2\n  } else if (state.protocols.local.order < 0) {\n    // swap\n    state.protocols.local.keys = keys.k2\n    state.protocols.remote.keys = keys.k1\n  } else {\n    // we should've bailed before state. but if not, bail here.\n    throw new Error('you are trying to talk to yourself')\n  }\n\n  log('2.3. mac + cipher')\n\n  await Promise.all([state.protocols.local, state.protocols.remote].map(data => support.makeMacAndCipher(data)))\n}\n\nexports.verifyNonce = (state, n2) => {\n  const n1 = state.proposal.out.rand\n\n  if (uint8ArrayEquals(n1, n2)) return\n\n  throw new Error(\n    `Failed to read our encrypted nonce: ${uint8ArrayToString(n1, 'base16')} != ${uint8ArrayToString(n2, 'base16')}`\n  )\n}\n"]},"metadata":{},"sourceType":"script"}