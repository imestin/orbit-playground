{"ast":null,"code":"/* eslint max-nested-callbacks: [\"error\", 8] */\n'use strict';\n\nconst CID = require('cids');\n\nconst errCode = require('err-code');\n\nconst dagCborLinks = require('dag-cbor-links');\n\nconst debug = require('debug'); // const parallelBatch = require('it-parallel-batch')\n\n\nconst first = require('it-first');\n\nconst all = require('it-all');\n\nconst cbor = require('cbor');\n\nconst multibase = require('multibase');\n\nconst multicodec = require('multicodec'); // arbitrary limit to the number of concurrent dag operations\n// const WALK_DAG_CONCURRENCY_LIMIT = 300\n// const IS_PINNED_WITH_TYPE_CONCURRENCY_LIMIT = 300\n// const PIN_DS_KEY = new Key('/local/pins')\n\n\nfunction invalidPinTypeErr(type) {\n  const errMsg = `Invalid type '${type}', must be one of {direct, indirect, recursive, all}`;\n  return errCode(new Error(errMsg), 'ERR_INVALID_PIN_TYPE');\n}\n\nconst encoder = multibase.encoding('base32upper');\n\nfunction cidToKey(cid) {\n  return `/${encoder.encode(cid.multihash)}`;\n}\n\nfunction keyToMultihash(key) {\n  return encoder.decode(key.toString().slice(1));\n}\n\nconst PinTypes = {\n  direct: 'direct',\n  recursive: 'recursive',\n  indirect: 'indirect',\n  all: 'all'\n};\n\nclass PinManager {\n  constructor(repo, dag) {\n    this.repo = repo;\n    this.dag = dag;\n    this.log = debug('ipfs:pin');\n    this.directPins = new Set();\n    this.recursivePins = new Set();\n  }\n\n  async *_walkDag(cid, {\n    preload = false\n  }) {\n    const {\n      value: node\n    } = await this.dag.get(cid, {\n      preload\n    });\n\n    if (cid.codec === 'dag-pb') {\n      for (const link of node.Links) {\n        yield link.Hash;\n        yield* this._walkDag(link.Hash, {\n          preload\n        });\n      }\n    } else if (cid.codec === 'dag-cbor') {\n      for (const [_, childCid] of dagCborLinks(node)) {\n        // eslint-disable-line no-unused-vars\n        yield childCid;\n        yield* this._walkDag(childCid, {\n          preload\n        });\n      }\n    }\n  }\n\n  async pinDirectly(cid, options = {}) {\n    await this.dag.get(cid, options);\n    const pin = {\n      depth: 0\n    };\n\n    if (cid.version !== 0) {\n      pin.version = cid.version;\n    }\n\n    if (cid.codec !== 'dag-pb') {\n      pin.codec = multicodec.getNumber(cid.codec);\n    }\n\n    if (options.metadata) {\n      pin.metadata = options.metadata;\n    }\n\n    return this.repo.pins.put(cidToKey(cid), cbor.encode(pin));\n  }\n\n  async unpin(cid) {\n    // eslint-disable-line require-await\n    return this.repo.pins.delete(cidToKey(cid));\n  }\n\n  async pinRecursively(cid, options = {}) {\n    await this.fetchCompleteDag(cid, options);\n    const pin = {\n      depth: Infinity\n    };\n\n    if (cid.version !== 0) {\n      pin.version = cid.version;\n    }\n\n    if (cid.codec !== 'dag-pb') {\n      pin.codec = multicodec.getNumber(cid.codec);\n    }\n\n    if (options.metadata) {\n      pin.metadata = options.metadata;\n    }\n\n    await this.repo.pins.put(cidToKey(cid), cbor.encode(pin));\n  }\n\n  async *directKeys() {\n    for await (const entry of this.repo.pins.query({\n      filters: [entry => {\n        const pin = cbor.decode(entry.value);\n        return pin.depth === 0;\n      }]\n    })) {\n      const pin = cbor.decode(entry.value);\n      const version = pin.version || 0;\n      const codec = pin.codec ? multicodec.getName(pin.codec) : 'dag-pb';\n      const multihash = keyToMultihash(entry.key);\n      yield {\n        cid: new CID(version, codec, multihash),\n        metadata: pin.metadata\n      };\n    }\n  }\n\n  async *recursiveKeys() {\n    for await (const entry of this.repo.pins.query({\n      filters: [entry => {\n        const pin = cbor.decode(entry.value);\n        return pin.depth === Infinity;\n      }]\n    })) {\n      const pin = cbor.decode(entry.value);\n      const version = pin.version || 0;\n      const codec = pin.codec ? multicodec.getName(pin.codec) : 'dag-pb';\n      const multihash = keyToMultihash(entry.key);\n      yield {\n        cid: new CID(version, codec, multihash),\n        metadata: pin.metadata\n      };\n    }\n  }\n\n  async *indirectKeys({\n    preload\n  }) {\n    for await (const {\n      cid\n    } of this.recursiveKeys()) {\n      for await (const childCid of this._walkDag(cid, {\n        preload\n      })) {\n        // recursive pins override indirect pins\n        const types = [PinTypes.recursive];\n        const result = await this.isPinnedWithType(childCid, types);\n\n        if (result.pinned) {\n          continue;\n        }\n\n        yield childCid;\n      }\n    }\n  }\n\n  async isPinnedWithType(cid, types) {\n    if (!Array.isArray(types)) {\n      types = [types];\n    }\n\n    const all = types.includes(PinTypes.all);\n    const direct = types.includes(PinTypes.direct);\n    const recursive = types.includes(PinTypes.recursive);\n    const indirect = types.includes(PinTypes.indirect);\n\n    if (recursive || direct || all) {\n      const result = await first(this.repo.pins.query({\n        prefix: cidToKey(cid),\n        filters: [entry => {\n          if (all) {\n            return true;\n          }\n\n          const pin = cbor.decode(entry.value);\n          return types.includes(pin.depth === 0 ? PinTypes.direct : PinTypes.recursive);\n        }],\n        limit: 1\n      }));\n\n      if (result) {\n        const pin = cbor.decode(result.value);\n        return {\n          cid,\n          pinned: true,\n          reason: pin.depth === 0 ? PinTypes.direct : PinTypes.recursive,\n          metadata: pin.metadata\n        };\n      }\n    }\n\n    const self = this;\n\n    async function* findChild(key, source) {\n      for await (const {\n        cid: parentCid\n      } of source) {\n        for await (const childCid of self._walkDag(parentCid, {\n          preload: false\n        })) {\n          if (childCid.equals(key)) {\n            yield parentCid;\n            return;\n          }\n        }\n      }\n    }\n\n    if (all || indirect) {\n      // indirect (default)\n      // check each recursive key to see if multihash is under it\n      const parentCid = await first(findChild(cid, this.recursiveKeys()));\n\n      if (parentCid) {\n        return {\n          cid,\n          pinned: true,\n          reason: PinTypes.indirect,\n          parent: parentCid\n        };\n      }\n    }\n\n    return {\n      cid,\n      pinned: false\n    };\n  }\n\n  async fetchCompleteDag(cid, options) {\n    await all(this._walkDag(cid, {\n      preload: options.preload\n    }));\n  } // Throws an error if the pin type is invalid\n\n\n  static checkPinType(type) {\n    if (typeof type !== 'string' || !Object.keys(PinTypes).includes(type)) {\n      throw invalidPinTypeErr(type);\n    }\n  }\n\n}\n\nPinManager.PinTypes = PinTypes;\nmodule.exports = PinManager;","map":{"version":3,"sources":["/home/user/orbit-playground/music-app/node_modules/ipfs/src/core/components/pin/pin-manager.js"],"names":["CID","require","errCode","dagCborLinks","debug","first","all","cbor","multibase","multicodec","invalidPinTypeErr","type","errMsg","Error","encoder","encoding","cidToKey","cid","encode","multihash","keyToMultihash","key","decode","toString","slice","PinTypes","direct","recursive","indirect","PinManager","constructor","repo","dag","log","directPins","Set","recursivePins","_walkDag","preload","value","node","get","codec","link","Links","Hash","_","childCid","pinDirectly","options","pin","depth","version","getNumber","metadata","pins","put","unpin","delete","pinRecursively","fetchCompleteDag","Infinity","directKeys","entry","query","filters","getName","recursiveKeys","indirectKeys","types","result","isPinnedWithType","pinned","Array","isArray","includes","prefix","limit","reason","self","findChild","source","parentCid","equals","parent","checkPinType","Object","keys","module","exports"],"mappings":"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","sourcesContent":["/* eslint max-nested-callbacks: [\"error\", 8] */\n'use strict'\n\nconst CID = require('cids')\nconst errCode = require('err-code')\nconst dagCborLinks = require('dag-cbor-links')\nconst debug = require('debug')\n// const parallelBatch = require('it-parallel-batch')\nconst first = require('it-first')\nconst all = require('it-all')\nconst cbor = require('cbor')\nconst multibase = require('multibase')\nconst multicodec = require('multicodec')\n\n// arbitrary limit to the number of concurrent dag operations\n// const WALK_DAG_CONCURRENCY_LIMIT = 300\n// const IS_PINNED_WITH_TYPE_CONCURRENCY_LIMIT = 300\n// const PIN_DS_KEY = new Key('/local/pins')\n\nfunction invalidPinTypeErr (type) {\n  const errMsg = `Invalid type '${type}', must be one of {direct, indirect, recursive, all}`\n  return errCode(new Error(errMsg), 'ERR_INVALID_PIN_TYPE')\n}\n\nconst encoder = multibase.encoding('base32upper')\n\nfunction cidToKey (cid) {\n  return `/${encoder.encode(cid.multihash)}`\n}\n\nfunction keyToMultihash (key) {\n  return encoder.decode(key.toString().slice(1))\n}\n\nconst PinTypes = {\n  direct: 'direct',\n  recursive: 'recursive',\n  indirect: 'indirect',\n  all: 'all'\n}\n\nclass PinManager {\n  constructor (repo, dag) {\n    this.repo = repo\n    this.dag = dag\n    this.log = debug('ipfs:pin')\n    this.directPins = new Set()\n    this.recursivePins = new Set()\n  }\n\n  async * _walkDag (cid, { preload = false }) {\n    const { value: node } = await this.dag.get(cid, { preload })\n\n    if (cid.codec === 'dag-pb') {\n      for (const link of node.Links) {\n        yield link.Hash\n        yield * this._walkDag(link.Hash, { preload })\n      }\n    } else if (cid.codec === 'dag-cbor') {\n      for (const [_, childCid] of dagCborLinks(node)) { // eslint-disable-line no-unused-vars\n        yield childCid\n        yield * this._walkDag(childCid, { preload })\n      }\n    }\n  }\n\n  async pinDirectly (cid, options = {}) {\n    await this.dag.get(cid, options)\n\n    const pin = {\n      depth: 0\n    }\n\n    if (cid.version !== 0) {\n      pin.version = cid.version\n    }\n\n    if (cid.codec !== 'dag-pb') {\n      pin.codec = multicodec.getNumber(cid.codec)\n    }\n\n    if (options.metadata) {\n      pin.metadata = options.metadata\n    }\n\n    return this.repo.pins.put(cidToKey(cid), cbor.encode(pin))\n  }\n\n  async unpin (cid) { // eslint-disable-line require-await\n    return this.repo.pins.delete(cidToKey(cid))\n  }\n\n  async pinRecursively (cid, options = {}) {\n    await this.fetchCompleteDag(cid, options)\n\n    const pin = {\n      depth: Infinity\n    }\n\n    if (cid.version !== 0) {\n      pin.version = cid.version\n    }\n\n    if (cid.codec !== 'dag-pb') {\n      pin.codec = multicodec.getNumber(cid.codec)\n    }\n\n    if (options.metadata) {\n      pin.metadata = options.metadata\n    }\n\n    await this.repo.pins.put(cidToKey(cid), cbor.encode(pin))\n  }\n\n  async * directKeys () {\n    for await (const entry of this.repo.pins.query({\n      filters: [(entry) => {\n        const pin = cbor.decode(entry.value)\n\n        return pin.depth === 0\n      }]\n    })) {\n      const pin = cbor.decode(entry.value)\n      const version = pin.version || 0\n      const codec = pin.codec ? multicodec.getName(pin.codec) : 'dag-pb'\n      const multihash = keyToMultihash(entry.key)\n\n      yield {\n        cid: new CID(version, codec, multihash),\n        metadata: pin.metadata\n      }\n    }\n  }\n\n  async * recursiveKeys () {\n    for await (const entry of this.repo.pins.query({\n      filters: [(entry) => {\n        const pin = cbor.decode(entry.value)\n\n        return pin.depth === Infinity\n      }]\n    })) {\n      const pin = cbor.decode(entry.value)\n      const version = pin.version || 0\n      const codec = pin.codec ? multicodec.getName(pin.codec) : 'dag-pb'\n      const multihash = keyToMultihash(entry.key)\n\n      yield {\n        cid: new CID(version, codec, multihash),\n        metadata: pin.metadata\n      }\n    }\n  }\n\n  async * indirectKeys ({ preload }) {\n    for await (const { cid } of this.recursiveKeys()) {\n      for await (const childCid of this._walkDag(cid, { preload })) {\n        // recursive pins override indirect pins\n        const types = [\n          PinTypes.recursive\n        ]\n\n        const result = await this.isPinnedWithType(childCid, types)\n\n        if (result.pinned) {\n          continue\n        }\n\n        yield childCid\n      }\n    }\n  }\n\n  async isPinnedWithType (cid, types) {\n    if (!Array.isArray(types)) {\n      types = [types]\n    }\n\n    const all = types.includes(PinTypes.all)\n    const direct = types.includes(PinTypes.direct)\n    const recursive = types.includes(PinTypes.recursive)\n    const indirect = types.includes(PinTypes.indirect)\n\n    if (recursive || direct || all) {\n      const result = await first(this.repo.pins.query({\n        prefix: cidToKey(cid),\n        filters: [entry => {\n          if (all) {\n            return true\n          }\n\n          const pin = cbor.decode(entry.value)\n\n          return types.includes(pin.depth === 0 ? PinTypes.direct : PinTypes.recursive)\n        }],\n        limit: 1\n      }))\n\n      if (result) {\n        const pin = cbor.decode(result.value)\n\n        return {\n          cid,\n          pinned: true,\n          reason: pin.depth === 0 ? PinTypes.direct : PinTypes.recursive,\n          metadata: pin.metadata\n        }\n      }\n    }\n\n    const self = this\n\n    async function * findChild (key, source) {\n      for await (const { cid: parentCid } of source) {\n        for await (const childCid of self._walkDag(parentCid, { preload: false })) {\n          if (childCid.equals(key)) {\n            yield parentCid\n            return\n          }\n        }\n      }\n    }\n\n    if (all || indirect) {\n      // indirect (default)\n      // check each recursive key to see if multihash is under it\n\n      const parentCid = await first(findChild(cid, this.recursiveKeys()))\n\n      if (parentCid) {\n        return {\n          cid,\n          pinned: true,\n          reason: PinTypes.indirect,\n          parent: parentCid\n        }\n      }\n    }\n\n    return {\n      cid,\n      pinned: false\n    }\n  }\n\n  async fetchCompleteDag (cid, options) {\n    await all(this._walkDag(cid, { preload: options.preload }))\n  }\n\n  // Throws an error if the pin type is invalid\n  static checkPinType (type) {\n    if (typeof type !== 'string' || !Object.keys(PinTypes).includes(type)) {\n      throw invalidPinTypeErr(type)\n    }\n  }\n}\n\nPinManager.PinTypes = PinTypes\n\nmodule.exports = PinManager\n"]},"metadata":{},"sourceType":"script"}