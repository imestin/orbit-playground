{"ast":null,"code":"'use strict';\n\nconst defaultMigrations = require('../migrations');\n\nconst repoVersion = require('./repo/version');\n\nconst repoLock = require('./repo/lock');\n\nconst errors = require('./errors');\n\nconst log = require('debug')('ipfs:repo:migrator');\n\nexports.getCurrentRepoVersion = repoVersion.getVersion;\nexports.errors = errors;\n/**\n * Returns the version of latest migration.\n * If no migrations are present returns 0.\n *\n * @param {array?} migrations - Array of migrations to consider. If undefined, the bundled migrations are used. Mainly for testing purpose.\n * @returns {int}\n */\n\nfunction getLatestMigrationVersion(migrations) {\n  migrations = migrations || defaultMigrations;\n\n  if (!Array.isArray(migrations) || migrations.length === 0) {\n    return 0;\n  }\n\n  return migrations[migrations.length - 1].version;\n}\n\nexports.getLatestMigrationVersion = getLatestMigrationVersion;\n/**\n * Main function to execute forward migrations.\n * It acquire lock on the provided path before doing any migrations.\n *\n * Signature of the progress callback is: function(migrationObject: object, currentMigrationNumber: int, totalMigrationsCount: int)\n *\n * @param {string} path - Path to initialized (!) JS-IPFS repo\n * @param {Object} repoOptions - Options that are passed to migrations, that can use them to correctly construct datastore. Options are same like for IPFSRepo.\n * @param {int} toVersion - Version to which the repo should be migrated.\n * @param {Object?} options - Options for migration\n * @param {boolean?} options.ignoreLock - Won't lock the repo for applying the migrations. Use with caution.\n * @param {function?} options.onProgress - Callback which will be called after each executed migration to report progress\n * @param {boolean?} options.isDryRun - Allows to simulate the execution of the migrations without any effect.\n * @param {array?} options.migrations - Array of migrations to migrate. If undefined, the bundled migrations are used. Mainly for testing purpose.\n * @returns {Promise<void>}\n */\n\nasync function migrate(path, repoOptions, toVersion, {\n  ignoreLock = false,\n  onProgress,\n  isDryRun = false,\n  migrations\n}) {\n  migrations = migrations || defaultMigrations;\n\n  if (!path) {\n    throw new errors.RequiredParameterError('Path argument is required!');\n  }\n\n  if (!repoOptions) {\n    throw new errors.RequiredParameterError('repoOptions argument is required!');\n  }\n\n  if (!toVersion) {\n    throw new errors.RequiredParameterError('toVersion argument is required!');\n  }\n\n  if (!Number.isInteger(toVersion) || toVersion <= 0) {\n    throw new errors.InvalidValueError('Version has to be positive integer!');\n  }\n\n  const currentVersion = await repoVersion.getVersion(path, repoOptions);\n\n  if (currentVersion === toVersion) {\n    log('Nothing to migrate.');\n    return;\n  }\n\n  if (currentVersion > toVersion) {\n    throw new errors.InvalidValueError(`Current repo's version (${currentVersion}) is higher then toVersion (${toVersion}), you probably wanted to revert it?`);\n  }\n\n  verifyAvailableMigrations(migrations, currentVersion, toVersion);\n  let lock;\n\n  if (!isDryRun && !ignoreLock) {\n    lock = await repoLock.lock(currentVersion, path);\n  }\n\n  try {\n    for (const migration of migrations) {\n      if (toVersion !== undefined && migration.version > toVersion) {\n        break;\n      }\n\n      if (migration.version <= currentVersion) {\n        continue;\n      }\n\n      log(`Migrating version ${migration.version}`);\n\n      try {\n        if (!isDryRun) {\n          let progressCallback;\n\n          if (onProgress) {\n            // eslint-disable-line max-depth\n            progressCallback = (percent, message) => onProgress(migration.version, percent.toFixed(2), message);\n          }\n\n          await migration.migrate(path, repoOptions, progressCallback);\n        }\n      } catch (e) {\n        const lastSuccessfullyMigratedVersion = migration.version - 1;\n        log(`An exception was raised during execution of migration. Setting the repo's version to last successfully migrated version: ${lastSuccessfullyMigratedVersion}`);\n        await repoVersion.setVersion(path, lastSuccessfullyMigratedVersion, repoOptions);\n        throw new Error(`During migration to version ${migration.version} exception was raised: ${e.stack || e.message || e}`);\n      }\n\n      log(`Migrating to version ${migration.version} finished`);\n    }\n\n    if (!isDryRun) {\n      await repoVersion.setVersion(path, toVersion || getLatestMigrationVersion(migrations), repoOptions);\n    }\n\n    log('Repo successfully migrated ', toVersion !== undefined ? `to version ${toVersion}!` : 'to latest version!');\n  } finally {\n    if (!isDryRun && !ignoreLock) {\n      await lock.close();\n    }\n  }\n}\n\nexports.migrate = migrate;\n/**\n * Main function to execute backward migration (reversion).\n * It acquire lock on the provided path before doing any migrations.\n *\n * Signature of the progress callback is: function(migrationObject: object, currentMigrationNumber: int, totalMigrationsCount: int)\n *\n * @param {string} path - Path to initialized (!) JS-IPFS repo\n * @param {Object} repoOptions - Options that are passed to migrations, that can use them to correctly construct datastore. Options are same like for IPFSRepo.\n * @param {int} toVersion - Version to which the repo will be reverted.\n * @param {Object?} options - Options for the reversion\n * @param {function?} options.onProgress - Callback which will be called after each reverted migration to report progress\n * @param {boolean?} options.isDryRun - Allows to simulate the execution of the reversion without any effects. Make sense to utilize onProgress with this argument.\n * @param {boolean?} options.ignoreLock - Won't lock the repo for reverting the migrations. Use with caution.\n * @param {array?} options.migrations - Array of migrations to migrate. If undefined, the bundled migrations are used. Mainly for testing purpose.\n * @returns {Promise<void>}\n */\n\nasync function revert(path, repoOptions, toVersion, {\n  ignoreLock = false,\n  onProgress,\n  isDryRun = false,\n  migrations\n}) {\n  migrations = migrations || defaultMigrations;\n\n  if (!path) {\n    throw new errors.RequiredParameterError('Path argument is required!');\n  }\n\n  if (!repoOptions) {\n    throw new errors.RequiredParameterError('repoOptions argument is required!');\n  }\n\n  if (!toVersion) {\n    throw new errors.RequiredParameterError('When reverting migrations, you have to specify to which version to revert!');\n  }\n\n  if (!Number.isInteger(toVersion) || toVersion <= 0) {\n    throw new errors.InvalidValueError('Version has to be positive integer!');\n  }\n\n  const currentVersion = await repoVersion.getVersion(path, repoOptions);\n\n  if (currentVersion === toVersion) {\n    log('Nothing to revert.');\n    return;\n  }\n\n  if (currentVersion < toVersion) {\n    throw new errors.InvalidValueError(`Current repo's version (${currentVersion}) is lower then toVersion (${toVersion}), you probably wanted to migrate it?`);\n  }\n\n  verifyAvailableMigrations(migrations, toVersion, currentVersion, true);\n  let lock;\n  if (!isDryRun && !ignoreLock) lock = await repoLock.lock(currentVersion, path);\n  log(`Reverting from version ${currentVersion} to ${toVersion}`);\n\n  try {\n    const reversedMigrationArray = migrations.slice().reverse();\n\n    for (const migration of reversedMigrationArray) {\n      if (migration.version <= toVersion) {\n        break;\n      }\n\n      if (migration.version > currentVersion) {\n        continue;\n      }\n\n      log(`Reverting migration version ${migration.version}`);\n\n      try {\n        if (!isDryRun) {\n          let progressCallback;\n\n          if (onProgress) {\n            // eslint-disable-line max-depth\n            progressCallback = (percent, message) => onProgress(migration.version, percent.toFixed(2), message);\n          }\n\n          await migration.revert(path, repoOptions, progressCallback);\n        }\n      } catch (e) {\n        const lastSuccessfullyRevertedVersion = migration.version;\n        log(`An exception was raised during execution of migration. Setting the repo's version to last successfully reverted version: ${lastSuccessfullyRevertedVersion}`);\n        await repoVersion.setVersion(path, lastSuccessfullyRevertedVersion, repoOptions);\n        e.message = `During reversion to version ${migration.version} exception was raised: ${e.message}`;\n        throw e;\n      }\n\n      log(`Reverting to version ${migration.version} finished`);\n    }\n\n    if (!isDryRun) {\n      await repoVersion.setVersion(path, toVersion, repoOptions);\n    }\n\n    log(`All migrations successfully reverted to version ${toVersion}!`);\n  } finally {\n    if (!isDryRun && !ignoreLock) {\n      await lock.close();\n    }\n  }\n}\n\nexports.revert = revert;\n/**\n * Function checks if all migrations in given range are available.\n *\n * @param {array} migrations\n * @param {int} fromVersion\n * @param {int} toVersion\n * @param {boolean} checkReversibility - Will additionally checks if all the migrations in the range are reversible\n * @returns {void}\n */\n\nfunction verifyAvailableMigrations(migrations, fromVersion, toVersion, checkReversibility = false) {\n  let migrationCounter = 0;\n\n  for (const migration of migrations) {\n    if (migration.version > toVersion) {\n      break;\n    }\n\n    if (migration.version > fromVersion) {\n      if (checkReversibility && !migration.revert) {\n        throw new errors.NonReversibleMigrationError(`It is not possible to revert to version ${fromVersion} because migration version ${migration.version} is not reversible. Cancelling reversion.`);\n      }\n\n      migrationCounter++;\n    }\n  }\n\n  if (migrationCounter !== toVersion - fromVersion) {\n    throw new errors.InvalidValueError(`The ipfs-repo-migrations package does not have all migration to migrate from version ${fromVersion} to ${toVersion}`);\n  }\n}","map":{"version":3,"sources":["/home/user/orbit-playground/music-app/node_modules/ipfs-repo-migrations/src/index.js"],"names":["defaultMigrations","require","repoVersion","repoLock","errors","log","exports","getCurrentRepoVersion","getVersion","getLatestMigrationVersion","migrations","Array","isArray","length","version","migrate","path","repoOptions","toVersion","ignoreLock","onProgress","isDryRun","RequiredParameterError","Number","isInteger","InvalidValueError","currentVersion","verifyAvailableMigrations","lock","migration","undefined","progressCallback","percent","message","toFixed","e","lastSuccessfullyMigratedVersion","setVersion","Error","stack","close","revert","reversedMigrationArray","slice","reverse","lastSuccessfullyRevertedVersion","fromVersion","checkReversibility","migrationCounter","NonReversibleMigrationError"],"mappings":"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","sourcesContent":["'use strict'\n\nconst defaultMigrations = require('../migrations')\nconst repoVersion = require('./repo/version')\nconst repoLock = require('./repo/lock')\nconst errors = require('./errors')\n\nconst log = require('debug')('ipfs:repo:migrator')\n\nexports.getCurrentRepoVersion = repoVersion.getVersion\nexports.errors = errors\n\n/**\n * Returns the version of latest migration.\n * If no migrations are present returns 0.\n *\n * @param {array?} migrations - Array of migrations to consider. If undefined, the bundled migrations are used. Mainly for testing purpose.\n * @returns {int}\n */\nfunction getLatestMigrationVersion (migrations) {\n  migrations = migrations || defaultMigrations\n\n  if (!Array.isArray(migrations) || migrations.length === 0) {\n    return 0\n  }\n\n  return migrations[migrations.length - 1].version\n}\n\nexports.getLatestMigrationVersion = getLatestMigrationVersion\n\n/**\n * Main function to execute forward migrations.\n * It acquire lock on the provided path before doing any migrations.\n *\n * Signature of the progress callback is: function(migrationObject: object, currentMigrationNumber: int, totalMigrationsCount: int)\n *\n * @param {string} path - Path to initialized (!) JS-IPFS repo\n * @param {Object} repoOptions - Options that are passed to migrations, that can use them to correctly construct datastore. Options are same like for IPFSRepo.\n * @param {int} toVersion - Version to which the repo should be migrated.\n * @param {Object?} options - Options for migration\n * @param {boolean?} options.ignoreLock - Won't lock the repo for applying the migrations. Use with caution.\n * @param {function?} options.onProgress - Callback which will be called after each executed migration to report progress\n * @param {boolean?} options.isDryRun - Allows to simulate the execution of the migrations without any effect.\n * @param {array?} options.migrations - Array of migrations to migrate. If undefined, the bundled migrations are used. Mainly for testing purpose.\n * @returns {Promise<void>}\n */\nasync function migrate (path, repoOptions, toVersion, { ignoreLock = false, onProgress, isDryRun = false, migrations }) {\n  migrations = migrations || defaultMigrations\n\n  if (!path) {\n    throw new errors.RequiredParameterError('Path argument is required!')\n  }\n\n  if (!repoOptions) {\n    throw new errors.RequiredParameterError('repoOptions argument is required!')\n  }\n\n  if (!toVersion) {\n    throw new errors.RequiredParameterError('toVersion argument is required!')\n  }\n\n  if (!Number.isInteger(toVersion) || toVersion <= 0) {\n    throw new errors.InvalidValueError('Version has to be positive integer!')\n  }\n\n  const currentVersion = await repoVersion.getVersion(path, repoOptions)\n\n  if (currentVersion === toVersion) {\n    log('Nothing to migrate.')\n    return\n  }\n\n  if (currentVersion > toVersion) {\n    throw new errors.InvalidValueError(`Current repo's version (${currentVersion}) is higher then toVersion (${toVersion}), you probably wanted to revert it?`)\n  }\n\n  verifyAvailableMigrations(migrations, currentVersion, toVersion)\n\n  let lock\n\n  if (!isDryRun && !ignoreLock) {\n    lock = await repoLock.lock(currentVersion, path)\n  }\n\n  try {\n    for (const migration of migrations) {\n      if (toVersion !== undefined && migration.version > toVersion) {\n        break\n      }\n\n      if (migration.version <= currentVersion) {\n        continue\n      }\n\n      log(`Migrating version ${migration.version}`)\n\n      try {\n        if (!isDryRun) {\n          let progressCallback\n\n          if (onProgress) { // eslint-disable-line max-depth\n            progressCallback = (percent, message) => onProgress(migration.version, percent.toFixed(2), message)\n          }\n\n          await migration.migrate(path, repoOptions, progressCallback)\n        }\n      } catch (e) {\n        const lastSuccessfullyMigratedVersion = migration.version - 1\n\n        log(`An exception was raised during execution of migration. Setting the repo's version to last successfully migrated version: ${lastSuccessfullyMigratedVersion}`)\n        await repoVersion.setVersion(path, lastSuccessfullyMigratedVersion, repoOptions)\n\n        throw new Error(`During migration to version ${migration.version} exception was raised: ${e.stack || e.message || e}`)\n      }\n\n      log(`Migrating to version ${migration.version} finished`)\n    }\n\n    if (!isDryRun) {\n      await repoVersion.setVersion(path, toVersion || getLatestMigrationVersion(migrations), repoOptions)\n    }\n\n    log('Repo successfully migrated ', toVersion !== undefined ? `to version ${toVersion}!` : 'to latest version!')\n  } finally {\n    if (!isDryRun && !ignoreLock) {\n      await lock.close()\n    }\n  }\n}\n\nexports.migrate = migrate\n\n/**\n * Main function to execute backward migration (reversion).\n * It acquire lock on the provided path before doing any migrations.\n *\n * Signature of the progress callback is: function(migrationObject: object, currentMigrationNumber: int, totalMigrationsCount: int)\n *\n * @param {string} path - Path to initialized (!) JS-IPFS repo\n * @param {Object} repoOptions - Options that are passed to migrations, that can use them to correctly construct datastore. Options are same like for IPFSRepo.\n * @param {int} toVersion - Version to which the repo will be reverted.\n * @param {Object?} options - Options for the reversion\n * @param {function?} options.onProgress - Callback which will be called after each reverted migration to report progress\n * @param {boolean?} options.isDryRun - Allows to simulate the execution of the reversion without any effects. Make sense to utilize onProgress with this argument.\n * @param {boolean?} options.ignoreLock - Won't lock the repo for reverting the migrations. Use with caution.\n * @param {array?} options.migrations - Array of migrations to migrate. If undefined, the bundled migrations are used. Mainly for testing purpose.\n * @returns {Promise<void>}\n */\nasync function revert (path, repoOptions, toVersion, { ignoreLock = false, onProgress, isDryRun = false, migrations }) {\n  migrations = migrations || defaultMigrations\n\n  if (!path) {\n    throw new errors.RequiredParameterError('Path argument is required!')\n  }\n\n  if (!repoOptions) {\n    throw new errors.RequiredParameterError('repoOptions argument is required!')\n  }\n\n  if (!toVersion) {\n    throw new errors.RequiredParameterError('When reverting migrations, you have to specify to which version to revert!')\n  }\n\n  if (!Number.isInteger(toVersion) || toVersion <= 0) {\n    throw new errors.InvalidValueError('Version has to be positive integer!')\n  }\n\n  const currentVersion = await repoVersion.getVersion(path, repoOptions)\n\n  if (currentVersion === toVersion) {\n    log('Nothing to revert.')\n    return\n  }\n\n  if (currentVersion < toVersion) {\n    throw new errors.InvalidValueError(`Current repo's version (${currentVersion}) is lower then toVersion (${toVersion}), you probably wanted to migrate it?`)\n  }\n\n  verifyAvailableMigrations(migrations, toVersion, currentVersion, true)\n\n  let lock\n  if (!isDryRun && !ignoreLock) lock = await repoLock.lock(currentVersion, path)\n\n  log(`Reverting from version ${currentVersion} to ${toVersion}`)\n\n  try {\n    const reversedMigrationArray = migrations.slice().reverse()\n\n    for (const migration of reversedMigrationArray) {\n      if (migration.version <= toVersion) {\n        break\n      }\n\n      if (migration.version > currentVersion) {\n        continue\n      }\n\n      log(`Reverting migration version ${migration.version}`)\n\n      try {\n        if (!isDryRun) {\n          let progressCallback\n\n          if (onProgress) { // eslint-disable-line max-depth\n            progressCallback = (percent, message) => onProgress(migration.version, percent.toFixed(2), message)\n          }\n\n          await migration.revert(path, repoOptions, progressCallback)\n        }\n      } catch (e) {\n        const lastSuccessfullyRevertedVersion = migration.version\n        log(`An exception was raised during execution of migration. Setting the repo's version to last successfully reverted version: ${lastSuccessfullyRevertedVersion}`)\n        await repoVersion.setVersion(path, lastSuccessfullyRevertedVersion, repoOptions)\n\n        e.message = `During reversion to version ${migration.version} exception was raised: ${e.message}`\n        throw e\n      }\n\n      log(`Reverting to version ${migration.version} finished`)\n    }\n\n    if (!isDryRun) {\n      await repoVersion.setVersion(path, toVersion, repoOptions)\n    }\n\n    log(`All migrations successfully reverted to version ${toVersion}!`)\n  } finally {\n    if (!isDryRun && !ignoreLock) {\n      await lock.close()\n    }\n  }\n}\n\nexports.revert = revert\n\n/**\n * Function checks if all migrations in given range are available.\n *\n * @param {array} migrations\n * @param {int} fromVersion\n * @param {int} toVersion\n * @param {boolean} checkReversibility - Will additionally checks if all the migrations in the range are reversible\n * @returns {void}\n */\nfunction verifyAvailableMigrations (migrations, fromVersion, toVersion, checkReversibility = false) {\n  let migrationCounter = 0\n  for (const migration of migrations) {\n    if (migration.version > toVersion) {\n      break\n    }\n\n    if (migration.version > fromVersion) {\n      if (checkReversibility && !migration.revert) {\n        throw new errors.NonReversibleMigrationError(`It is not possible to revert to version ${fromVersion} because migration version ${migration.version} is not reversible. Cancelling reversion.`)\n      }\n\n      migrationCounter++\n    }\n  }\n\n  if (migrationCounter !== (toVersion - fromVersion)) {\n    throw new errors.InvalidValueError(`The ipfs-repo-migrations package does not have all migration to migrate from version ${fromVersion} to ${toVersion}`)\n  }\n}\n"]},"metadata":{},"sourceType":"script"}