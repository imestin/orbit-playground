{"ast":null,"code":"'use strict';\n\nconst PeerId = require('peer-id');\n\nconst CID = require('cids');\n\nconst errCode = require('err-code');\n\nconst {\n  withTimeoutOption\n} = require('../utils');\n\nmodule.exports = ({\n  libp2p,\n  repo\n}) => {\n  return {\n    /**\n     * Given a key, query the DHT for its best value.\n     *\n     * @param {Uint8Array} key\n     * @param {Object} [options] - get options\n     * @param {number} [options.timeout] - optional timeout\n     * @returns {Promise<Uint8Array>}\n     */\n    get: withTimeoutOption(async (key, options) => {\n      // eslint-disable-line require-await\n      options = options || {};\n\n      if (!(key instanceof Uint8Array)) {\n        try {\n          key = key.toString().split('/').filter(part => part && part !== 'ipfs' && part !== 'ipns').shift();\n          key = new CID(key).bytes;\n        } catch (err) {\n          throw errCode(err, 'ERR_INVALID_CID');\n        }\n      }\n\n      return libp2p._dht.get(key, options);\n    }),\n\n    /**\n     * Write a key/value pair to the DHT.\n     *\n     * Given a key of the form /foo/bar and a value of any\n     * form, this will write that value to the DHT with\n     * that key.\n     *\n     * @param {Uint8Array} key\n     * @param {Uint8Array} value\n     * @returns {Promise}\n     */\n    put: withTimeoutOption(async (key, value) => {\n      // eslint-disable-line require-await\n      if (!(key instanceof Uint8Array)) {\n        try {\n          key = key.toString().split('/').filter(part => part && part !== 'ipfs' && part !== 'ipns').shift();\n          key = new CID(key).bytes;\n        } catch (err) {\n          throw errCode(err, 'ERR_INVALID_CID');\n        }\n      }\n\n      return libp2p._dht.put(key, value);\n    }),\n\n    /**\n     * Find peers in the DHT that can provide a specific value, given a key.\n     *\n     * @param {CID} key - They key to find providers for.\n     * @param {Object} [options] - findProviders options\n     * @param {number} [options.timeout] - how long the query should maximally run, in milliseconds (default: 60000)\n     * @param {number} [options.numProviders] - maximum number of providers to find\n     * @returns {AsyncIterable<{ id: CID, addrs: Multiaddr[] }>}\n     */\n    findProvs: withTimeoutOption(async function* (key, options) {\n      // eslint-disable-line require-await\n      options = options || {};\n\n      if (typeof key === 'string') {\n        try {\n          key = new CID(key);\n        } catch (err) {\n          throw errCode(err, 'ERR_INVALID_CID');\n        }\n      }\n\n      if (options.numProviders) {\n        options.maxNumProviders = options.numProviders;\n      }\n\n      for await (const peer of libp2p._dht.findProviders(key, options)) {\n        yield {\n          id: peer.id.toB58String(),\n          addrs: peer.addrs\n        };\n      }\n    }),\n\n    /**\n     * Query the DHT for all multiaddresses associated with a `PeerId`.\n     *\n     * @param {PeerId} peerId - The id of the peer to search for.\n     * @returns {Promise<{ id: String, addrs: Multiaddr[] }>}\n     */\n    findPeer: withTimeoutOption(async peerId => {\n      // eslint-disable-line require-await\n      if (typeof peerId === 'string') {\n        peerId = PeerId.createFromCID(peerId);\n      }\n\n      const peer = await libp2p._dht.findPeer(peerId);\n      return {\n        id: peer.id.toB58String(),\n        addrs: peer.multiaddrs\n      };\n    }),\n\n    /**\n     * Announce to the network that we are providing given values.\n     *\n     * @param {CID|CID[]} cids - The keys that should be announced.\n     * @param {Object} [options] - provide options\n     * @param {bool} [options.recursive=false] - Provide not only the given object but also all objects linked from it.\n     * @returns {Promise}\n     */\n    provide: withTimeoutOption(async function* (cids, options) {\n      cids = Array.isArray(cids) ? cids : [cids];\n      options = options || {};\n\n      for (var i in cids) {\n        if (typeof cids[i] === 'string') {\n          try {\n            cids[i] = new CID(cids[i]);\n          } catch (err) {\n            throw errCode(err, 'ERR_INVALID_CID');\n          }\n        }\n      } // ensure blocks are actually local\n\n\n      const hasCids = await Promise.all(cids.map(cid => repo.blocks.has(cid)));\n      const hasAll = hasCids.every(has => has);\n\n      if (!hasAll) {\n        throw errCode(new Error('block(s) not found locally, cannot provide'), 'ERR_BLOCK_NOT_FOUND');\n      }\n\n      if (options.recursive) {\n        // TODO: Implement recursive providing\n        throw errCode(new Error('not implemented yet'), 'ERR_NOT_IMPLEMENTED_YET');\n      }\n\n      for (const cid of cids) {\n        yield libp2p._dht.provide(cid);\n      }\n    }),\n\n    /**\n     * Find the closest peers to a given `PeerId`, by querying the DHT.\n     *\n     * @param {string|PeerId} peerId - The `PeerId` to run the query against.\n     * @returns {AsyncIterable<{ id: CID, addrs: Multiaddr[] }>}\n     */\n    query: withTimeoutOption(async function* (peerId) {\n      if (typeof peerId === 'string') {\n        peerId = PeerId.createFromCID(peerId);\n      }\n\n      for await (const closerPeerId of libp2p._dht.getClosestPeers(peerId.toBytes())) {\n        yield {\n          id: closerPeerId.toB58String(),\n          addrs: [] // TODO: get addrs?\n\n        };\n      }\n    })\n  };\n};","map":{"version":3,"sources":["/home/user/orbit-playground/music-app/node_modules/ipfs/src/core/components/dht.js"],"names":["PeerId","require","CID","errCode","withTimeoutOption","module","exports","libp2p","repo","get","key","options","Uint8Array","toString","split","filter","part","shift","bytes","err","_dht","put","value","findProvs","numProviders","maxNumProviders","peer","findProviders","id","toB58String","addrs","findPeer","peerId","createFromCID","multiaddrs","provide","cids","Array","isArray","i","hasCids","Promise","all","map","cid","blocks","has","hasAll","every","Error","recursive","query","closerPeerId","getClosestPeers","toBytes"],"mappings":"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","sourcesContent":["'use strict'\n\nconst PeerId = require('peer-id')\nconst CID = require('cids')\nconst errCode = require('err-code')\nconst { withTimeoutOption } = require('../utils')\n\nmodule.exports = ({ libp2p, repo }) => {\n  return {\n    /**\n     * Given a key, query the DHT for its best value.\n     *\n     * @param {Uint8Array} key\n     * @param {Object} [options] - get options\n     * @param {number} [options.timeout] - optional timeout\n     * @returns {Promise<Uint8Array>}\n     */\n    get: withTimeoutOption(async (key, options) => { // eslint-disable-line require-await\n      options = options || {}\n\n      if (!(key instanceof Uint8Array)) {\n        try {\n          key = key.toString().split('/')\n            .filter(part => part && part !== 'ipfs' && part !== 'ipns')\n            .shift()\n\n          key = (new CID(key)).bytes\n        } catch (err) {\n          throw errCode(err, 'ERR_INVALID_CID')\n        }\n      }\n\n      return libp2p._dht.get(key, options)\n    }),\n\n    /**\n     * Write a key/value pair to the DHT.\n     *\n     * Given a key of the form /foo/bar and a value of any\n     * form, this will write that value to the DHT with\n     * that key.\n     *\n     * @param {Uint8Array} key\n     * @param {Uint8Array} value\n     * @returns {Promise}\n     */\n    put: withTimeoutOption(async (key, value) => { // eslint-disable-line require-await\n      if (!(key instanceof Uint8Array)) {\n        try {\n          key = key.toString().split('/')\n            .filter(part => part && part !== 'ipfs' && part !== 'ipns')\n            .shift()\n\n          key = (new CID(key)).bytes\n        } catch (err) {\n          throw errCode(err, 'ERR_INVALID_CID')\n        }\n      }\n\n      return libp2p._dht.put(key, value)\n    }),\n\n    /**\n     * Find peers in the DHT that can provide a specific value, given a key.\n     *\n     * @param {CID} key - They key to find providers for.\n     * @param {Object} [options] - findProviders options\n     * @param {number} [options.timeout] - how long the query should maximally run, in milliseconds (default: 60000)\n     * @param {number} [options.numProviders] - maximum number of providers to find\n     * @returns {AsyncIterable<{ id: CID, addrs: Multiaddr[] }>}\n     */\n    findProvs: withTimeoutOption(async function * (key, options) { // eslint-disable-line require-await\n      options = options || {}\n\n      if (typeof key === 'string') {\n        try {\n          key = new CID(key)\n        } catch (err) {\n          throw errCode(err, 'ERR_INVALID_CID')\n        }\n      }\n\n      if (options.numProviders) {\n        options.maxNumProviders = options.numProviders\n      }\n\n      for await (const peer of libp2p._dht.findProviders(key, options)) {\n        yield {\n          id: peer.id.toB58String(),\n          addrs: peer.addrs\n        }\n      }\n    }),\n\n    /**\n     * Query the DHT for all multiaddresses associated with a `PeerId`.\n     *\n     * @param {PeerId} peerId - The id of the peer to search for.\n     * @returns {Promise<{ id: String, addrs: Multiaddr[] }>}\n     */\n    findPeer: withTimeoutOption(async peerId => { // eslint-disable-line require-await\n      if (typeof peerId === 'string') {\n        peerId = PeerId.createFromCID(peerId)\n      }\n\n      const peer = await libp2p._dht.findPeer(peerId)\n\n      return {\n        id: peer.id.toB58String(),\n        addrs: peer.multiaddrs\n      }\n    }),\n\n    /**\n     * Announce to the network that we are providing given values.\n     *\n     * @param {CID|CID[]} cids - The keys that should be announced.\n     * @param {Object} [options] - provide options\n     * @param {bool} [options.recursive=false] - Provide not only the given object but also all objects linked from it.\n     * @returns {Promise}\n     */\n    provide: withTimeoutOption(async function * (cids, options) {\n      cids = Array.isArray(cids) ? cids : [cids]\n      options = options || {}\n\n      for (var i in cids) {\n        if (typeof cids[i] === 'string') {\n          try {\n            cids[i] = new CID(cids[i])\n          } catch (err) {\n            throw errCode(err, 'ERR_INVALID_CID')\n          }\n        }\n      }\n\n      // ensure blocks are actually local\n      const hasCids = await Promise.all(cids.map(cid => repo.blocks.has(cid)))\n      const hasAll = hasCids.every(has => has)\n\n      if (!hasAll) {\n        throw errCode(new Error('block(s) not found locally, cannot provide'), 'ERR_BLOCK_NOT_FOUND')\n      }\n\n      if (options.recursive) {\n        // TODO: Implement recursive providing\n        throw errCode(new Error('not implemented yet'), 'ERR_NOT_IMPLEMENTED_YET')\n      }\n\n      for (const cid of cids) {\n        yield libp2p._dht.provide(cid)\n      }\n    }),\n\n    /**\n     * Find the closest peers to a given `PeerId`, by querying the DHT.\n     *\n     * @param {string|PeerId} peerId - The `PeerId` to run the query against.\n     * @returns {AsyncIterable<{ id: CID, addrs: Multiaddr[] }>}\n     */\n    query: withTimeoutOption(async function * (peerId) {\n      if (typeof peerId === 'string') {\n        peerId = PeerId.createFromCID(peerId)\n      }\n\n      for await (const closerPeerId of libp2p._dht.getClosestPeers(peerId.toBytes())) {\n        yield {\n          id: closerPeerId.toB58String(),\n          addrs: [] // TODO: get addrs?\n        }\n      }\n    })\n  }\n}\n"]},"metadata":{},"sourceType":"script"}