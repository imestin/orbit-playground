{"ast":null,"code":"\"use strict\";\n/* eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars */\n\n(function (global, factory) {\n  /* AMD */\n  if (typeof define === 'function' && define.amd) {\n    define(['protobufjs/minimal'], factory);\n  }\n  /* CommonJS */\n  else if (typeof require === 'function' && typeof module === 'object' && module && module.exports) {\n      module.exports = factory(require('protobufjs/minimal'));\n    }\n})(this, function ($protobuf) {\n  // Common aliases\n  var $Reader = $protobuf.Reader;\n  var $Writer = $protobuf.Writer;\n  var $util = $protobuf.util; // Exported root namespace\n\n  var $root = $protobuf.roots.default || ($protobuf.roots.default = {});\n\n  $root.pb = function () {\n    /**\n         * Namespace pb.\n         * @exports pb\n         * @namespace\n         */\n    var pb = {};\n\n    pb.NoiseHandshakePayload = function () {\n      /**\n             * Properties of a NoiseHandshakePayload.\n             * @memberof pb\n             * @interface INoiseHandshakePayload\n             * @property {Uint8Array|null} [identityKey] NoiseHandshakePayload identityKey\n             * @property {Uint8Array|null} [identitySig] NoiseHandshakePayload identitySig\n             * @property {Uint8Array|null} [data] NoiseHandshakePayload data\n             */\n\n      /**\n             * Constructs a new NoiseHandshakePayload.\n             * @memberof pb\n             * @classdesc Represents a NoiseHandshakePayload.\n             * @implements INoiseHandshakePayload\n             * @constructor\n             * @param {pb.INoiseHandshakePayload=} [properties] Properties to set\n             */\n      function NoiseHandshakePayload(properties) {\n        if (properties) {\n          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) {\n              this[keys[i]] = properties[keys[i]];\n            }\n          }\n        }\n      }\n      /**\n             * NoiseHandshakePayload identityKey.\n             * @member {Uint8Array} identityKey\n             * @memberof pb.NoiseHandshakePayload\n             * @instance\n             */\n\n\n      NoiseHandshakePayload.prototype.identityKey = $util.newBuffer([]);\n      /**\n             * NoiseHandshakePayload identitySig.\n             * @member {Uint8Array} identitySig\n             * @memberof pb.NoiseHandshakePayload\n             * @instance\n             */\n\n      NoiseHandshakePayload.prototype.identitySig = $util.newBuffer([]);\n      /**\n             * NoiseHandshakePayload data.\n             * @member {Uint8Array} data\n             * @memberof pb.NoiseHandshakePayload\n             * @instance\n             */\n\n      NoiseHandshakePayload.prototype.data = $util.newBuffer([]);\n      /**\n             * Creates a new NoiseHandshakePayload instance using the specified properties.\n             * @function create\n             * @memberof pb.NoiseHandshakePayload\n             * @static\n             * @param {pb.INoiseHandshakePayload=} [properties] Properties to set\n             * @returns {pb.NoiseHandshakePayload} NoiseHandshakePayload instance\n             */\n\n      NoiseHandshakePayload.create = function create(properties) {\n        return new NoiseHandshakePayload(properties);\n      };\n      /**\n             * Encodes the specified NoiseHandshakePayload message. Does not implicitly {@link pb.NoiseHandshakePayload.verify|verify} messages.\n             * @function encode\n             * @memberof pb.NoiseHandshakePayload\n             * @static\n             * @param {pb.INoiseHandshakePayload} message NoiseHandshakePayload message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n\n\n      NoiseHandshakePayload.encode = function encode(message, writer) {\n        if (!writer) {\n          writer = $Writer.create();\n        }\n\n        if (message.identityKey != null && message.hasOwnProperty('identityKey')) {\n          writer.uint32(\n          /* id 1, wireType 2 = */\n          10).bytes(message.identityKey);\n        }\n\n        if (message.identitySig != null && message.hasOwnProperty('identitySig')) {\n          writer.uint32(\n          /* id 2, wireType 2 = */\n          18).bytes(message.identitySig);\n        }\n\n        if (message.data != null && message.hasOwnProperty('data')) {\n          writer.uint32(\n          /* id 3, wireType 2 = */\n          26).bytes(message.data);\n        }\n\n        return writer;\n      };\n      /**\n             * Encodes the specified NoiseHandshakePayload message, length delimited. Does not implicitly {@link pb.NoiseHandshakePayload.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof pb.NoiseHandshakePayload\n             * @static\n             * @param {pb.INoiseHandshakePayload} message NoiseHandshakePayload message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n\n\n      NoiseHandshakePayload.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n      };\n      /**\n             * Decodes a NoiseHandshakePayload message from the specified reader or buffer.\n             * @function decode\n             * @memberof pb.NoiseHandshakePayload\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {pb.NoiseHandshakePayload} NoiseHandshakePayload\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n\n\n      NoiseHandshakePayload.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) {\n          reader = $Reader.create(reader);\n        }\n\n        var end = length === undefined ? reader.len : reader.pos + length;\n        var message = new $root.pb.NoiseHandshakePayload();\n\n        while (reader.pos < end) {\n          var tag = reader.uint32();\n\n          switch (tag >>> 3) {\n            case 1:\n              message.identityKey = reader.bytes();\n              break;\n\n            case 2:\n              message.identitySig = reader.bytes();\n              break;\n\n            case 3:\n              message.data = reader.bytes();\n              break;\n\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n\n        return message;\n      };\n      /**\n             * Decodes a NoiseHandshakePayload message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof pb.NoiseHandshakePayload\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {pb.NoiseHandshakePayload} NoiseHandshakePayload\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n\n\n      NoiseHandshakePayload.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader)) {\n          reader = new $Reader(reader);\n        }\n\n        return this.decode(reader, reader.uint32());\n      };\n      /**\n             * Verifies a NoiseHandshakePayload message.\n             * @function verify\n             * @memberof pb.NoiseHandshakePayload\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n\n\n      NoiseHandshakePayload.verify = function verify(message) {\n        if (typeof message !== 'object' || message === null) {\n          return 'object expected';\n        }\n\n        if (message.identityKey != null && message.hasOwnProperty('identityKey')) {\n          if (!(message.identityKey && typeof message.identityKey.length === 'number' || $util.isString(message.identityKey))) {\n            return 'identityKey: buffer expected';\n          }\n        }\n\n        if (message.identitySig != null && message.hasOwnProperty('identitySig')) {\n          if (!(message.identitySig && typeof message.identitySig.length === 'number' || $util.isString(message.identitySig))) {\n            return 'identitySig: buffer expected';\n          }\n        }\n\n        if (message.data != null && message.hasOwnProperty('data')) {\n          if (!(message.data && typeof message.data.length === 'number' || $util.isString(message.data))) {\n            return 'data: buffer expected';\n          }\n        }\n\n        return null;\n      };\n      /**\n             * Creates a NoiseHandshakePayload message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof pb.NoiseHandshakePayload\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {pb.NoiseHandshakePayload} NoiseHandshakePayload\n             */\n\n\n      NoiseHandshakePayload.fromObject = function fromObject(object) {\n        if (object instanceof $root.pb.NoiseHandshakePayload) {\n          return object;\n        }\n\n        var message = new $root.pb.NoiseHandshakePayload();\n\n        if (object.identityKey != null) {\n          if (typeof object.identityKey === 'string') {\n            $util.base64.decode(object.identityKey, message.identityKey = $util.newBuffer($util.base64.length(object.identityKey)), 0);\n          } else if (object.identityKey.length) {\n            message.identityKey = object.identityKey;\n          }\n        }\n\n        if (object.identitySig != null) {\n          if (typeof object.identitySig === 'string') {\n            $util.base64.decode(object.identitySig, message.identitySig = $util.newBuffer($util.base64.length(object.identitySig)), 0);\n          } else if (object.identitySig.length) {\n            message.identitySig = object.identitySig;\n          }\n        }\n\n        if (object.data != null) {\n          if (typeof object.data === 'string') {\n            $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);\n          } else if (object.data.length) {\n            message.data = object.data;\n          }\n        }\n\n        return message;\n      };\n      /**\n             * Creates a plain object from a NoiseHandshakePayload message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof pb.NoiseHandshakePayload\n             * @static\n             * @param {pb.NoiseHandshakePayload} message NoiseHandshakePayload\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n\n\n      NoiseHandshakePayload.toObject = function toObject(message, options) {\n        if (!options) {\n          options = {};\n        }\n\n        var object = {};\n\n        if (options.defaults) {\n          if (options.bytes === String) {\n            object.identityKey = '';\n          } else {\n            object.identityKey = [];\n\n            if (options.bytes !== Array) {\n              object.identityKey = $util.newBuffer(object.identityKey);\n            }\n          }\n\n          if (options.bytes === String) {\n            object.identitySig = '';\n          } else {\n            object.identitySig = [];\n\n            if (options.bytes !== Array) {\n              object.identitySig = $util.newBuffer(object.identitySig);\n            }\n          }\n\n          if (options.bytes === String) {\n            object.data = '';\n          } else {\n            object.data = [];\n\n            if (options.bytes !== Array) {\n              object.data = $util.newBuffer(object.data);\n            }\n          }\n        }\n\n        if (message.identityKey != null && message.hasOwnProperty('identityKey')) {\n          object.identityKey = options.bytes === String ? $util.base64.encode(message.identityKey, 0, message.identityKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.identityKey) : message.identityKey;\n        }\n\n        if (message.identitySig != null && message.hasOwnProperty('identitySig')) {\n          object.identitySig = options.bytes === String ? $util.base64.encode(message.identitySig, 0, message.identitySig.length) : options.bytes === Array ? Array.prototype.slice.call(message.identitySig) : message.identitySig;\n        }\n\n        if (message.data != null && message.hasOwnProperty('data')) {\n          object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;\n        }\n\n        return object;\n      };\n      /**\n             * Converts this NoiseHandshakePayload to JSON.\n             * @function toJSON\n             * @memberof pb.NoiseHandshakePayload\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n\n\n      NoiseHandshakePayload.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n      };\n\n      return NoiseHandshakePayload;\n    }();\n\n    return pb;\n  }();\n\n  return $root;\n});","map":{"version":3,"sources":["../../../src/proto/payload.js"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/* eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars */\n(function (global, factory) {\n    /* AMD */ if (typeof define === 'function' && define.amd) {\n        define(['protobufjs/minimal'], factory);\n    }\n    /* CommonJS */ else if (typeof require === 'function' && typeof module === 'object' && module && module.exports) {\n        module.exports = factory(require('protobufjs/minimal'));\n    }\n})(this, function ($protobuf) {\n    // Common aliases\n    var $Reader = $protobuf.Reader;\n    var $Writer = $protobuf.Writer;\n    var $util = $protobuf.util;\n    // Exported root namespace\n    var $root = $protobuf.roots.default || ($protobuf.roots.default = {});\n    $root.pb = (function () {\n        /**\n             * Namespace pb.\n             * @exports pb\n             * @namespace\n             */\n        var pb = {};\n        pb.NoiseHandshakePayload = (function () {\n            /**\n                   * Properties of a NoiseHandshakePayload.\n                   * @memberof pb\n                   * @interface INoiseHandshakePayload\n                   * @property {Uint8Array|null} [identityKey] NoiseHandshakePayload identityKey\n                   * @property {Uint8Array|null} [identitySig] NoiseHandshakePayload identitySig\n                   * @property {Uint8Array|null} [data] NoiseHandshakePayload data\n                   */\n            /**\n                   * Constructs a new NoiseHandshakePayload.\n                   * @memberof pb\n                   * @classdesc Represents a NoiseHandshakePayload.\n                   * @implements INoiseHandshakePayload\n                   * @constructor\n                   * @param {pb.INoiseHandshakePayload=} [properties] Properties to set\n                   */\n            function NoiseHandshakePayload(properties) {\n                if (properties) {\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n                        if (properties[keys[i]] != null) {\n                            this[keys[i]] = properties[keys[i]];\n                        }\n                    }\n                }\n            }\n            /**\n                   * NoiseHandshakePayload identityKey.\n                   * @member {Uint8Array} identityKey\n                   * @memberof pb.NoiseHandshakePayload\n                   * @instance\n                   */\n            NoiseHandshakePayload.prototype.identityKey = $util.newBuffer([]);\n            /**\n                   * NoiseHandshakePayload identitySig.\n                   * @member {Uint8Array} identitySig\n                   * @memberof pb.NoiseHandshakePayload\n                   * @instance\n                   */\n            NoiseHandshakePayload.prototype.identitySig = $util.newBuffer([]);\n            /**\n                   * NoiseHandshakePayload data.\n                   * @member {Uint8Array} data\n                   * @memberof pb.NoiseHandshakePayload\n                   * @instance\n                   */\n            NoiseHandshakePayload.prototype.data = $util.newBuffer([]);\n            /**\n                   * Creates a new NoiseHandshakePayload instance using the specified properties.\n                   * @function create\n                   * @memberof pb.NoiseHandshakePayload\n                   * @static\n                   * @param {pb.INoiseHandshakePayload=} [properties] Properties to set\n                   * @returns {pb.NoiseHandshakePayload} NoiseHandshakePayload instance\n                   */\n            NoiseHandshakePayload.create = function create(properties) {\n                return new NoiseHandshakePayload(properties);\n            };\n            /**\n                   * Encodes the specified NoiseHandshakePayload message. Does not implicitly {@link pb.NoiseHandshakePayload.verify|verify} messages.\n                   * @function encode\n                   * @memberof pb.NoiseHandshakePayload\n                   * @static\n                   * @param {pb.INoiseHandshakePayload} message NoiseHandshakePayload message or plain object to encode\n                   * @param {$protobuf.Writer} [writer] Writer to encode to\n                   * @returns {$protobuf.Writer} Writer\n                   */\n            NoiseHandshakePayload.encode = function encode(message, writer) {\n                if (!writer) {\n                    writer = $Writer.create();\n                }\n                if (message.identityKey != null && message.hasOwnProperty('identityKey')) {\n                    writer.uint32(/* id 1, wireType 2 = */ 10).bytes(message.identityKey);\n                }\n                if (message.identitySig != null && message.hasOwnProperty('identitySig')) {\n                    writer.uint32(/* id 2, wireType 2 = */ 18).bytes(message.identitySig);\n                }\n                if (message.data != null && message.hasOwnProperty('data')) {\n                    writer.uint32(/* id 3, wireType 2 = */ 26).bytes(message.data);\n                }\n                return writer;\n            };\n            /**\n                   * Encodes the specified NoiseHandshakePayload message, length delimited. Does not implicitly {@link pb.NoiseHandshakePayload.verify|verify} messages.\n                   * @function encodeDelimited\n                   * @memberof pb.NoiseHandshakePayload\n                   * @static\n                   * @param {pb.INoiseHandshakePayload} message NoiseHandshakePayload message or plain object to encode\n                   * @param {$protobuf.Writer} [writer] Writer to encode to\n                   * @returns {$protobuf.Writer} Writer\n                   */\n            NoiseHandshakePayload.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n            /**\n                   * Decodes a NoiseHandshakePayload message from the specified reader or buffer.\n                   * @function decode\n                   * @memberof pb.NoiseHandshakePayload\n                   * @static\n                   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                   * @param {number} [length] Message length if known beforehand\n                   * @returns {pb.NoiseHandshakePayload} NoiseHandshakePayload\n                   * @throws {Error} If the payload is not a reader or valid buffer\n                   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                   */\n            NoiseHandshakePayload.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader)) {\n                    reader = $Reader.create(reader);\n                }\n                var end = length === undefined ? reader.len : reader.pos + length;\n                var message = new $root.pb.NoiseHandshakePayload();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1:\n                            message.identityKey = reader.bytes();\n                            break;\n                        case 2:\n                            message.identitySig = reader.bytes();\n                            break;\n                        case 3:\n                            message.data = reader.bytes();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return message;\n            };\n            /**\n                   * Decodes a NoiseHandshakePayload message from the specified reader or buffer, length delimited.\n                   * @function decodeDelimited\n                   * @memberof pb.NoiseHandshakePayload\n                   * @static\n                   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                   * @returns {pb.NoiseHandshakePayload} NoiseHandshakePayload\n                   * @throws {Error} If the payload is not a reader or valid buffer\n                   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                   */\n            NoiseHandshakePayload.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader)) {\n                    reader = new $Reader(reader);\n                }\n                return this.decode(reader, reader.uint32());\n            };\n            /**\n                   * Verifies a NoiseHandshakePayload message.\n                   * @function verify\n                   * @memberof pb.NoiseHandshakePayload\n                   * @static\n                   * @param {Object.<string,*>} message Plain object to verify\n                   * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                   */\n            NoiseHandshakePayload.verify = function verify(message) {\n                if (typeof message !== 'object' || message === null) {\n                    return 'object expected';\n                }\n                if (message.identityKey != null && message.hasOwnProperty('identityKey')) {\n                    if (!(message.identityKey && typeof message.identityKey.length === 'number' || $util.isString(message.identityKey))) {\n                        return 'identityKey: buffer expected';\n                    }\n                }\n                if (message.identitySig != null && message.hasOwnProperty('identitySig')) {\n                    if (!(message.identitySig && typeof message.identitySig.length === 'number' || $util.isString(message.identitySig))) {\n                        return 'identitySig: buffer expected';\n                    }\n                }\n                if (message.data != null && message.hasOwnProperty('data')) {\n                    if (!(message.data && typeof message.data.length === 'number' || $util.isString(message.data))) {\n                        return 'data: buffer expected';\n                    }\n                }\n                return null;\n            };\n            /**\n                   * Creates a NoiseHandshakePayload message from a plain object. Also converts values to their respective internal types.\n                   * @function fromObject\n                   * @memberof pb.NoiseHandshakePayload\n                   * @static\n                   * @param {Object.<string,*>} object Plain object\n                   * @returns {pb.NoiseHandshakePayload} NoiseHandshakePayload\n                   */\n            NoiseHandshakePayload.fromObject = function fromObject(object) {\n                if (object instanceof $root.pb.NoiseHandshakePayload) {\n                    return object;\n                }\n                var message = new $root.pb.NoiseHandshakePayload();\n                if (object.identityKey != null) {\n                    if (typeof object.identityKey === 'string') {\n                        $util.base64.decode(object.identityKey, message.identityKey = $util.newBuffer($util.base64.length(object.identityKey)), 0);\n                    }\n                    else if (object.identityKey.length) {\n                        message.identityKey = object.identityKey;\n                    }\n                }\n                if (object.identitySig != null) {\n                    if (typeof object.identitySig === 'string') {\n                        $util.base64.decode(object.identitySig, message.identitySig = $util.newBuffer($util.base64.length(object.identitySig)), 0);\n                    }\n                    else if (object.identitySig.length) {\n                        message.identitySig = object.identitySig;\n                    }\n                }\n                if (object.data != null) {\n                    if (typeof object.data === 'string') {\n                        $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);\n                    }\n                    else if (object.data.length) {\n                        message.data = object.data;\n                    }\n                }\n                return message;\n            };\n            /**\n                   * Creates a plain object from a NoiseHandshakePayload message. Also converts values to other types if specified.\n                   * @function toObject\n                   * @memberof pb.NoiseHandshakePayload\n                   * @static\n                   * @param {pb.NoiseHandshakePayload} message NoiseHandshakePayload\n                   * @param {$protobuf.IConversionOptions} [options] Conversion options\n                   * @returns {Object.<string,*>} Plain object\n                   */\n            NoiseHandshakePayload.toObject = function toObject(message, options) {\n                if (!options) {\n                    options = {};\n                }\n                var object = {};\n                if (options.defaults) {\n                    if (options.bytes === String) {\n                        object.identityKey = '';\n                    }\n                    else {\n                        object.identityKey = [];\n                        if (options.bytes !== Array) {\n                            object.identityKey = $util.newBuffer(object.identityKey);\n                        }\n                    }\n                    if (options.bytes === String) {\n                        object.identitySig = '';\n                    }\n                    else {\n                        object.identitySig = [];\n                        if (options.bytes !== Array) {\n                            object.identitySig = $util.newBuffer(object.identitySig);\n                        }\n                    }\n                    if (options.bytes === String) {\n                        object.data = '';\n                    }\n                    else {\n                        object.data = [];\n                        if (options.bytes !== Array) {\n                            object.data = $util.newBuffer(object.data);\n                        }\n                    }\n                }\n                if (message.identityKey != null && message.hasOwnProperty('identityKey')) {\n                    object.identityKey = options.bytes === String ? $util.base64.encode(message.identityKey, 0, message.identityKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.identityKey) : message.identityKey;\n                }\n                if (message.identitySig != null && message.hasOwnProperty('identitySig')) {\n                    object.identitySig = options.bytes === String ? $util.base64.encode(message.identitySig, 0, message.identitySig.length) : options.bytes === Array ? Array.prototype.slice.call(message.identitySig) : message.identitySig;\n                }\n                if (message.data != null && message.hasOwnProperty('data')) {\n                    object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;\n                }\n                return object;\n            };\n            /**\n                   * Converts this NoiseHandshakePayload to JSON.\n                   * @function toJSON\n                   * @memberof pb.NoiseHandshakePayload\n                   * @instance\n                   * @returns {Object.<string,*>} JSON object\n                   */\n            NoiseHandshakePayload.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n            return NoiseHandshakePayload;\n        })();\n        return pb;\n    })();\n    return $root;\n});\n//# sourceMappingURL=payload.js.map"]},"metadata":{},"sourceType":"script"}