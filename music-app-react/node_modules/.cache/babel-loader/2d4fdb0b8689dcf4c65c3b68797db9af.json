{"ast":null,"code":"'use strict';\n\nconst debug = require('debug');\n\nconst EventEmitter = require('events');\n\nconst errcode = require('err-code');\n\nconst pipe = require('it-pipe');\n\nconst MulticodecTopology = require('../topology/multicodec-topology');\n\nconst {\n  codes\n} = require('./errors');\n/**\n * @type {typeof import('./message')}\n */\n\n\nconst message = require('./message');\n\nconst PeerStreams = require('./peer-streams');\n\nconst utils = require('./utils');\n\nconst {\n  signMessage,\n  verifySignature\n} = require('./message/sign');\n/**\n * @typedef {Object} InMessage\n * @property {string} [from]\n * @property {string} receivedFrom\n * @property {string[]} topicIDs\n * @property {Uint8Array} [seqno]\n * @property {Uint8Array} data\n * @property {Uint8Array} [signature]\n * @property {Uint8Array} [key]\n *\n * @typedef PeerId\n * @type import('peer-id')\n */\n\n/**\n* PubsubBaseProtocol handles the peers and connections logic for pubsub routers\n* and specifies the API that pubsub routers should have.\n*/\n\n\nclass PubsubBaseProtocol extends EventEmitter {\n  /**\n   * @param {Object} props\n   * @param {String} props.debugName log namespace\n   * @param {Array<string>|string} props.multicodecs protocol identificers to connect\n   * @param {Libp2p} props.libp2p\n   * @param {boolean} [props.signMessages = true] if messages should be signed\n   * @param {boolean} [props.strictSigning = true] if message signing should be required\n   * @param {boolean} [props.canRelayMessage = false] if can relay messages not subscribed\n   * @param {boolean} [props.emitSelf = false] if publish should emit to self, if subscribed\n   * @abstract\n   */\n  constructor({\n    debugName,\n    multicodecs,\n    libp2p,\n    signMessages = true,\n    strictSigning = true,\n    canRelayMessage = false,\n    emitSelf = false\n  }) {\n    if (typeof debugName !== 'string') {\n      throw new Error('a debugname `string` is required');\n    }\n\n    if (!multicodecs) {\n      throw new Error('multicodecs are required');\n    }\n\n    if (!libp2p) {\n      throw new Error('libp2p is required');\n    }\n\n    super();\n    this.log = debug(debugName);\n    this.log.err = debug(`${debugName}:error`);\n    /**\n     * @type {Array<string>}\n     */\n\n    this.multicodecs = utils.ensureArray(multicodecs);\n    this._libp2p = libp2p;\n    this.registrar = libp2p.registrar;\n    /**\n     * @type {PeerId}\n     */\n\n    this.peerId = libp2p.peerId;\n    this.started = false;\n    /**\n     * Map of topics to which peers are subscribed to\n     *\n     * @type {Map<string, Set<string>>}\n     */\n\n    this.topics = new Map();\n    /**\n     * List of our subscriptions\n     * @type {Set<string>}\n     */\n\n    this.subscriptions = new Set();\n    /**\n     * Map of peer streams\n     *\n     * @type {Map<string, import('./peer-streams')>}\n     */\n\n    this.peers = new Map(); // Message signing\n\n    this.signMessages = signMessages;\n    /**\n     * If message signing should be required for incoming messages\n     * @type {boolean}\n     */\n\n    this.strictSigning = strictSigning;\n    /**\n     * If router can relay received messages, even if not subscribed\n     * @type {boolean}\n     */\n\n    this.canRelayMessage = canRelayMessage;\n    /**\n     * if publish should emit to self, if subscribed\n     * @type {boolean}\n     */\n\n    this.emitSelf = emitSelf;\n    /**\n     * Topic validator function\n     * @typedef {function(string, InMessage): Promise<void>} validator\n     */\n\n    /**\n     * Topic validator map\n     *\n     * Keyed by topic\n     * Topic validators are functions with the following input:\n     * @type {Map<string, validator>}\n     */\n\n    this.topicValidators = new Map();\n    this._registrarId = undefined;\n    this._onIncomingStream = this._onIncomingStream.bind(this);\n    this._onPeerConnected = this._onPeerConnected.bind(this);\n    this._onPeerDisconnected = this._onPeerDisconnected.bind(this);\n  } // LIFECYCLE METHODS\n\n  /**\n   * Register the pubsub protocol onto the libp2p node.\n   * @returns {void}\n   */\n\n\n  start() {\n    if (this.started) {\n      return;\n    }\n\n    this.log('starting'); // Incoming streams\n    // Called after a peer dials us\n\n    this.registrar.handle(this.multicodecs, this._onIncomingStream); // register protocol with topology\n    // Topology callbacks called on connection manager changes\n\n    const topology = new MulticodecTopology({\n      multicodecs: this.multicodecs,\n      handlers: {\n        onConnect: this._onPeerConnected,\n        onDisconnect: this._onPeerDisconnected\n      }\n    });\n    this._registrarId = this.registrar.register(topology);\n    this.log('started');\n    this.started = true;\n  }\n  /**\n   * Unregister the pubsub protocol and the streams with other peers will be closed.\n   * @returns {void}\n   */\n\n\n  stop() {\n    if (!this.started) {\n      return;\n    } // unregister protocol and handlers\n\n\n    this.registrar.unregister(this._registrarId);\n    this.log('stopping');\n    this.peers.forEach(peerStreams => peerStreams.close());\n    this.peers = new Map();\n    this.subscriptions = new Set();\n    this.started = false;\n    this.log('stopped');\n  }\n  /**\n   * On an inbound stream opened.\n   * @private\n   * @param {Object} props\n   * @param {string} props.protocol\n   * @param {DuplexIterableStream} props.stream\n   * @param {Connection} props.connection connection\n   */\n\n\n  _onIncomingStream({\n    protocol,\n    stream,\n    connection\n  }) {\n    const peerId = connection.remotePeer;\n    const idB58Str = peerId.toB58String();\n\n    const peer = this._addPeer(peerId, protocol);\n\n    peer.attachInboundStream(stream);\n\n    this._processMessages(idB58Str, peer.inboundStream, peer);\n  }\n  /**\n   * Registrar notifies an established connection with pubsub protocol.\n   * @private\n   * @param {PeerId} peerId remote peer-id\n   * @param {Connection} conn connection to the peer\n   */\n\n\n  async _onPeerConnected(peerId, conn) {\n    const idB58Str = peerId.toB58String();\n    this.log('connected', idB58Str);\n\n    try {\n      const {\n        stream,\n        protocol\n      } = await conn.newStream(this.multicodecs);\n\n      const peer = this._addPeer(peerId, protocol);\n\n      await peer.attachOutboundStream(stream);\n    } catch (err) {\n      this.log.err(err);\n    } // Immediately send my own subscriptions to the newly established conn\n\n\n    this._sendSubscriptions(idB58Str, Array.from(this.subscriptions), true);\n  }\n  /**\n   * Registrar notifies a closing connection with pubsub protocol.\n   * @private\n   * @param {PeerId} peerId peerId\n   * @param {Error} err error for connection end\n   */\n\n\n  _onPeerDisconnected(peerId, err) {\n    const idB58Str = peerId.toB58String();\n    this.log('connection ended', idB58Str, err ? err.message : '');\n\n    this._removePeer(peerId);\n  }\n  /**\n   * Notifies the router that a peer has been connected\n   * @private\n   * @param {PeerId} peerId\n   * @param {string} protocol\n   * @returns {PeerStreams}\n   */\n\n\n  _addPeer(peerId, protocol) {\n    const id = peerId.toB58String();\n    const existing = this.peers.get(id); // If peer streams already exists, do nothing\n\n    if (existing) {\n      return existing;\n    } // else create a new peer streams\n\n\n    this.log('new peer', id);\n    const peerStreams = new PeerStreams({\n      id: peerId,\n      protocol\n    });\n    this.peers.set(id, peerStreams);\n    peerStreams.once('close', () => this._removePeer(peerId));\n    return peerStreams;\n  }\n  /**\n   * Notifies the router that a peer has been disconnected.\n   * @private\n   * @param {PeerId} peerId\n   * @returns {PeerStreams | undefined}\n   */\n\n\n  _removePeer(peerId) {\n    if (!peerId) return;\n    const id = peerId.toB58String();\n    const peerStreams = this.peers.get(id);\n    if (!peerStreams) return; // close peer streams\n\n    peerStreams.removeAllListeners();\n    peerStreams.close(); // delete peer streams\n\n    this.log('delete peer', id);\n    this.peers.delete(id); // remove peer from topics map\n\n    for (const peers of this.topics.values()) {\n      peers.delete(id);\n    }\n\n    return peerStreams;\n  } // MESSAGE METHODS\n\n  /**\n   * Responsible for processing each RPC message received by other peers.\n   * @param {string} idB58Str peer id string in base58\n   * @param {DuplexIterableStream} stream inbound stream\n   * @param {PeerStreams} peerStreams PubSub peer\n   * @returns {Promise<void>}\n   */\n\n\n  async _processMessages(idB58Str, stream, peerStreams) {\n    try {\n      await pipe(stream, async source => {\n        for await (const data of source) {\n          const rpcBytes = data instanceof Uint8Array ? data : data.slice();\n\n          const rpcMsg = this._decodeRpc(rpcBytes);\n\n          this._processRpc(idB58Str, peerStreams, rpcMsg);\n        }\n      });\n    } catch (err) {\n      this._onPeerDisconnected(peerStreams.id, err);\n    }\n  }\n  /**\n   * Handles an rpc request from a peer\n   * @param {String} idB58Str\n   * @param {PeerStreams} peerStreams\n   * @param {RPC} rpc\n   * @returns {boolean}\n   */\n\n\n  _processRpc(idB58Str, peerStreams, rpc) {\n    this.log('rpc from', idB58Str);\n    const subs = rpc.subscriptions;\n    const msgs = rpc.msgs;\n\n    if (subs.length) {\n      // update peer subscriptions\n      subs.forEach(subOpt => this._processRpcSubOpt(idB58Str, subOpt));\n      this.emit('pubsub:subscription-change', peerStreams.id, subs);\n    }\n\n    if (!this._acceptFrom(idB58Str)) {\n      this.log('received message from unacceptable peer %s', idB58Str);\n      return false;\n    }\n\n    if (msgs.length) {\n      msgs.forEach(message => {\n        if (!(this.canRelayMessage || message.topicIDs.some(topic => this.subscriptions.has(topic)))) {\n          this.log('received message we didn\\'t subscribe to. Dropping.');\n          return;\n        }\n\n        const msg = utils.normalizeInRpcMessage(message, idB58Str);\n\n        this._processRpcMessage(msg);\n      });\n    }\n\n    return true;\n  }\n  /**\n   * Handles a subscription change from a peer\n   * @param {string} id\n   * @param {RPC.SubOpt} subOpt\n   */\n\n\n  _processRpcSubOpt(id, subOpt) {\n    const t = subOpt.topicID;\n    let topicSet = this.topics.get(t);\n\n    if (!topicSet) {\n      topicSet = new Set();\n      this.topics.set(t, topicSet);\n    }\n\n    if (subOpt.subscribe) {\n      // subscribe peer to new topic\n      topicSet.add(id);\n    } else {\n      // unsubscribe from existing topic\n      topicSet.delete(id);\n    }\n  }\n  /**\n   * Handles an message from a peer\n   * @param {InMessage} msg\n   * @returns {Promise<void>}\n   */\n\n\n  async _processRpcMessage(msg) {\n    if (this.peerId.toB58String() === msg.from && !this.emitSelf) {\n      return;\n    } // Ensure the message is valid before processing it\n\n\n    try {\n      await this.validate(msg);\n    } catch (err) {\n      this.log('Message is invalid, dropping it. %O', err);\n      return;\n    } // Emit to self\n\n\n    this._emitMessage(msg);\n\n    this._publish(utils.normalizeOutRpcMessage(msg));\n  }\n  /**\n   * Emit a message from a peer\n   * @param {InMessage} message\n   */\n\n\n  _emitMessage(message) {\n    message.topicIDs.forEach(topic => {\n      if (this.subscriptions.has(topic)) {\n        this.emit(topic, message);\n      }\n    });\n  }\n  /**\n   * The default msgID implementation\n   * Child class can override this.\n   * @param {RPC.Message} msg the message object\n   * @returns {string} message id as string\n   */\n\n\n  getMsgId(msg) {\n    return utils.msgId(msg.from, msg.seqno);\n  }\n  /**\n   * Whether to accept a message from a peer\n   * Override to create a graylist\n   * @override\n   * @param {string} id\n   * @returns {boolean}\n   */\n\n\n  _acceptFrom(id) {\n    return true;\n  }\n  /**\n   * Decode Uint8Array into an RPC object.\n   * This can be override to use a custom router protobuf.\n   * @param {Uint8Array} bytes\n   * @returns {RPC}\n   */\n\n\n  _decodeRpc(bytes) {\n    return message.rpc.RPC.decode(bytes);\n  }\n  /**\n   * Encode RPC object into a Uint8Array.\n   * This can be override to use a custom router protobuf.\n   * @param {RPC} rpc\n   * @returns {Uint8Array}\n   */\n\n\n  _encodeRpc(rpc) {\n    return message.rpc.RPC.encode(rpc);\n  }\n  /**\n   * Send an rpc object to a peer\n   * @param {string} id peer id\n   * @param {RPC} rpc\n   * @returns {void}\n   */\n\n\n  _sendRpc(id, rpc) {\n    const peerStreams = this.peers.get(id);\n\n    if (!peerStreams || !peerStreams.isWritable) {\n      const msg = `Cannot send RPC to ${id} as there is no open stream to it available`;\n      this.log.err(msg);\n      return;\n    }\n\n    peerStreams.write(this._encodeRpc(rpc));\n  }\n  /**\n   * Send subscroptions to a peer\n   * @param {string} id peer id\n   * @param {string[]} topics\n   * @param {boolean} subscribe set to false for unsubscriptions\n   * @returns {void}\n   */\n\n\n  _sendSubscriptions(id, topics, subscribe) {\n    return this._sendRpc(id, {\n      subscriptions: topics.map(t => ({\n        topicID: t,\n        subscribe: subscribe\n      }))\n    });\n  }\n  /**\n   * Validates the given message. The signature will be checked for authenticity.\n   * Throws an error on invalid messages\n   * @param {InMessage} message\n   * @returns {Promise<void>}\n   */\n\n\n  async validate(message) {\n    // eslint-disable-line require-await\n    // If strict signing is on and we have no signature, abort\n    if (this.strictSigning && !message.signature) {\n      throw errcode(new Error('Signing required and no signature was present'), codes.ERR_MISSING_SIGNATURE);\n    } // Check the message signature if present\n\n\n    if (message.signature && !(await verifySignature(message))) {\n      throw errcode(new Error('Invalid message signature'), codes.ERR_INVALID_SIGNATURE);\n    }\n\n    for (const topic of message.topicIDs) {\n      const validatorFn = this.topicValidators.get(topic);\n\n      if (!validatorFn) {\n        continue;\n      }\n\n      await validatorFn(topic, message);\n    }\n  }\n  /**\n   * Normalizes the message and signs it, if signing is enabled.\n   * Should be used by the routers to create the message to send.\n   * @private\n   * @param {Message} message\n   * @returns {Promise<Message>}\n   */\n\n\n  _buildMessage(message) {\n    const msg = utils.normalizeOutRpcMessage(message);\n\n    if (this.signMessages) {\n      return signMessage(this.peerId, msg);\n    } else {\n      return message;\n    }\n  } // API METHODS\n\n  /**\n   * Get a list of the peer-ids that are subscribed to one topic.\n   * @param {string} topic\n   * @returns {Array<string>}\n   */\n\n\n  getSubscribers(topic) {\n    if (!this.started) {\n      throw errcode(new Error('not started yet'), 'ERR_NOT_STARTED_YET');\n    }\n\n    if (!topic || typeof topic !== 'string') {\n      throw errcode(new Error('a string topic must be provided'), 'ERR_NOT_VALID_TOPIC');\n    }\n\n    const peersInTopic = this.topics.get(topic);\n\n    if (!peersInTopic) {\n      return [];\n    }\n\n    return Array.from(peersInTopic);\n  }\n  /**\n   * Publishes messages to all subscribed peers\n   * @override\n   * @param {string} topic\n   * @param {Buffer} message\n   * @returns {Promise<void>}\n   */\n\n\n  async publish(topic, message) {\n    if (!this.started) {\n      throw new Error('Pubsub has not started');\n    }\n\n    this.log('publish', topic, message);\n    const from = this.peerId.toB58String();\n    let msgObject = {\n      receivedFrom: from,\n      from: from,\n      data: message,\n      seqno: utils.randomSeqno(),\n      topicIDs: [topic]\n    }; // ensure that any operations performed on the message will include the signature\n\n    const outMsg = await this._buildMessage(msgObject);\n    msgObject = utils.normalizeInRpcMessage(outMsg); // Emit to self if I'm interested and emitSelf enabled\n\n    this.emitSelf && this._emitMessage(msgObject); // send to all the other peers\n\n    await this._publish(msgObject);\n  }\n  /**\n   * Overriding the implementation of publish should handle the appropriate algorithms for the publish/subscriber implementation.\n   * For example, a Floodsub implementation might simply publish each message to each topic for every peer\n   * @abstract\n   * @param {InMessage} message\n   * @returns {Promise<void>}\n   *\n   */\n\n\n  _publish(message) {\n    throw errcode(new Error('publish must be implemented by the subclass'), 'ERR_NOT_IMPLEMENTED');\n  }\n  /**\n   * Subscribes to a given topic.\n   * @abstract\n   * @param {string} topic\n   * @returns {void}\n   */\n\n\n  subscribe(topic) {\n    if (!this.started) {\n      throw new Error('Pubsub has not started');\n    }\n\n    if (!this.subscriptions.has(topic)) {\n      this.subscriptions.add(topic);\n      this.peers.forEach((_, id) => this._sendSubscriptions(id, [topic], true));\n    }\n  }\n  /**\n   * Unsubscribe from the given topic.\n   * @override\n   * @param {string} topic\n   * @returns {void}\n   */\n\n\n  unsubscribe(topic) {\n    if (!this.started) {\n      throw new Error('Pubsub is not started');\n    }\n\n    if (this.subscriptions.has(topic) && this.listenerCount(topic) === 0) {\n      this.subscriptions.delete(topic);\n      this.peers.forEach((_, id) => this._sendSubscriptions(id, [topic], false));\n    }\n  }\n  /**\n   * Get the list of topics which the peer is subscribed to.\n   * @override\n   * @returns {Array<String>}\n   */\n\n\n  getTopics() {\n    if (!this.started) {\n      throw new Error('Pubsub is not started');\n    }\n\n    return Array.from(this.subscriptions);\n  }\n\n}\n\nmodule.exports = PubsubBaseProtocol;\nmodule.exports.message = message;\nmodule.exports.utils = utils;","map":{"version":3,"sources":["/home/user/orbit-playground/music-app/node_modules/libp2p-gossipsub/node_modules/libp2p-interfaces/src/pubsub/index.js"],"names":["debug","require","EventEmitter","errcode","pipe","MulticodecTopology","codes","message","PeerStreams","utils","signMessage","verifySignature","PubsubBaseProtocol","constructor","debugName","multicodecs","libp2p","signMessages","strictSigning","canRelayMessage","emitSelf","Error","log","err","ensureArray","_libp2p","registrar","peerId","started","topics","Map","subscriptions","Set","peers","topicValidators","_registrarId","undefined","_onIncomingStream","bind","_onPeerConnected","_onPeerDisconnected","start","handle","topology","handlers","onConnect","onDisconnect","register","stop","unregister","forEach","peerStreams","close","protocol","stream","connection","remotePeer","idB58Str","toB58String","peer","_addPeer","attachInboundStream","_processMessages","inboundStream","conn","newStream","attachOutboundStream","_sendSubscriptions","Array","from","_removePeer","id","existing","get","set","once","removeAllListeners","delete","values","source","data","rpcBytes","Uint8Array","slice","rpcMsg","_decodeRpc","_processRpc","rpc","subs","msgs","length","subOpt","_processRpcSubOpt","emit","_acceptFrom","topicIDs","some","topic","has","msg","normalizeInRpcMessage","_processRpcMessage","t","topicID","topicSet","subscribe","add","validate","_emitMessage","_publish","normalizeOutRpcMessage","getMsgId","msgId","seqno","bytes","RPC","decode","_encodeRpc","encode","_sendRpc","isWritable","write","map","signature","ERR_MISSING_SIGNATURE","ERR_INVALID_SIGNATURE","validatorFn","_buildMessage","getSubscribers","peersInTopic","publish","msgObject","receivedFrom","randomSeqno","outMsg","_","unsubscribe","listenerCount","getTopics","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst debug = require('debug')\nconst EventEmitter = require('events')\nconst errcode = require('err-code')\n\nconst pipe = require('it-pipe')\n\nconst MulticodecTopology = require('../topology/multicodec-topology')\nconst { codes } = require('./errors')\n/**\n * @type {typeof import('./message')}\n */\nconst message = require('./message')\nconst PeerStreams = require('./peer-streams')\nconst utils = require('./utils')\n\nconst {\n  signMessage,\n  verifySignature\n} = require('./message/sign')\n\n/**\n * @typedef {Object} InMessage\n * @property {string} [from]\n * @property {string} receivedFrom\n * @property {string[]} topicIDs\n * @property {Uint8Array} [seqno]\n * @property {Uint8Array} data\n * @property {Uint8Array} [signature]\n * @property {Uint8Array} [key]\n *\n * @typedef PeerId\n * @type import('peer-id')\n */\n\n/**\n* PubsubBaseProtocol handles the peers and connections logic for pubsub routers\n* and specifies the API that pubsub routers should have.\n*/\nclass PubsubBaseProtocol extends EventEmitter {\n  /**\n   * @param {Object} props\n   * @param {String} props.debugName log namespace\n   * @param {Array<string>|string} props.multicodecs protocol identificers to connect\n   * @param {Libp2p} props.libp2p\n   * @param {boolean} [props.signMessages = true] if messages should be signed\n   * @param {boolean} [props.strictSigning = true] if message signing should be required\n   * @param {boolean} [props.canRelayMessage = false] if can relay messages not subscribed\n   * @param {boolean} [props.emitSelf = false] if publish should emit to self, if subscribed\n   * @abstract\n   */\n  constructor ({\n    debugName,\n    multicodecs,\n    libp2p,\n    signMessages = true,\n    strictSigning = true,\n    canRelayMessage = false,\n    emitSelf = false\n  }) {\n    if (typeof debugName !== 'string') {\n      throw new Error('a debugname `string` is required')\n    }\n\n    if (!multicodecs) {\n      throw new Error('multicodecs are required')\n    }\n\n    if (!libp2p) {\n      throw new Error('libp2p is required')\n    }\n\n    super()\n\n    this.log = debug(debugName)\n    this.log.err = debug(`${debugName}:error`)\n\n    /**\n     * @type {Array<string>}\n     */\n    this.multicodecs = utils.ensureArray(multicodecs)\n    this._libp2p = libp2p\n    this.registrar = libp2p.registrar\n    /**\n     * @type {PeerId}\n     */\n    this.peerId = libp2p.peerId\n\n    this.started = false\n\n    /**\n     * Map of topics to which peers are subscribed to\n     *\n     * @type {Map<string, Set<string>>}\n     */\n    this.topics = new Map()\n\n    /**\n     * List of our subscriptions\n     * @type {Set<string>}\n     */\n    this.subscriptions = new Set()\n\n    /**\n     * Map of peer streams\n     *\n     * @type {Map<string, import('./peer-streams')>}\n     */\n    this.peers = new Map()\n\n    // Message signing\n    this.signMessages = signMessages\n\n    /**\n     * If message signing should be required for incoming messages\n     * @type {boolean}\n     */\n    this.strictSigning = strictSigning\n\n    /**\n     * If router can relay received messages, even if not subscribed\n     * @type {boolean}\n     */\n    this.canRelayMessage = canRelayMessage\n\n    /**\n     * if publish should emit to self, if subscribed\n     * @type {boolean}\n     */\n    this.emitSelf = emitSelf\n\n    /**\n     * Topic validator function\n     * @typedef {function(string, InMessage): Promise<void>} validator\n     */\n    /**\n     * Topic validator map\n     *\n     * Keyed by topic\n     * Topic validators are functions with the following input:\n     * @type {Map<string, validator>}\n     */\n    this.topicValidators = new Map()\n\n    this._registrarId = undefined\n    this._onIncomingStream = this._onIncomingStream.bind(this)\n    this._onPeerConnected = this._onPeerConnected.bind(this)\n    this._onPeerDisconnected = this._onPeerDisconnected.bind(this)\n  }\n\n  // LIFECYCLE METHODS\n\n  /**\n   * Register the pubsub protocol onto the libp2p node.\n   * @returns {void}\n   */\n  start () {\n    if (this.started) {\n      return\n    }\n    this.log('starting')\n\n    // Incoming streams\n    // Called after a peer dials us\n    this.registrar.handle(this.multicodecs, this._onIncomingStream)\n\n    // register protocol with topology\n    // Topology callbacks called on connection manager changes\n    const topology = new MulticodecTopology({\n      multicodecs: this.multicodecs,\n      handlers: {\n        onConnect: this._onPeerConnected,\n        onDisconnect: this._onPeerDisconnected\n      }\n    })\n    this._registrarId = this.registrar.register(topology)\n\n    this.log('started')\n    this.started = true\n  }\n\n  /**\n   * Unregister the pubsub protocol and the streams with other peers will be closed.\n   * @returns {void}\n   */\n  stop () {\n    if (!this.started) {\n      return\n    }\n\n    // unregister protocol and handlers\n    this.registrar.unregister(this._registrarId)\n\n    this.log('stopping')\n    this.peers.forEach((peerStreams) => peerStreams.close())\n\n    this.peers = new Map()\n    this.subscriptions = new Set()\n    this.started = false\n    this.log('stopped')\n  }\n\n  /**\n   * On an inbound stream opened.\n   * @private\n   * @param {Object} props\n   * @param {string} props.protocol\n   * @param {DuplexIterableStream} props.stream\n   * @param {Connection} props.connection connection\n   */\n  _onIncomingStream ({ protocol, stream, connection }) {\n    const peerId = connection.remotePeer\n    const idB58Str = peerId.toB58String()\n    const peer = this._addPeer(peerId, protocol)\n    peer.attachInboundStream(stream)\n\n    this._processMessages(idB58Str, peer.inboundStream, peer)\n  }\n\n  /**\n   * Registrar notifies an established connection with pubsub protocol.\n   * @private\n   * @param {PeerId} peerId remote peer-id\n   * @param {Connection} conn connection to the peer\n   */\n  async _onPeerConnected (peerId, conn) {\n    const idB58Str = peerId.toB58String()\n    this.log('connected', idB58Str)\n\n    try {\n      const { stream, protocol } = await conn.newStream(this.multicodecs)\n      const peer = this._addPeer(peerId, protocol)\n      await peer.attachOutboundStream(stream)\n    } catch (err) {\n      this.log.err(err)\n    }\n\n    // Immediately send my own subscriptions to the newly established conn\n    this._sendSubscriptions(idB58Str, Array.from(this.subscriptions), true)\n  }\n\n  /**\n   * Registrar notifies a closing connection with pubsub protocol.\n   * @private\n   * @param {PeerId} peerId peerId\n   * @param {Error} err error for connection end\n   */\n  _onPeerDisconnected (peerId, err) {\n    const idB58Str = peerId.toB58String()\n\n    this.log('connection ended', idB58Str, err ? err.message : '')\n    this._removePeer(peerId)\n  }\n\n  /**\n   * Notifies the router that a peer has been connected\n   * @private\n   * @param {PeerId} peerId\n   * @param {string} protocol\n   * @returns {PeerStreams}\n   */\n  _addPeer (peerId, protocol) {\n    const id = peerId.toB58String()\n    const existing = this.peers.get(id)\n\n    // If peer streams already exists, do nothing\n    if (existing) {\n      return existing\n    }\n\n    // else create a new peer streams\n    this.log('new peer', id)\n\n    const peerStreams = new PeerStreams({\n      id: peerId,\n      protocol\n    })\n\n    this.peers.set(id, peerStreams)\n    peerStreams.once('close', () => this._removePeer(peerId))\n\n    return peerStreams\n  }\n\n  /**\n   * Notifies the router that a peer has been disconnected.\n   * @private\n   * @param {PeerId} peerId\n   * @returns {PeerStreams | undefined}\n   */\n  _removePeer (peerId) {\n    if (!peerId) return\n    const id = peerId.toB58String()\n    const peerStreams = this.peers.get(id)\n    if (!peerStreams) return\n\n    // close peer streams\n    peerStreams.removeAllListeners()\n    peerStreams.close()\n\n    // delete peer streams\n    this.log('delete peer', id)\n    this.peers.delete(id)\n\n    // remove peer from topics map\n    for (const peers of this.topics.values()) {\n      peers.delete(id)\n    }\n\n    return peerStreams\n  }\n\n  // MESSAGE METHODS\n\n  /**\n   * Responsible for processing each RPC message received by other peers.\n   * @param {string} idB58Str peer id string in base58\n   * @param {DuplexIterableStream} stream inbound stream\n   * @param {PeerStreams} peerStreams PubSub peer\n   * @returns {Promise<void>}\n   */\n  async _processMessages (idB58Str, stream, peerStreams) {\n    try {\n      await pipe(\n        stream,\n        async (source) => {\n          for await (const data of source) {\n            const rpcBytes = data instanceof Uint8Array ? data : data.slice()\n            const rpcMsg = this._decodeRpc(rpcBytes)\n\n            this._processRpc(idB58Str, peerStreams, rpcMsg)\n          }\n        }\n      )\n    } catch (err) {\n      this._onPeerDisconnected(peerStreams.id, err)\n    }\n  }\n\n  /**\n   * Handles an rpc request from a peer\n   * @param {String} idB58Str\n   * @param {PeerStreams} peerStreams\n   * @param {RPC} rpc\n   * @returns {boolean}\n   */\n  _processRpc (idB58Str, peerStreams, rpc) {\n    this.log('rpc from', idB58Str)\n    const subs = rpc.subscriptions\n    const msgs = rpc.msgs\n\n    if (subs.length) {\n      // update peer subscriptions\n      subs.forEach((subOpt) => this._processRpcSubOpt(idB58Str, subOpt))\n      this.emit('pubsub:subscription-change', peerStreams.id, subs)\n    }\n\n    if (!this._acceptFrom(idB58Str)) {\n      this.log('received message from unacceptable peer %s', idB58Str)\n      return false\n    }\n\n    if (msgs.length) {\n      msgs.forEach(message => {\n        if (!(this.canRelayMessage || message.topicIDs.some((topic) => this.subscriptions.has(topic)))) {\n          this.log('received message we didn\\'t subscribe to. Dropping.')\n          return\n        }\n        const msg = utils.normalizeInRpcMessage(message, idB58Str)\n        this._processRpcMessage(msg)\n      })\n    }\n    return true\n  }\n\n  /**\n   * Handles a subscription change from a peer\n   * @param {string} id\n   * @param {RPC.SubOpt} subOpt\n   */\n  _processRpcSubOpt (id, subOpt) {\n    const t = subOpt.topicID\n\n    let topicSet = this.topics.get(t)\n    if (!topicSet) {\n      topicSet = new Set()\n      this.topics.set(t, topicSet)\n    }\n\n    if (subOpt.subscribe) {\n      // subscribe peer to new topic\n      topicSet.add(id)\n    } else {\n      // unsubscribe from existing topic\n      topicSet.delete(id)\n    }\n  }\n\n  /**\n   * Handles an message from a peer\n   * @param {InMessage} msg\n   * @returns {Promise<void>}\n   */\n  async _processRpcMessage (msg) {\n    if (this.peerId.toB58String() === msg.from && !this.emitSelf) {\n      return\n    }\n\n    // Ensure the message is valid before processing it\n    try {\n      await this.validate(msg)\n    } catch (err) {\n      this.log('Message is invalid, dropping it. %O', err)\n      return\n    }\n\n    // Emit to self\n    this._emitMessage(msg)\n\n    this._publish(utils.normalizeOutRpcMessage(msg))\n  }\n\n  /**\n   * Emit a message from a peer\n   * @param {InMessage} message\n   */\n  _emitMessage (message) {\n    message.topicIDs.forEach((topic) => {\n      if (this.subscriptions.has(topic)) {\n        this.emit(topic, message)\n      }\n    })\n  }\n\n  /**\n   * The default msgID implementation\n   * Child class can override this.\n   * @param {RPC.Message} msg the message object\n   * @returns {string} message id as string\n   */\n  getMsgId (msg) {\n    return utils.msgId(msg.from, msg.seqno)\n  }\n\n  /**\n   * Whether to accept a message from a peer\n   * Override to create a graylist\n   * @override\n   * @param {string} id\n   * @returns {boolean}\n   */\n  _acceptFrom (id) {\n    return true\n  }\n\n  /**\n   * Decode Uint8Array into an RPC object.\n   * This can be override to use a custom router protobuf.\n   * @param {Uint8Array} bytes\n   * @returns {RPC}\n   */\n  _decodeRpc (bytes) {\n    return message.rpc.RPC.decode(bytes)\n  }\n\n  /**\n   * Encode RPC object into a Uint8Array.\n   * This can be override to use a custom router protobuf.\n   * @param {RPC} rpc\n   * @returns {Uint8Array}\n   */\n  _encodeRpc (rpc) {\n    return message.rpc.RPC.encode(rpc)\n  }\n\n  /**\n   * Send an rpc object to a peer\n   * @param {string} id peer id\n   * @param {RPC} rpc\n   * @returns {void}\n   */\n  _sendRpc (id, rpc) {\n    const peerStreams = this.peers.get(id)\n    if (!peerStreams || !peerStreams.isWritable) {\n      const msg = `Cannot send RPC to ${id} as there is no open stream to it available`\n\n      this.log.err(msg)\n      return\n    }\n    peerStreams.write(this._encodeRpc(rpc))\n  }\n\n  /**\n   * Send subscroptions to a peer\n   * @param {string} id peer id\n   * @param {string[]} topics\n   * @param {boolean} subscribe set to false for unsubscriptions\n   * @returns {void}\n   */\n  _sendSubscriptions (id, topics, subscribe) {\n    return this._sendRpc(id, {\n      subscriptions: topics.map(t => ({ topicID: t, subscribe: subscribe }))\n    })\n  }\n\n  /**\n   * Validates the given message. The signature will be checked for authenticity.\n   * Throws an error on invalid messages\n   * @param {InMessage} message\n   * @returns {Promise<void>}\n   */\n  async validate (message) { // eslint-disable-line require-await\n    // If strict signing is on and we have no signature, abort\n    if (this.strictSigning && !message.signature) {\n      throw errcode(new Error('Signing required and no signature was present'), codes.ERR_MISSING_SIGNATURE)\n    }\n\n    // Check the message signature if present\n    if (message.signature && !(await verifySignature(message))) {\n      throw errcode(new Error('Invalid message signature'), codes.ERR_INVALID_SIGNATURE)\n    }\n\n    for (const topic of message.topicIDs) {\n      const validatorFn = this.topicValidators.get(topic)\n      if (!validatorFn) {\n        continue\n      }\n      await validatorFn(topic, message)\n    }\n  }\n\n  /**\n   * Normalizes the message and signs it, if signing is enabled.\n   * Should be used by the routers to create the message to send.\n   * @private\n   * @param {Message} message\n   * @returns {Promise<Message>}\n   */\n  _buildMessage (message) {\n    const msg = utils.normalizeOutRpcMessage(message)\n    if (this.signMessages) {\n      return signMessage(this.peerId, msg)\n    } else {\n      return message\n    }\n  }\n\n  // API METHODS\n\n  /**\n   * Get a list of the peer-ids that are subscribed to one topic.\n   * @param {string} topic\n   * @returns {Array<string>}\n   */\n  getSubscribers (topic) {\n    if (!this.started) {\n      throw errcode(new Error('not started yet'), 'ERR_NOT_STARTED_YET')\n    }\n\n    if (!topic || typeof topic !== 'string') {\n      throw errcode(new Error('a string topic must be provided'), 'ERR_NOT_VALID_TOPIC')\n    }\n\n    const peersInTopic = this.topics.get(topic)\n    if (!peersInTopic) {\n      return []\n    }\n    return Array.from(peersInTopic)\n  }\n\n  /**\n   * Publishes messages to all subscribed peers\n   * @override\n   * @param {string} topic\n   * @param {Buffer} message\n   * @returns {Promise<void>}\n   */\n  async publish (topic, message) {\n    if (!this.started) {\n      throw new Error('Pubsub has not started')\n    }\n\n    this.log('publish', topic, message)\n\n    const from = this.peerId.toB58String()\n    let msgObject = {\n      receivedFrom: from,\n      from: from,\n      data: message,\n      seqno: utils.randomSeqno(),\n      topicIDs: [topic]\n    }\n\n    // ensure that any operations performed on the message will include the signature\n    const outMsg = await this._buildMessage(msgObject)\n    msgObject = utils.normalizeInRpcMessage(outMsg)\n\n    // Emit to self if I'm interested and emitSelf enabled\n    this.emitSelf && this._emitMessage(msgObject)\n\n    // send to all the other peers\n    await this._publish(msgObject)\n  }\n\n  /**\n   * Overriding the implementation of publish should handle the appropriate algorithms for the publish/subscriber implementation.\n   * For example, a Floodsub implementation might simply publish each message to each topic for every peer\n   * @abstract\n   * @param {InMessage} message\n   * @returns {Promise<void>}\n   *\n   */\n  _publish (message) {\n    throw errcode(new Error('publish must be implemented by the subclass'), 'ERR_NOT_IMPLEMENTED')\n  }\n\n  /**\n   * Subscribes to a given topic.\n   * @abstract\n   * @param {string} topic\n   * @returns {void}\n   */\n  subscribe (topic) {\n    if (!this.started) {\n      throw new Error('Pubsub has not started')\n    }\n\n    if (!this.subscriptions.has(topic)) {\n      this.subscriptions.add(topic)\n      this.peers.forEach((_, id) => this._sendSubscriptions(id, [topic], true))\n    }\n  }\n\n  /**\n   * Unsubscribe from the given topic.\n   * @override\n   * @param {string} topic\n   * @returns {void}\n   */\n  unsubscribe (topic) {\n    if (!this.started) {\n      throw new Error('Pubsub is not started')\n    }\n\n    if (this.subscriptions.has(topic) && this.listenerCount(topic) === 0) {\n      this.subscriptions.delete(topic)\n      this.peers.forEach((_, id) => this._sendSubscriptions(id, [topic], false))\n    }\n  }\n\n  /**\n   * Get the list of topics which the peer is subscribed to.\n   * @override\n   * @returns {Array<String>}\n   */\n  getTopics () {\n    if (!this.started) {\n      throw new Error('Pubsub is not started')\n    }\n\n    return Array.from(this.subscriptions)\n  }\n}\n\nmodule.exports = PubsubBaseProtocol\nmodule.exports.message = message\nmodule.exports.utils = utils\n"]},"metadata":{},"sourceType":"script"}