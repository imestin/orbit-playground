{"ast":null,"code":"'use strict';\n\nconst CID = require('cids');\n\nconst Key = require('interface-datastore').Key;\n\nconst mb = require('multibase');\n\nconst log = require('debug')('ipfs:repo:migrator:migration-8');\n\nconst uint8ArrayToString = require('uint8arrays/to-string');\n\nconst {\n  createStore\n} = require('../../src/utils');\n\nconst length = require('it-length');\n\nfunction keyToMultihash(key) {\n  const buf = mb.decode(`b${key.toString().slice(1)}`); // Extract multihash from CID\n\n  let multihash = new CID(buf).multihash; // Encode and slice off multibase codec\n\n  multihash = mb.encode('base32', multihash).slice(1); // Should be uppercase for interop with go\n\n  multihash = uint8ArrayToString(multihash).toUpperCase();\n  return new Key(`/${multihash}`, false);\n}\n\nfunction keyToCid(key) {\n  const buf = mb.decode(`b${key.toString().slice(1)}`); // CID to Key\n\n  const multihash = mb.encode('base32', new CID(1, 'raw', buf).bytes).slice(1);\n  return new Key(`/${uint8ArrayToString(multihash)}`.toUpperCase(), false);\n}\n\nasync function process(repoPath, repoOptions, onProgress, keyFunction) {\n  const blockstore = await createStore(repoPath, 'blocks', repoOptions);\n  await blockstore.open();\n  let blockCount;\n\n  if (onProgress) {\n    blockCount = await length(blockstore.query({\n      keysOnly: true,\n      filters: [({\n        key\n      }) => {\n        const newKey = keyFunction(key);\n        return newKey.toString() !== key.toString();\n      }]\n    }));\n  }\n\n  try {\n    let counter = 0;\n\n    for await (const block of blockstore.query({})) {\n      const newKey = keyFunction(block.key); // If the Key is base32 CIDv0 then there's nothing to do\n\n      if (newKey.toString() !== block.key.toString()) {\n        counter += 1;\n        log(`Migrating Block from ${block.key} to ${newKey}`);\n        await blockstore.delete(block.key);\n        await blockstore.put(newKey, block.value);\n\n        if (onProgress) {\n          onProgress(counter / blockCount * 100, `Migrated Block from ${block.key} to ${newKey}`);\n        }\n      }\n    }\n  } finally {\n    await blockstore.close();\n  }\n}\n\nmodule.exports = {\n  version: 8,\n  description: 'Transforms key names into base32 encoding and converts Block store to use bare multihashes encoded as base32',\n  migrate: (repoPath, repoOptions, onProgress) => {\n    return process(repoPath, repoOptions, onProgress, keyToMultihash);\n  },\n  revert: (repoPath, repoOptions, onProgress) => {\n    return process(repoPath, repoOptions, onProgress, keyToCid);\n  }\n};","map":{"version":3,"sources":["/home/user/orbit-playground/music-app/node_modules/ipfs-repo-migrations/migrations/migration-8/index.js"],"names":["CID","require","Key","mb","log","uint8ArrayToString","createStore","length","keyToMultihash","key","buf","decode","toString","slice","multihash","encode","toUpperCase","keyToCid","bytes","process","repoPath","repoOptions","onProgress","keyFunction","blockstore","open","blockCount","query","keysOnly","filters","newKey","counter","block","delete","put","value","close","module","exports","version","description","migrate","revert"],"mappings":"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","sourcesContent":["'use strict'\n\nconst CID = require('cids')\nconst Key = require('interface-datastore').Key\nconst mb = require('multibase')\nconst log = require('debug')('ipfs:repo:migrator:migration-8')\nconst uint8ArrayToString = require('uint8arrays/to-string')\nconst { createStore } = require('../../src/utils')\nconst length = require('it-length')\n\nfunction keyToMultihash (key) {\n  const buf = mb.decode(`b${key.toString().slice(1)}`)\n\n  // Extract multihash from CID\n  let multihash = new CID(buf).multihash\n\n  // Encode and slice off multibase codec\n  multihash = mb.encode('base32', multihash).slice(1)\n\n  // Should be uppercase for interop with go\n  multihash = uint8ArrayToString(multihash).toUpperCase()\n\n  return new Key(`/${multihash}`, false)\n}\n\nfunction keyToCid (key) {\n  const buf = mb.decode(`b${key.toString().slice(1)}`)\n\n  // CID to Key\n  const multihash = mb.encode('base32', new CID(1, 'raw', buf).bytes).slice(1)\n\n  return new Key(`/${uint8ArrayToString(multihash)}`.toUpperCase(), false)\n}\n\nasync function process (repoPath, repoOptions, onProgress, keyFunction) {\n  const blockstore = await createStore(repoPath, 'blocks', repoOptions)\n  await blockstore.open()\n\n  let blockCount\n\n  if (onProgress) {\n    blockCount = await length(blockstore.query({\n      keysOnly: true,\n      filters: [({ key }) => {\n        const newKey = keyFunction(key)\n\n        return newKey.toString() !== key.toString()\n      }]\n    }))\n  }\n\n  try {\n    let counter = 0\n\n    for await (const block of blockstore.query({})) {\n      const newKey = keyFunction(block.key)\n\n      // If the Key is base32 CIDv0 then there's nothing to do\n      if(newKey.toString() !== block.key.toString()) {\n        counter += 1\n        log(`Migrating Block from ${block.key} to ${newKey}`)\n        await blockstore.delete(block.key)\n        await blockstore.put(newKey, block.value)\n\n        if (onProgress) {\n          onProgress((counter / blockCount) * 100, `Migrated Block from ${block.key} to ${newKey}`)\n        }\n      }\n    }\n  } finally {\n    await blockstore.close()\n  }\n}\n\nmodule.exports = {\n  version: 8,\n  description: 'Transforms key names into base32 encoding and converts Block store to use bare multihashes encoded as base32',\n  migrate: (repoPath, repoOptions, onProgress) => {\n    return process(repoPath, repoOptions, onProgress, keyToMultihash)\n  },\n  revert: (repoPath, repoOptions, onProgress) => {\n    return process(repoPath, repoOptions, onProgress, keyToCid)\n  }\n}\n"]},"metadata":{},"sourceType":"script"}