{"ast":null,"code":"/* eslint max-nested-callbacks: [\"error\", 8] */\n'use strict';\n\nconst {\n  resolvePath,\n  withTimeoutOption\n} = require('../../utils');\n\nconst PinManager = require('./pin-manager');\n\nconst {\n  PinTypes\n} = PinManager;\n\nconst normaliseInput = require('ipfs-core-utils/src/pins/normalise-input');\n\nmodule.exports = ({\n  pinManager,\n  gcLock,\n  dag\n}) => {\n  return withTimeoutOption(async function* addAll(source, options) {\n    options = options || {};\n\n    const pinAdd = async function* () {\n      for await (const {\n        path,\n        recursive,\n        metadata\n      } of normaliseInput(source)) {\n        const cid = await resolvePath(dag, path); // verify that each hash can be pinned\n\n        const {\n          reason\n        } = await pinManager.isPinnedWithType(cid, [PinTypes.recursive, PinTypes.direct]);\n\n        if (reason === 'recursive' && !recursive) {\n          // only disallow trying to override recursive pins\n          throw new Error(`${cid} already pinned recursively`);\n        }\n\n        if (recursive) {\n          await pinManager.pinRecursively(cid, {\n            metadata\n          });\n        } else {\n          await pinManager.pinDirectly(cid, {\n            metadata\n          });\n        }\n\n        yield cid;\n      }\n    }; // When adding a file, we take a lock that gets released after pinning\n    // is complete, so don't take a second lock here\n\n\n    const lock = Boolean(options.lock);\n\n    if (!lock) {\n      yield* pinAdd();\n      return;\n    }\n\n    const release = await gcLock.readLock();\n\n    try {\n      yield* pinAdd();\n    } finally {\n      release();\n    }\n  });\n};","map":{"version":3,"sources":["/home/user/orbit-playground/music-app/node_modules/ipfs/src/core/components/pin/add-all.js"],"names":["resolvePath","withTimeoutOption","require","PinManager","PinTypes","normaliseInput","module","exports","pinManager","gcLock","dag","addAll","source","options","pinAdd","path","recursive","metadata","cid","reason","isPinnedWithType","direct","Error","pinRecursively","pinDirectly","lock","Boolean","release","readLock"],"mappings":"AAAA;AACA;;AAEA,MAAM;AAAEA,EAAAA,WAAF;AAAeC,EAAAA;AAAf,IAAqCC,OAAO,CAAC,aAAD,CAAlD;;AACA,MAAMC,UAAU,GAAGD,OAAO,CAAC,eAAD,CAA1B;;AACA,MAAM;AAAEE,EAAAA;AAAF,IAAeD,UAArB;;AACA,MAAME,cAAc,GAAGH,OAAO,CAAC,0CAAD,CAA9B;;AAEAI,MAAM,CAACC,OAAP,GAAiB,CAAC;AAAEC,EAAAA,UAAF;AAAcC,EAAAA,MAAd;AAAsBC,EAAAA;AAAtB,CAAD,KAAiC;AAChD,SAAOT,iBAAiB,CAAC,gBAAiBU,MAAjB,CAAyBC,MAAzB,EAAiCC,OAAjC,EAA0C;AACjEA,IAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;;AAEA,UAAMC,MAAM,GAAG,mBAAoB;AACjC,iBAAW,MAAM;AAAEC,QAAAA,IAAF;AAAQC,QAAAA,SAAR;AAAmBC,QAAAA;AAAnB,OAAjB,IAAkDZ,cAAc,CAACO,MAAD,CAAhE,EAA0E;AACxE,cAAMM,GAAG,GAAG,MAAMlB,WAAW,CAACU,GAAD,EAAMK,IAAN,CAA7B,CADwE,CAGxE;;AACA,cAAM;AAAEI,UAAAA;AAAF,YAAa,MAAMX,UAAU,CAACY,gBAAX,CAA4BF,GAA5B,EAAiC,CAACd,QAAQ,CAACY,SAAV,EAAqBZ,QAAQ,CAACiB,MAA9B,CAAjC,CAAzB;;AAEA,YAAIF,MAAM,KAAK,WAAX,IAA0B,CAACH,SAA/B,EAA0C;AACxC;AACA,gBAAM,IAAIM,KAAJ,CAAW,GAAEJ,GAAI,6BAAjB,CAAN;AACD;;AAED,YAAIF,SAAJ,EAAe;AACb,gBAAMR,UAAU,CAACe,cAAX,CAA0BL,GAA1B,EAA+B;AAAED,YAAAA;AAAF,WAA/B,CAAN;AACD,SAFD,MAEO;AACL,gBAAMT,UAAU,CAACgB,WAAX,CAAuBN,GAAvB,EAA4B;AAAED,YAAAA;AAAF,WAA5B,CAAN;AACD;;AAED,cAAMC,GAAN;AACD;AACF,KApBD,CAHiE,CAyBjE;AACA;;;AACA,UAAMO,IAAI,GAAGC,OAAO,CAACb,OAAO,CAACY,IAAT,CAApB;;AAEA,QAAI,CAACA,IAAL,EAAW;AACT,aAAQX,MAAM,EAAd;AACA;AACD;;AAED,UAAMa,OAAO,GAAG,MAAMlB,MAAM,CAACmB,QAAP,EAAtB;;AAEA,QAAI;AACF,aAAQd,MAAM,EAAd;AACD,KAFD,SAEU;AACRa,MAAAA,OAAO;AACR;AACF,GAzCuB,CAAxB;AA0CD,CA3CD","sourcesContent":["/* eslint max-nested-callbacks: [\"error\", 8] */\n'use strict'\n\nconst { resolvePath, withTimeoutOption } = require('../../utils')\nconst PinManager = require('./pin-manager')\nconst { PinTypes } = PinManager\nconst normaliseInput = require('ipfs-core-utils/src/pins/normalise-input')\n\nmodule.exports = ({ pinManager, gcLock, dag }) => {\n  return withTimeoutOption(async function * addAll (source, options) {\n    options = options || {}\n\n    const pinAdd = async function * () {\n      for await (const { path, recursive, metadata } of normaliseInput(source)) {\n        const cid = await resolvePath(dag, path)\n\n        // verify that each hash can be pinned\n        const { reason } = await pinManager.isPinnedWithType(cid, [PinTypes.recursive, PinTypes.direct])\n\n        if (reason === 'recursive' && !recursive) {\n          // only disallow trying to override recursive pins\n          throw new Error(`${cid} already pinned recursively`)\n        }\n\n        if (recursive) {\n          await pinManager.pinRecursively(cid, { metadata })\n        } else {\n          await pinManager.pinDirectly(cid, { metadata })\n        }\n\n        yield cid\n      }\n    }\n\n    // When adding a file, we take a lock that gets released after pinning\n    // is complete, so don't take a second lock here\n    const lock = Boolean(options.lock)\n\n    if (!lock) {\n      yield * pinAdd()\n      return\n    }\n\n    const release = await gcLock.readLock()\n\n    try {\n      yield * pinAdd()\n    } finally {\n      release()\n    }\n  })\n}\n"]},"metadata":{},"sourceType":"script"}