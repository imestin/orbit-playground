{"ast":null,"code":"'use strict';\n\nconst ipns = require('ipns');\n\nconst PeerId = require('peer-id');\n\nconst errcode = require('err-code');\n\nconst debug = require('debug');\n\nconst log = debug('ipfs:ipns:resolver');\nlog.error = debug('ipfs:ipns:resolver:error');\n\nconst uint8ArrayToString = require('uint8arrays/to-string');\n\nconst {\n  Errors\n} = require('interface-datastore');\n\nconst ERR_NOT_FOUND = Errors.notFoundError().code;\nconst defaultMaximumRecursiveDepth = 32;\n\nclass IpnsResolver {\n  constructor(routing) {\n    this._routing = routing;\n  }\n\n  async resolve(name, options) {\n    options = options || {};\n\n    if (typeof name !== 'string') {\n      throw errcode(new Error('invalid name'), 'ERR_INVALID_NAME');\n    }\n\n    options = options || {};\n    const recursive = options.recursive && options.recursive.toString() === 'true';\n    const nameSegments = name.split('/');\n\n    if (nameSegments.length !== 3 || nameSegments[0] !== '') {\n      throw errcode(new Error('invalid name'), 'ERR_INVALID_NAME');\n    }\n\n    const key = nameSegments[2]; // Define a maximum depth if recursive option enabled\n\n    let depth;\n\n    if (recursive) {\n      depth = defaultMaximumRecursiveDepth;\n    }\n\n    const res = await this.resolver(key, depth);\n    log(`${name} was locally resolved correctly`);\n    return res;\n  } // Recursive resolver according to the specified depth\n\n\n  async resolver(name, depth) {\n    // Exceeded recursive maximum depth\n    if (depth === 0) {\n      const errMsg = `could not resolve name (recursion limit of ${defaultMaximumRecursiveDepth} exceeded)`;\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_RESOLVE_RECURSION_LIMIT');\n    }\n\n    const res = await this._resolveName(name);\n    const nameSegments = res.split('/'); // If obtained a ipfs cid or recursive option is disabled\n\n    if (nameSegments[1] === 'ipfs' || !depth) {\n      return res;\n    } // continue recursively until depth equals 0\n\n\n    return this.resolver(nameSegments[2], depth - 1);\n  } // resolve ipns entries from the provided routing\n\n\n  async _resolveName(name) {\n    const peerId = PeerId.createFromCID(name);\n    const {\n      routingKey\n    } = ipns.getIdKeys(peerId.toBytes());\n    let record;\n\n    try {\n      record = await this._routing.get(routingKey.uint8Array());\n    } catch (err) {\n      log.error('could not get record from routing', err);\n\n      if (err.code === ERR_NOT_FOUND) {\n        throw errcode(new Error(`record requested for ${name} was not found in the network`), 'ERR_NO_RECORD_FOUND');\n      }\n\n      throw errcode(new Error(`unexpected error getting the ipns record ${peerId.toString()}`), 'ERR_UNEXPECTED_ERROR_GETTING_RECORD');\n    } // IPNS entry\n\n\n    let ipnsEntry;\n\n    try {\n      ipnsEntry = ipns.unmarshal(record);\n    } catch (err) {\n      log.error('could not unmarshal record', err);\n      throw errcode(new Error('found ipns record that we couldn\\'t convert to a value'), 'ERR_INVALID_RECORD_RECEIVED');\n    } // We should have the public key by now (inline, or in the entry)\n\n\n    return this._validateRecord(peerId, ipnsEntry);\n  } // validate a resolved record\n\n\n  async _validateRecord(peerId, ipnsEntry) {\n    const pubKey = await ipns.extractPublicKey(peerId, ipnsEntry); // IPNS entry validation\n\n    await ipns.validate(pubKey, ipnsEntry);\n    return uint8ArrayToString(ipnsEntry.value);\n  }\n\n}\n\nexports = module.exports = IpnsResolver;","map":{"version":3,"sources":["/home/user/orbit-playground/music-app/node_modules/ipfs/src/core/ipns/resolver.js"],"names":["ipns","require","PeerId","errcode","debug","log","error","uint8ArrayToString","Errors","ERR_NOT_FOUND","notFoundError","code","defaultMaximumRecursiveDepth","IpnsResolver","constructor","routing","_routing","resolve","name","options","Error","recursive","toString","nameSegments","split","length","key","depth","res","resolver","errMsg","_resolveName","peerId","createFromCID","routingKey","getIdKeys","toBytes","record","get","uint8Array","err","ipnsEntry","unmarshal","_validateRecord","pubKey","extractPublicKey","validate","value","exports","module"],"mappings":"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","sourcesContent":["'use strict'\n\nconst ipns = require('ipns')\nconst PeerId = require('peer-id')\nconst errcode = require('err-code')\nconst debug = require('debug')\nconst log = debug('ipfs:ipns:resolver')\nlog.error = debug('ipfs:ipns:resolver:error')\nconst uint8ArrayToString = require('uint8arrays/to-string')\n\nconst { Errors } = require('interface-datastore')\nconst ERR_NOT_FOUND = Errors.notFoundError().code\n\nconst defaultMaximumRecursiveDepth = 32\n\nclass IpnsResolver {\n  constructor (routing) {\n    this._routing = routing\n  }\n\n  async resolve (name, options) {\n    options = options || {}\n\n    if (typeof name !== 'string') {\n      throw errcode(new Error('invalid name'), 'ERR_INVALID_NAME')\n    }\n\n    options = options || {}\n    const recursive = options.recursive && options.recursive.toString() === 'true'\n\n    const nameSegments = name.split('/')\n\n    if (nameSegments.length !== 3 || nameSegments[0] !== '') {\n      throw errcode(new Error('invalid name'), 'ERR_INVALID_NAME')\n    }\n\n    const key = nameSegments[2]\n\n    // Define a maximum depth if recursive option enabled\n    let depth\n\n    if (recursive) {\n      depth = defaultMaximumRecursiveDepth\n    }\n\n    const res = await this.resolver(key, depth)\n\n    log(`${name} was locally resolved correctly`)\n    return res\n  }\n\n  // Recursive resolver according to the specified depth\n  async resolver (name, depth) {\n    // Exceeded recursive maximum depth\n    if (depth === 0) {\n      const errMsg = `could not resolve name (recursion limit of ${defaultMaximumRecursiveDepth} exceeded)`\n      log.error(errMsg)\n\n      throw errcode(new Error(errMsg), 'ERR_RESOLVE_RECURSION_LIMIT')\n    }\n\n    const res = await this._resolveName(name)\n    const nameSegments = res.split('/')\n\n    // If obtained a ipfs cid or recursive option is disabled\n    if (nameSegments[1] === 'ipfs' || !depth) {\n      return res\n    }\n\n    // continue recursively until depth equals 0\n    return this.resolver(nameSegments[2], depth - 1)\n  }\n\n  // resolve ipns entries from the provided routing\n  async _resolveName (name) {\n    const peerId = PeerId.createFromCID(name)\n    const { routingKey } = ipns.getIdKeys(peerId.toBytes())\n    let record\n\n    try {\n      record = await this._routing.get(routingKey.uint8Array())\n    } catch (err) {\n      log.error('could not get record from routing', err)\n\n      if (err.code === ERR_NOT_FOUND) {\n        throw errcode(new Error(`record requested for ${name} was not found in the network`), 'ERR_NO_RECORD_FOUND')\n      }\n\n      throw errcode(new Error(`unexpected error getting the ipns record ${peerId.toString()}`), 'ERR_UNEXPECTED_ERROR_GETTING_RECORD')\n    }\n\n    // IPNS entry\n    let ipnsEntry\n    try {\n      ipnsEntry = ipns.unmarshal(record)\n    } catch (err) {\n      log.error('could not unmarshal record', err)\n\n      throw errcode(new Error('found ipns record that we couldn\\'t convert to a value'), 'ERR_INVALID_RECORD_RECEIVED')\n    }\n\n    // We should have the public key by now (inline, or in the entry)\n    return this._validateRecord(peerId, ipnsEntry)\n  }\n\n  // validate a resolved record\n  async _validateRecord (peerId, ipnsEntry) {\n    const pubKey = await ipns.extractPublicKey(peerId, ipnsEntry)\n\n    // IPNS entry validation\n    await ipns.validate(pubKey, ipnsEntry)\n\n    return uint8ArrayToString(ipnsEntry.value)\n  }\n}\n\nexports = module.exports = IpnsResolver\n"]},"metadata":{},"sourceType":"script"}