{"ast":null,"code":"'use strict';\n\nconst debug = require('debug');\n\nconst log = debug('libp2p:identify');\nlog.error = debug('libp2p:identify:error');\n\nconst errCode = require('err-code');\n\nconst pb = require('it-protocol-buffers');\n\nconst lp = require('it-length-prefixed');\n\nconst pipe = require('it-pipe');\n\nconst {\n  collect,\n  take,\n  consume\n} = require('streaming-iterables');\n\nconst uint8ArrayFromString = require('uint8arrays/from-string');\n\nconst PeerId = require('peer-id');\n\nconst multiaddr = require('multiaddr');\n\nconst {\n  toBuffer\n} = require('it-buffer');\n\nconst Message = require('./message');\n\nconst Envelope = require('../record/envelope');\n\nconst PeerRecord = require('../record/peer-record');\n\nconst {\n  MULTICODEC_IDENTIFY,\n  MULTICODEC_IDENTIFY_PUSH,\n  AGENT_VERSION,\n  PROTOCOL_VERSION\n} = require('./consts');\n\nconst {\n  codes\n} = require('../errors');\n\nclass IdentifyService {\n  /**\n   * Takes the `addr` and converts it to a Multiaddr if possible\n   * @param {Uint8Array|String} addr\n   * @returns {Multiaddr|null}\n   */\n  static getCleanMultiaddr(addr) {\n    if (addr && addr.length > 0) {\n      try {\n        return multiaddr(addr);\n      } catch (_) {\n        return null;\n      }\n    }\n\n    return null;\n  }\n  /**\n   * @constructor\n   * @param {object} options\n   * @param {Libp2p} options.libp2p\n   * @param {Map<string, handler>} options.protocols A reference to the protocols we support\n   */\n\n\n  constructor({\n    libp2p,\n    protocols\n  }) {\n    /**\n     * @property {PeerStore}\n     */\n    this.peerStore = libp2p.peerStore;\n    /**\n     * @property {ConnectionManager}\n     */\n\n    this.connectionManager = libp2p.connectionManager;\n    this.connectionManager.on('peer:connect', connection => {\n      const peerId = connection.remotePeer;\n      this.identify(connection, peerId).catch(log.error);\n    });\n    /**\n     * @property {PeerId}\n     */\n\n    this.peerId = libp2p.peerId;\n    /**\n     * @property {AddressManager}\n     */\n\n    this._libp2p = libp2p;\n    this._protocols = protocols;\n    this.handleMessage = this.handleMessage.bind(this);\n  }\n  /**\n   * Send an Identify Push update to the list of connections\n   * @param {Array<Connection>} connections\n   * @returns {Promise<void>}\n   */\n\n\n  async push(connections) {\n    const signedPeerRecord = await this._getSelfPeerRecord();\n\n    const listenAddrs = this._libp2p.multiaddrs.map(ma => ma.bytes);\n\n    const protocols = Array.from(this._protocols.keys());\n    const pushes = connections.map(async connection => {\n      try {\n        const {\n          stream\n        } = await connection.newStream(MULTICODEC_IDENTIFY_PUSH);\n        await pipe([{\n          listenAddrs,\n          signedPeerRecord,\n          protocols\n        }], pb.encode(Message), stream, consume);\n      } catch (err) {\n        // Just log errors\n        log.error('could not push identify update to peer', err);\n      }\n    });\n    return Promise.all(pushes);\n  }\n  /**\n   * Calls `push` for all peers in the `peerStore` that are connected\n   * @param {PeerStore} peerStore\n   */\n\n\n  pushToPeerStore(peerStore) {\n    const connections = [];\n    let connection;\n\n    for (const peer of peerStore.peers.values()) {\n      if (peer.protocols.includes(MULTICODEC_IDENTIFY_PUSH) && (connection = this.connectionManager.get(peer.id))) {\n        connections.push(connection);\n      }\n    }\n\n    this.push(connections);\n  }\n  /**\n   * Requests the `Identify` message from peer associated with the given `connection`.\n   * If the identified peer does not match the `PeerId` associated with the connection,\n   * an error will be thrown.\n   *\n   * @async\n   * @param {Connection} connection\n   * @returns {Promise<void>}\n   */\n\n\n  async identify(connection) {\n    const {\n      stream\n    } = await connection.newStream(MULTICODEC_IDENTIFY);\n    const [data] = await pipe([], stream, lp.decode(), take(1), toBuffer, collect);\n\n    if (!data) {\n      throw errCode(new Error('No data could be retrieved'), codes.ERR_CONNECTION_ENDED);\n    }\n\n    let message;\n\n    try {\n      message = Message.decode(data);\n    } catch (err) {\n      throw errCode(err, codes.ERR_INVALID_MESSAGE);\n    }\n\n    let {\n      publicKey,\n      listenAddrs,\n      protocols,\n      observedAddr,\n      signedPeerRecord\n    } = message;\n    const id = await PeerId.createFromPubKey(publicKey);\n\n    if (connection.remotePeer.toB58String() !== id.toB58String()) {\n      throw errCode(new Error('identified peer does not match the expected peer'), codes.ERR_INVALID_PEER);\n    } // Get the observedAddr if there is one\n\n\n    observedAddr = IdentifyService.getCleanMultiaddr(observedAddr);\n\n    try {\n      const envelope = await Envelope.openAndCertify(signedPeerRecord, PeerRecord.DOMAIN);\n\n      if (this.peerStore.addressBook.consumePeerRecord(envelope)) {\n        this.peerStore.protoBook.set(id, protocols);\n        return;\n      }\n    } catch (err) {\n      log('received invalid envelope, discard it and fallback to listenAddrs is available', err);\n    } // LEGACY: Update peers data in PeerStore\n\n\n    try {\n      this.peerStore.addressBook.set(id, listenAddrs.map(addr => multiaddr(addr)));\n    } catch (err) {\n      log.error('received invalid addrs', err);\n    }\n\n    this.peerStore.protoBook.set(id, protocols);\n    this.peerStore.metadataBook.set(id, 'AgentVersion', uint8ArrayFromString(message.agentVersion)); // TODO: Track our observed address so that we can score it\n\n    log('received observed address of %s', observedAddr);\n  }\n  /**\n   * A handler to register with Libp2p to process identify messages.\n   *\n   * @param {object} options\n   * @param {String} options.protocol\n   * @param {*} options.stream\n   * @param {Connection} options.connection\n   * @returns {Promise<void>}\n   */\n\n\n  handleMessage({\n    connection,\n    stream,\n    protocol\n  }) {\n    switch (protocol) {\n      case MULTICODEC_IDENTIFY:\n        return this._handleIdentify({\n          connection,\n          stream\n        });\n\n      case MULTICODEC_IDENTIFY_PUSH:\n        return this._handlePush({\n          connection,\n          stream\n        });\n\n      default:\n        log.error('cannot handle unknown protocol %s', protocol);\n    }\n  }\n  /**\n   * Sends the `Identify` response with the Signed Peer Record\n   * to the requesting peer over the given `connection`\n   * @private\n   * @param {object} options\n   * @param {*} options.stream\n   * @param {Connection} options.connection\n   */\n\n\n  async _handleIdentify({\n    connection,\n    stream\n  }) {\n    let publicKey = new Uint8Array(0);\n\n    if (this.peerId.pubKey) {\n      publicKey = this.peerId.pubKey.bytes;\n    }\n\n    const signedPeerRecord = await this._getSelfPeerRecord();\n    const message = Message.encode({\n      protocolVersion: PROTOCOL_VERSION,\n      agentVersion: AGENT_VERSION,\n      publicKey,\n      listenAddrs: this._libp2p.multiaddrs.map(ma => ma.bytes),\n      signedPeerRecord,\n      observedAddr: connection.remoteAddr.bytes,\n      protocols: Array.from(this._protocols.keys())\n    });\n\n    try {\n      await pipe([message], lp.encode(), stream, consume);\n    } catch (err) {\n      log.error('could not respond to identify request', err);\n    }\n  }\n  /**\n   * Reads the Identify Push message from the given `connection`\n   * @private\n   * @param {object} options\n   * @param {*} options.stream\n   * @param {Connection} options.connection\n   */\n\n\n  async _handlePush({\n    connection,\n    stream\n  }) {\n    let message;\n\n    try {\n      const [data] = await pipe([], stream, lp.decode(), take(1), toBuffer, collect);\n      message = Message.decode(data);\n    } catch (err) {\n      return log.error('received invalid message', err);\n    }\n\n    const id = connection.remotePeer;\n\n    try {\n      const envelope = await Envelope.openAndCertify(message.signedPeerRecord, PeerRecord.DOMAIN);\n\n      if (this.peerStore.addressBook.consumePeerRecord(envelope)) {\n        this.peerStore.protoBook.set(id, message.protocols);\n        return;\n      }\n    } catch (err) {\n      log('received invalid envelope, discard it and fallback to listenAddrs is available', err);\n    } // LEGACY: Update peers data in PeerStore\n\n\n    try {\n      this.peerStore.addressBook.set(id, message.listenAddrs.map(addr => multiaddr(addr)));\n    } catch (err) {\n      log.error('received invalid addrs', err);\n    } // Update the protocols\n\n\n    this.peerStore.protoBook.set(id, message.protocols);\n  }\n  /**\n   * Get self signed peer record raw envelope.\n   * @return {Uint8Array}\n   */\n\n\n  async _getSelfPeerRecord() {\n    const selfSignedPeerRecord = this.peerStore.addressBook.getRawEnvelope(this.peerId); // TODO: support invalidation when dynamic multiaddrs are supported\n\n    if (selfSignedPeerRecord) {\n      return selfSignedPeerRecord;\n    }\n\n    try {\n      const peerRecord = new PeerRecord({\n        peerId: this.peerId,\n        multiaddrs: this._libp2p.multiaddrs\n      });\n      const envelope = await Envelope.seal(peerRecord, this.peerId);\n      this.peerStore.addressBook.consumePeerRecord(envelope);\n      return this.peerStore.addressBook.getRawEnvelope(this.peerId);\n    } catch (err) {\n      log.error('failed to get self peer record');\n    }\n\n    return null;\n  }\n\n}\n\nmodule.exports.IdentifyService = IdentifyService;\n/**\n * The protocols the IdentifyService supports\n * @property multicodecs\n */\n\nmodule.exports.multicodecs = {\n  IDENTIFY: MULTICODEC_IDENTIFY,\n  IDENTIFY_PUSH: MULTICODEC_IDENTIFY_PUSH\n};\nmodule.exports.Message = Message;","map":{"version":3,"sources":["/home/user/orbit-playground/music-app/node_modules/libp2p/src/identify/index.js"],"names":["debug","require","log","error","errCode","pb","lp","pipe","collect","take","consume","uint8ArrayFromString","PeerId","multiaddr","toBuffer","Message","Envelope","PeerRecord","MULTICODEC_IDENTIFY","MULTICODEC_IDENTIFY_PUSH","AGENT_VERSION","PROTOCOL_VERSION","codes","IdentifyService","getCleanMultiaddr","addr","length","_","constructor","libp2p","protocols","peerStore","connectionManager","on","connection","peerId","remotePeer","identify","catch","_libp2p","_protocols","handleMessage","bind","push","connections","signedPeerRecord","_getSelfPeerRecord","listenAddrs","multiaddrs","map","ma","bytes","Array","from","keys","pushes","stream","newStream","encode","err","Promise","all","pushToPeerStore","peer","peers","values","includes","get","id","data","decode","Error","ERR_CONNECTION_ENDED","message","ERR_INVALID_MESSAGE","publicKey","observedAddr","createFromPubKey","toB58String","ERR_INVALID_PEER","envelope","openAndCertify","DOMAIN","addressBook","consumePeerRecord","protoBook","set","metadataBook","agentVersion","protocol","_handleIdentify","_handlePush","Uint8Array","pubKey","protocolVersion","remoteAddr","selfSignedPeerRecord","getRawEnvelope","peerRecord","seal","module","exports","multicodecs","IDENTIFY","IDENTIFY_PUSH"],"mappings":"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","sourcesContent":["'use strict'\n\nconst debug = require('debug')\nconst log = debug('libp2p:identify')\nlog.error = debug('libp2p:identify:error')\n\nconst errCode = require('err-code')\nconst pb = require('it-protocol-buffers')\nconst lp = require('it-length-prefixed')\nconst pipe = require('it-pipe')\nconst { collect, take, consume } = require('streaming-iterables')\nconst uint8ArrayFromString = require('uint8arrays/from-string')\n\nconst PeerId = require('peer-id')\nconst multiaddr = require('multiaddr')\nconst { toBuffer } = require('it-buffer')\n\nconst Message = require('./message')\n\nconst Envelope = require('../record/envelope')\nconst PeerRecord = require('../record/peer-record')\n\nconst {\n  MULTICODEC_IDENTIFY,\n  MULTICODEC_IDENTIFY_PUSH,\n  AGENT_VERSION,\n  PROTOCOL_VERSION\n} = require('./consts')\n\nconst { codes } = require('../errors')\n\nclass IdentifyService {\n  /**\n   * Takes the `addr` and converts it to a Multiaddr if possible\n   * @param {Uint8Array|String} addr\n   * @returns {Multiaddr|null}\n   */\n  static getCleanMultiaddr (addr) {\n    if (addr && addr.length > 0) {\n      try {\n        return multiaddr(addr)\n      } catch (_) {\n        return null\n      }\n    }\n    return null\n  }\n\n  /**\n   * @constructor\n   * @param {object} options\n   * @param {Libp2p} options.libp2p\n   * @param {Map<string, handler>} options.protocols A reference to the protocols we support\n   */\n  constructor ({ libp2p, protocols }) {\n    /**\n     * @property {PeerStore}\n     */\n    this.peerStore = libp2p.peerStore\n\n    /**\n     * @property {ConnectionManager}\n     */\n    this.connectionManager = libp2p.connectionManager\n\n    this.connectionManager.on('peer:connect', (connection) => {\n      const peerId = connection.remotePeer\n\n      this.identify(connection, peerId).catch(log.error)\n    })\n\n    /**\n     * @property {PeerId}\n     */\n    this.peerId = libp2p.peerId\n\n    /**\n     * @property {AddressManager}\n     */\n    this._libp2p = libp2p\n\n    this._protocols = protocols\n\n    this.handleMessage = this.handleMessage.bind(this)\n  }\n\n  /**\n   * Send an Identify Push update to the list of connections\n   * @param {Array<Connection>} connections\n   * @returns {Promise<void>}\n   */\n  async push (connections) {\n    const signedPeerRecord = await this._getSelfPeerRecord()\n    const listenAddrs = this._libp2p.multiaddrs.map((ma) => ma.bytes)\n    const protocols = Array.from(this._protocols.keys())\n\n    const pushes = connections.map(async connection => {\n      try {\n        const { stream } = await connection.newStream(MULTICODEC_IDENTIFY_PUSH)\n\n        await pipe(\n          [{\n            listenAddrs,\n            signedPeerRecord,\n            protocols\n          }],\n          pb.encode(Message),\n          stream,\n          consume\n        )\n      } catch (err) {\n        // Just log errors\n        log.error('could not push identify update to peer', err)\n      }\n    })\n\n    return Promise.all(pushes)\n  }\n\n  /**\n   * Calls `push` for all peers in the `peerStore` that are connected\n   * @param {PeerStore} peerStore\n   */\n  pushToPeerStore (peerStore) {\n    const connections = []\n    let connection\n    for (const peer of peerStore.peers.values()) {\n      if (peer.protocols.includes(MULTICODEC_IDENTIFY_PUSH) && (connection = this.connectionManager.get(peer.id))) {\n        connections.push(connection)\n      }\n    }\n\n    this.push(connections)\n  }\n\n  /**\n   * Requests the `Identify` message from peer associated with the given `connection`.\n   * If the identified peer does not match the `PeerId` associated with the connection,\n   * an error will be thrown.\n   *\n   * @async\n   * @param {Connection} connection\n   * @returns {Promise<void>}\n   */\n  async identify (connection) {\n    const { stream } = await connection.newStream(MULTICODEC_IDENTIFY)\n    const [data] = await pipe(\n      [],\n      stream,\n      lp.decode(),\n      take(1),\n      toBuffer,\n      collect\n    )\n\n    if (!data) {\n      throw errCode(new Error('No data could be retrieved'), codes.ERR_CONNECTION_ENDED)\n    }\n\n    let message\n    try {\n      message = Message.decode(data)\n    } catch (err) {\n      throw errCode(err, codes.ERR_INVALID_MESSAGE)\n    }\n\n    let {\n      publicKey,\n      listenAddrs,\n      protocols,\n      observedAddr,\n      signedPeerRecord\n    } = message\n\n    const id = await PeerId.createFromPubKey(publicKey)\n\n    if (connection.remotePeer.toB58String() !== id.toB58String()) {\n      throw errCode(new Error('identified peer does not match the expected peer'), codes.ERR_INVALID_PEER)\n    }\n\n    // Get the observedAddr if there is one\n    observedAddr = IdentifyService.getCleanMultiaddr(observedAddr)\n\n    try {\n      const envelope = await Envelope.openAndCertify(signedPeerRecord, PeerRecord.DOMAIN)\n      if (this.peerStore.addressBook.consumePeerRecord(envelope)) {\n        this.peerStore.protoBook.set(id, protocols)\n        return\n      }\n    } catch (err) {\n      log('received invalid envelope, discard it and fallback to listenAddrs is available', err)\n    }\n\n    // LEGACY: Update peers data in PeerStore\n    try {\n      this.peerStore.addressBook.set(id, listenAddrs.map((addr) => multiaddr(addr)))\n    } catch (err) {\n      log.error('received invalid addrs', err)\n    }\n\n    this.peerStore.protoBook.set(id, protocols)\n    this.peerStore.metadataBook.set(id, 'AgentVersion', uint8ArrayFromString(message.agentVersion))\n\n    // TODO: Track our observed address so that we can score it\n    log('received observed address of %s', observedAddr)\n  }\n\n  /**\n   * A handler to register with Libp2p to process identify messages.\n   *\n   * @param {object} options\n   * @param {String} options.protocol\n   * @param {*} options.stream\n   * @param {Connection} options.connection\n   * @returns {Promise<void>}\n   */\n  handleMessage ({ connection, stream, protocol }) {\n    switch (protocol) {\n      case MULTICODEC_IDENTIFY:\n        return this._handleIdentify({ connection, stream })\n      case MULTICODEC_IDENTIFY_PUSH:\n        return this._handlePush({ connection, stream })\n      default:\n        log.error('cannot handle unknown protocol %s', protocol)\n    }\n  }\n\n  /**\n   * Sends the `Identify` response with the Signed Peer Record\n   * to the requesting peer over the given `connection`\n   * @private\n   * @param {object} options\n   * @param {*} options.stream\n   * @param {Connection} options.connection\n   */\n  async _handleIdentify ({ connection, stream }) {\n    let publicKey = new Uint8Array(0)\n    if (this.peerId.pubKey) {\n      publicKey = this.peerId.pubKey.bytes\n    }\n\n    const signedPeerRecord = await this._getSelfPeerRecord()\n\n    const message = Message.encode({\n      protocolVersion: PROTOCOL_VERSION,\n      agentVersion: AGENT_VERSION,\n      publicKey,\n      listenAddrs: this._libp2p.multiaddrs.map((ma) => ma.bytes),\n      signedPeerRecord,\n      observedAddr: connection.remoteAddr.bytes,\n      protocols: Array.from(this._protocols.keys())\n    })\n\n    try {\n      await pipe(\n        [message],\n        lp.encode(),\n        stream,\n        consume\n      )\n    } catch (err) {\n      log.error('could not respond to identify request', err)\n    }\n  }\n\n  /**\n   * Reads the Identify Push message from the given `connection`\n   * @private\n   * @param {object} options\n   * @param {*} options.stream\n   * @param {Connection} options.connection\n   */\n  async _handlePush ({ connection, stream }) {\n    let message\n    try {\n      const [data] = await pipe(\n        [],\n        stream,\n        lp.decode(),\n        take(1),\n        toBuffer,\n        collect\n      )\n      message = Message.decode(data)\n    } catch (err) {\n      return log.error('received invalid message', err)\n    }\n\n    const id = connection.remotePeer\n\n    try {\n      const envelope = await Envelope.openAndCertify(message.signedPeerRecord, PeerRecord.DOMAIN)\n      if (this.peerStore.addressBook.consumePeerRecord(envelope)) {\n        this.peerStore.protoBook.set(id, message.protocols)\n        return\n      }\n    } catch (err) {\n      log('received invalid envelope, discard it and fallback to listenAddrs is available', err)\n    }\n\n    // LEGACY: Update peers data in PeerStore\n    try {\n      this.peerStore.addressBook.set(id, message.listenAddrs.map((addr) => multiaddr(addr)))\n    } catch (err) {\n      log.error('received invalid addrs', err)\n    }\n\n    // Update the protocols\n    this.peerStore.protoBook.set(id, message.protocols)\n  }\n\n  /**\n   * Get self signed peer record raw envelope.\n   * @return {Uint8Array}\n   */\n  async _getSelfPeerRecord () {\n    const selfSignedPeerRecord = this.peerStore.addressBook.getRawEnvelope(this.peerId)\n\n    // TODO: support invalidation when dynamic multiaddrs are supported\n    if (selfSignedPeerRecord) {\n      return selfSignedPeerRecord\n    }\n\n    try {\n      const peerRecord = new PeerRecord({\n        peerId: this.peerId,\n        multiaddrs: this._libp2p.multiaddrs\n      })\n      const envelope = await Envelope.seal(peerRecord, this.peerId)\n      this.peerStore.addressBook.consumePeerRecord(envelope)\n\n      return this.peerStore.addressBook.getRawEnvelope(this.peerId)\n    } catch (err) {\n      log.error('failed to get self peer record')\n    }\n    return null\n  }\n}\n\nmodule.exports.IdentifyService = IdentifyService\n/**\n * The protocols the IdentifyService supports\n * @property multicodecs\n */\nmodule.exports.multicodecs = {\n  IDENTIFY: MULTICODEC_IDENTIFY,\n  IDENTIFY_PUSH: MULTICODEC_IDENTIFY_PUSH\n}\nmodule.exports.Message = Message\n"]},"metadata":{},"sourceType":"script"}