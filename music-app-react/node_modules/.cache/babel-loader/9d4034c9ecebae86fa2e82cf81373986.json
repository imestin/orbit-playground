{"ast":null,"code":"'use strict';\n\nconst pkgversion = require('../../../package.json').version;\n\nconst multiaddr = require('multiaddr');\n\nconst {\n  withTimeoutOption\n} = require('../utils');\n\nconst uint8ArrayToString = require('uint8arrays/to-string');\n/**\n * @typedef {object} PeerIdObj - An object with the Peer identity\n * @property {string} id - the Peer ID\n * @property {string} publicKey - the public key of the peer as a base64 encoded string\n * @property {import('multiaddr')[]} addresses - A list of multiaddrs this node is listening on\n * @property {string} agentVersion - The agent version\n * @property {string} protocolVersion - The supported protocol version\n * @property {string[]} protocols - The supported protocols\n */\n\n/**\n * Returns the identity of the Peer\n * @template {Record<string, any>} ExtraOptions\n * @callback Id\n * @param {import('../utils').AbortOptions & ExtraOptions} [options]\n * @returns {Promise<PeerIdObj>}\n */\n\n\nmodule.exports = ({\n  peerId,\n  libp2p\n}) => {\n  // eslint-disable-next-line valid-jsdoc\n\n  /**\n   * @type {Id<{}>}\n   */\n  async function id(options) {\n    // eslint-disable-line require-await, @typescript-eslint/no-unused-vars\n    const id = peerId.toB58String();\n    let addresses = [];\n    let protocols = [];\n\n    if (libp2p) {\n      // only available while the node is running\n      addresses = libp2p.transportManager.getAddrs();\n      protocols = Array.from(libp2p.upgrader.protocols.keys());\n    }\n\n    return {\n      id,\n      publicKey: uint8ArrayToString(peerId.pubKey.bytes, 'base64pad'),\n      addresses: addresses.map(ma => {\n        const str = ma.toString(); // some relay-style transports add our peer id to the ma for us\n        // so don't double-add\n\n        if (str.endsWith(`/p2p/${id}`)) {\n          return str;\n        }\n\n        return `${str}/p2p/${id}`;\n      }).sort().map(ma => multiaddr(ma)),\n      agentVersion: `js-ipfs/${pkgversion}`,\n      protocolVersion: '9000',\n      protocols: protocols.sort()\n    };\n  }\n\n  return withTimeoutOption(id);\n};","map":{"version":3,"sources":["/home/user/orbit-playground/music-app/node_modules/ipfs/src/core/components/id.js"],"names":["pkgversion","require","version","multiaddr","withTimeoutOption","uint8ArrayToString","module","exports","peerId","libp2p","id","options","toB58String","addresses","protocols","transportManager","getAddrs","Array","from","upgrader","keys","publicKey","pubKey","bytes","map","ma","str","toString","endsWith","sort","agentVersion","protocolVersion"],"mappings":"AAAA;;AAEA,MAAMA,UAAU,GAAGC,OAAO,CAAC,uBAAD,CAAP,CAAiCC,OAApD;;AACA,MAAMC,SAAS,GAAGF,OAAO,CAAC,WAAD,CAAzB;;AACA,MAAM;AAAEG,EAAAA;AAAF,IAAwBH,OAAO,CAAC,UAAD,CAArC;;AACA,MAAMI,kBAAkB,GAAGJ,OAAO,CAAC,uBAAD,CAAlC;AAEA;;;;;;;;;;AAUA;;;;;;;;;AAQAK,MAAM,CAACC,OAAP,GAAiB,CAAC;AAAEC,EAAAA,MAAF;AAAUC,EAAAA;AAAV,CAAD,KAAwB;AACvC;;AACA;;;AAGA,iBAAeC,EAAf,CAAmBC,OAAnB,EAA4B;AAAE;AAC5B,UAAMD,EAAE,GAAGF,MAAM,CAACI,WAAP,EAAX;AACA,QAAIC,SAAS,GAAG,EAAhB;AACA,QAAIC,SAAS,GAAG,EAAhB;;AAEA,QAAIL,MAAJ,EAAY;AACV;AACAI,MAAAA,SAAS,GAAGJ,MAAM,CAACM,gBAAP,CAAwBC,QAAxB,EAAZ;AACAF,MAAAA,SAAS,GAAGG,KAAK,CAACC,IAAN,CAAWT,MAAM,CAACU,QAAP,CAAgBL,SAAhB,CAA0BM,IAA1B,EAAX,CAAZ;AACD;;AAED,WAAO;AACLV,MAAAA,EADK;AAELW,MAAAA,SAAS,EAAEhB,kBAAkB,CAACG,MAAM,CAACc,MAAP,CAAcC,KAAf,EAAsB,WAAtB,CAFxB;AAGLV,MAAAA,SAAS,EAAEA,SAAS,CACjBW,GADQ,CACJC,EAAE,IAAI;AACT,cAAMC,GAAG,GAAGD,EAAE,CAACE,QAAH,EAAZ,CADS,CAGT;AACA;;AACA,YAAID,GAAG,CAACE,QAAJ,CAAc,QAAOlB,EAAG,EAAxB,CAAJ,EAAgC;AAC9B,iBAAOgB,GAAP;AACD;;AAED,eAAQ,GAAEA,GAAI,QAAOhB,EAAG,EAAxB;AACD,OAXQ,EAYRmB,IAZQ,GAaRL,GAbQ,CAaJC,EAAE,IAAItB,SAAS,CAACsB,EAAD,CAbX,CAHN;AAiBLK,MAAAA,YAAY,EAAG,WAAU9B,UAAW,EAjB/B;AAkBL+B,MAAAA,eAAe,EAAE,MAlBZ;AAmBLjB,MAAAA,SAAS,EAAEA,SAAS,CAACe,IAAV;AAnBN,KAAP;AAqBD;;AACD,SAAOzB,iBAAiB,CAACM,EAAD,CAAxB;AACD,CAvCD","sourcesContent":["'use strict'\n\nconst pkgversion = require('../../../package.json').version\nconst multiaddr = require('multiaddr')\nconst { withTimeoutOption } = require('../utils')\nconst uint8ArrayToString = require('uint8arrays/to-string')\n\n/**\n * @typedef {object} PeerIdObj - An object with the Peer identity\n * @property {string} id - the Peer ID\n * @property {string} publicKey - the public key of the peer as a base64 encoded string\n * @property {import('multiaddr')[]} addresses - A list of multiaddrs this node is listening on\n * @property {string} agentVersion - The agent version\n * @property {string} protocolVersion - The supported protocol version\n * @property {string[]} protocols - The supported protocols\n */\n\n/**\n * Returns the identity of the Peer\n * @template {Record<string, any>} ExtraOptions\n * @callback Id\n * @param {import('../utils').AbortOptions & ExtraOptions} [options]\n * @returns {Promise<PeerIdObj>}\n */\n\nmodule.exports = ({ peerId, libp2p }) => {\n  // eslint-disable-next-line valid-jsdoc\n  /**\n   * @type {Id<{}>}\n   */\n  async function id (options) { // eslint-disable-line require-await, @typescript-eslint/no-unused-vars\n    const id = peerId.toB58String()\n    let addresses = []\n    let protocols = []\n\n    if (libp2p) {\n      // only available while the node is running\n      addresses = libp2p.transportManager.getAddrs()\n      protocols = Array.from(libp2p.upgrader.protocols.keys())\n    }\n\n    return {\n      id,\n      publicKey: uint8ArrayToString(peerId.pubKey.bytes, 'base64pad'),\n      addresses: addresses\n        .map(ma => {\n          const str = ma.toString()\n\n          // some relay-style transports add our peer id to the ma for us\n          // so don't double-add\n          if (str.endsWith(`/p2p/${id}`)) {\n            return str\n          }\n\n          return `${str}/p2p/${id}`\n        })\n        .sort()\n        .map(ma => multiaddr(ma)),\n      agentVersion: `js-ipfs/${pkgversion}`,\n      protocolVersion: '9000',\n      protocols: protocols.sort()\n    }\n  }\n  return withTimeoutOption(id)\n}\n"]},"metadata":{},"sourceType":"script"}