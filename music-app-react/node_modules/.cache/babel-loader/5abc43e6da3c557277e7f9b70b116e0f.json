{"ast":null,"code":"'use strict';\n\nconst debug = require('debug');\n\nconst log = debug('libp2p:persistent-peer-store');\nlog.error = debug('libp2p:persistent-peer-store:error');\n\nconst {\n  Key\n} = require('interface-datastore');\n\nconst multiaddr = require('multiaddr');\n\nconst PeerId = require('peer-id');\n\nconst PeerStore = require('..');\n\nconst {\n  NAMESPACE_ADDRESS,\n  NAMESPACE_COMMON,\n  NAMESPACE_KEYS,\n  NAMESPACE_METADATA,\n  NAMESPACE_PROTOCOL\n} = require('./consts');\n\nconst Addresses = require('./pb/address-book.proto');\n\nconst Protocols = require('./pb/proto-book.proto');\n/**\n * Responsible for managing the persistence of data in the PeerStore.\n */\n\n\nclass PersistentPeerStore extends PeerStore {\n  /**\n   * @constructor\n   * @param {Object} properties\n   * @param {PeerId} properties.peerId\n   * @param {Datastore} properties.datastore Datastore to persist data.\n   * @param {number} [properties.threshold = 5] Number of dirty peers allowed before commit data.\n   */\n  constructor({\n    peerId,\n    datastore,\n    threshold = 5\n  }) {\n    super({\n      peerId\n    });\n    /**\n     * Backend datastore used to persist data.\n     */\n\n    this._datastore = datastore;\n    /**\n     * Peers modified after the latest data persisted.\n     */\n\n    this._dirtyPeers = new Set();\n    /**\n     * Peers metadata changed mapping peer identifers to metadata changed.\n     * @type {Map<string, Set<string>>}\n     */\n\n    this._dirtyMetadata = new Map();\n    this.threshold = threshold;\n    this._addDirtyPeer = this._addDirtyPeer.bind(this);\n  }\n  /**\n   * Start Persistent PeerStore.\n   * @return {Promise<void>}\n   */\n\n\n  async start() {\n    log('PeerStore is starting'); // Handlers for dirty peers\n\n    this.on('change:protocols', this._addDirtyPeer);\n    this.on('change:multiaddrs', this._addDirtyPeer);\n    this.on('change:pubkey', this._addDirtyPeer);\n    this.on('change:metadata', this._addDirtyPeerMetadata); // Load data\n\n    for await (const entry of this._datastore.query({\n      prefix: NAMESPACE_COMMON\n    })) {\n      await this._processDatastoreEntry(entry);\n    }\n\n    log('PeerStore started');\n  }\n\n  async stop() {\n    log('PeerStore is stopping');\n    this.removeAllListeners();\n    await this._commitData();\n    log('PeerStore stopped');\n  }\n  /**\n   * Add modified peer to the dirty set\n   * @private\n   * @param {Object} params\n   * @param {PeerId} params.peerId\n   */\n\n\n  _addDirtyPeer({\n    peerId\n  }) {\n    const peerIdstr = peerId.toB58String();\n    log('add dirty peer', peerIdstr);\n\n    this._dirtyPeers.add(peerIdstr);\n\n    if (this._dirtyPeers.size >= this.threshold) {\n      // Commit current data\n      this._commitData().catch(err => {\n        log.error('error committing data', err);\n      });\n    }\n  }\n  /**\n   * Add modified metadata peer to the set.\n   * @private\n   * @param {Object} params\n   * @param {PeerId} params.peerId\n   * @param {string} params.metadata\n   */\n\n\n  _addDirtyPeerMetadata({\n    peerId,\n    metadata\n  }) {\n    const peerIdstr = peerId.toB58String();\n    log('add dirty metadata peer', peerIdstr);\n\n    this._dirtyPeers.add(peerIdstr); // Add dirty metadata key\n\n\n    const mData = this._dirtyMetadata.get(peerIdstr) || new Set();\n    mData.add(metadata);\n\n    this._dirtyMetadata.set(peerIdstr, mData);\n\n    if (this._dirtyPeers.size >= this.threshold) {\n      // Commit current data\n      this._commitData().catch(err => {\n        log.error('error committing data', err);\n      });\n    }\n  }\n  /**\n   * Add all the peers current data to a datastore batch and commit it.\n   * @private\n   * @param {Array<string>} peers\n   * @return {Promise<void>}\n   */\n\n\n  async _commitData() {\n    const commitPeers = Array.from(this._dirtyPeers);\n\n    if (!commitPeers.length) {\n      return;\n    } // Clear Dirty Peers set\n\n\n    this._dirtyPeers.clear();\n\n    log('create batch commit');\n\n    const batch = this._datastore.batch();\n\n    for (const peerIdStr of commitPeers) {\n      // PeerId\n      const peerId = this.keyBook.data.get(peerIdStr) || PeerId.createFromCID(peerIdStr); // Address Book\n\n      this._batchAddressBook(peerId, batch); // Key Book\n\n\n      this._batchKeyBook(peerId, batch); // Metadata Book\n\n\n      this._batchMetadataBook(peerId, batch); // Proto Book\n\n\n      this._batchProtoBook(peerId, batch);\n    }\n\n    await batch.commit();\n    log('batch committed');\n  }\n  /**\n   * Add address book data of the peer to the batch.\n   * @private\n   * @param {PeerId} peerId\n   * @param {Object} batch\n   */\n\n\n  _batchAddressBook(peerId, batch) {\n    const b32key = peerId.toString();\n    const key = new Key(`${NAMESPACE_ADDRESS}${b32key}`);\n    const entry = this.addressBook.data.get(peerId.toB58String());\n\n    try {\n      // Deleted from the book\n      if (!entry) {\n        batch.delete(key);\n        return;\n      }\n\n      const encodedData = Addresses.encode({\n        addrs: entry.addresses.map(address => ({\n          multiaddr: address.multiaddr.bytes,\n          isCertified: address.isCertified\n        })),\n        certified_record: entry.record ? {\n          seq: entry.record.seqNumber,\n          raw: entry.record.raw\n        } : undefined\n      });\n      batch.put(key, encodedData);\n    } catch (err) {\n      log.error(err);\n    }\n  }\n  /**\n   * Add Key book data of the peer to the batch.\n   * @private\n   * @param {PeerId} peerId\n   * @param {Object} batch\n   */\n\n\n  _batchKeyBook(peerId, batch) {\n    const b32key = peerId.toString();\n    const key = new Key(`${NAMESPACE_KEYS}${b32key}`);\n\n    try {\n      // Deleted from the book\n      if (!peerId.pubKey) {\n        batch.delete(key);\n        return;\n      }\n\n      const encodedData = peerId.marshalPubKey();\n      batch.put(key, encodedData);\n    } catch (err) {\n      log.error(err);\n    }\n  }\n  /**\n   * Add metadata book data of the peer to the batch.\n   * @private\n   * @param {PeerId} peerId\n   * @param {Object} batch\n   */\n\n\n  _batchMetadataBook(peerId, batch) {\n    const b32key = peerId.toString();\n    const dirtyMetada = this._dirtyMetadata.get(peerId.toB58String()) || [];\n\n    try {\n      dirtyMetada.forEach(dirtyKey => {\n        const key = new Key(`${NAMESPACE_METADATA}${b32key}/${dirtyKey}`);\n        const dirtyValue = this.metadataBook.getValue(peerId, dirtyKey);\n\n        if (dirtyValue) {\n          batch.put(key, dirtyValue);\n        } else {\n          batch.delete(key);\n        }\n      });\n    } catch (err) {\n      log.error(err);\n    }\n  }\n  /**\n   * Add proto book data of the peer to the batch.\n   * @private\n   * @param {PeerId} peerId\n   * @param {Object} batch\n   */\n\n\n  _batchProtoBook(peerId, batch) {\n    const b32key = peerId.toString();\n    const key = new Key(`${NAMESPACE_PROTOCOL}${b32key}`);\n    const protocols = this.protoBook.get(peerId);\n\n    try {\n      // Deleted from the book\n      if (!protocols) {\n        batch.delete(key);\n        return;\n      }\n\n      const encodedData = Protocols.encode({\n        protocols\n      });\n      batch.put(key, encodedData);\n    } catch (err) {\n      log.error(err);\n    }\n  }\n  /**\n   * Process datastore entry and add its data to the correct book.\n   * @private\n   * @param {Object} params\n   * @param {Key} params.key datastore key\n   * @param {Uint8Array} params.value datastore value stored\n   * @return {Promise<void>}\n   */\n\n\n  async _processDatastoreEntry({\n    key,\n    value\n  }) {\n    try {\n      const keyParts = key.toString().split('/');\n      const peerId = PeerId.createFromCID(keyParts[3]);\n      let decoded;\n\n      switch (keyParts[2]) {\n        case 'addrs':\n          decoded = Addresses.decode(value);\n\n          this.addressBook._setData(peerId, {\n            addresses: decoded.addrs.map(address => ({\n              multiaddr: multiaddr(address.multiaddr),\n              isCertified: Boolean(address.isCertified)\n            })),\n            record: decoded.certified_record ? {\n              raw: decoded.certified_record.raw,\n              seqNumber: decoded.certified_record.seq\n            } : undefined\n          }, {\n            emit: false\n          });\n\n          break;\n\n        case 'keys':\n          decoded = await PeerId.createFromPubKey(value);\n\n          this.keyBook._setData(decoded, decoded, {\n            emit: false\n          });\n\n          break;\n\n        case 'metadata':\n          this.metadataBook._setValue(peerId, keyParts[4], value, {\n            emit: false\n          });\n\n          break;\n\n        case 'protos':\n          decoded = Protocols.decode(value);\n\n          this.protoBook._setData(peerId, new Set(decoded.protocols), {\n            emit: false\n          });\n\n          break;\n\n        default:\n          log('invalid data persisted for: ', key.toString());\n      }\n    } catch (err) {\n      log.error(err);\n    }\n  }\n\n}\n\nmodule.exports = PersistentPeerStore;","map":{"version":3,"sources":["/home/user/orbit-playground/music-app/node_modules/libp2p/src/peer-store/persistent/index.js"],"names":["debug","require","log","error","Key","multiaddr","PeerId","PeerStore","NAMESPACE_ADDRESS","NAMESPACE_COMMON","NAMESPACE_KEYS","NAMESPACE_METADATA","NAMESPACE_PROTOCOL","Addresses","Protocols","PersistentPeerStore","constructor","peerId","datastore","threshold","_datastore","_dirtyPeers","Set","_dirtyMetadata","Map","_addDirtyPeer","bind","start","on","_addDirtyPeerMetadata","entry","query","prefix","_processDatastoreEntry","stop","removeAllListeners","_commitData","peerIdstr","toB58String","add","size","catch","err","metadata","mData","get","set","commitPeers","Array","from","length","clear","batch","peerIdStr","keyBook","data","createFromCID","_batchAddressBook","_batchKeyBook","_batchMetadataBook","_batchProtoBook","commit","b32key","toString","key","addressBook","delete","encodedData","encode","addrs","addresses","map","address","bytes","isCertified","certified_record","record","seq","seqNumber","raw","undefined","put","pubKey","marshalPubKey","dirtyMetada","forEach","dirtyKey","dirtyValue","metadataBook","getValue","protocols","protoBook","value","keyParts","split","decoded","decode","_setData","Boolean","emit","createFromPubKey","_setValue","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst debug = require('debug')\nconst log = debug('libp2p:persistent-peer-store')\nlog.error = debug('libp2p:persistent-peer-store:error')\n\nconst { Key } = require('interface-datastore')\nconst multiaddr = require('multiaddr')\nconst PeerId = require('peer-id')\n\nconst PeerStore = require('..')\n\nconst {\n  NAMESPACE_ADDRESS,\n  NAMESPACE_COMMON,\n  NAMESPACE_KEYS,\n  NAMESPACE_METADATA,\n  NAMESPACE_PROTOCOL\n} = require('./consts')\n\nconst Addresses = require('./pb/address-book.proto')\nconst Protocols = require('./pb/proto-book.proto')\n\n/**\n * Responsible for managing the persistence of data in the PeerStore.\n */\nclass PersistentPeerStore extends PeerStore {\n  /**\n   * @constructor\n   * @param {Object} properties\n   * @param {PeerId} properties.peerId\n   * @param {Datastore} properties.datastore Datastore to persist data.\n   * @param {number} [properties.threshold = 5] Number of dirty peers allowed before commit data.\n   */\n  constructor ({ peerId, datastore, threshold = 5 }) {\n    super({ peerId })\n\n    /**\n     * Backend datastore used to persist data.\n     */\n    this._datastore = datastore\n\n    /**\n     * Peers modified after the latest data persisted.\n     */\n    this._dirtyPeers = new Set()\n\n    /**\n     * Peers metadata changed mapping peer identifers to metadata changed.\n     * @type {Map<string, Set<string>>}\n     */\n    this._dirtyMetadata = new Map()\n\n    this.threshold = threshold\n    this._addDirtyPeer = this._addDirtyPeer.bind(this)\n  }\n\n  /**\n   * Start Persistent PeerStore.\n   * @return {Promise<void>}\n   */\n  async start () {\n    log('PeerStore is starting')\n\n    // Handlers for dirty peers\n    this.on('change:protocols', this._addDirtyPeer)\n    this.on('change:multiaddrs', this._addDirtyPeer)\n    this.on('change:pubkey', this._addDirtyPeer)\n    this.on('change:metadata', this._addDirtyPeerMetadata)\n\n    // Load data\n    for await (const entry of this._datastore.query({ prefix: NAMESPACE_COMMON })) {\n      await this._processDatastoreEntry(entry)\n    }\n\n    log('PeerStore started')\n  }\n\n  async stop () {\n    log('PeerStore is stopping')\n    this.removeAllListeners()\n    await this._commitData()\n    log('PeerStore stopped')\n  }\n\n  /**\n   * Add modified peer to the dirty set\n   * @private\n   * @param {Object} params\n   * @param {PeerId} params.peerId\n   */\n  _addDirtyPeer ({ peerId }) {\n    const peerIdstr = peerId.toB58String()\n\n    log('add dirty peer', peerIdstr)\n    this._dirtyPeers.add(peerIdstr)\n\n    if (this._dirtyPeers.size >= this.threshold) {\n      // Commit current data\n      this._commitData().catch(err => {\n        log.error('error committing data', err)\n      })\n    }\n  }\n\n  /**\n   * Add modified metadata peer to the set.\n   * @private\n   * @param {Object} params\n   * @param {PeerId} params.peerId\n   * @param {string} params.metadata\n   */\n  _addDirtyPeerMetadata ({ peerId, metadata }) {\n    const peerIdstr = peerId.toB58String()\n\n    log('add dirty metadata peer', peerIdstr)\n    this._dirtyPeers.add(peerIdstr)\n\n    // Add dirty metadata key\n    const mData = this._dirtyMetadata.get(peerIdstr) || new Set()\n    mData.add(metadata)\n    this._dirtyMetadata.set(peerIdstr, mData)\n\n    if (this._dirtyPeers.size >= this.threshold) {\n      // Commit current data\n      this._commitData().catch(err => {\n        log.error('error committing data', err)\n      })\n    }\n  }\n\n  /**\n   * Add all the peers current data to a datastore batch and commit it.\n   * @private\n   * @param {Array<string>} peers\n   * @return {Promise<void>}\n   */\n  async _commitData () {\n    const commitPeers = Array.from(this._dirtyPeers)\n\n    if (!commitPeers.length) {\n      return\n    }\n\n    // Clear Dirty Peers set\n    this._dirtyPeers.clear()\n\n    log('create batch commit')\n    const batch = this._datastore.batch()\n    for (const peerIdStr of commitPeers) {\n      // PeerId\n      const peerId = this.keyBook.data.get(peerIdStr) || PeerId.createFromCID(peerIdStr)\n\n      // Address Book\n      this._batchAddressBook(peerId, batch)\n\n      // Key Book\n      this._batchKeyBook(peerId, batch)\n\n      // Metadata Book\n      this._batchMetadataBook(peerId, batch)\n\n      // Proto Book\n      this._batchProtoBook(peerId, batch)\n    }\n\n    await batch.commit()\n    log('batch committed')\n  }\n\n  /**\n   * Add address book data of the peer to the batch.\n   * @private\n   * @param {PeerId} peerId\n   * @param {Object} batch\n   */\n  _batchAddressBook (peerId, batch) {\n    const b32key = peerId.toString()\n    const key = new Key(`${NAMESPACE_ADDRESS}${b32key}`)\n\n    const entry = this.addressBook.data.get(peerId.toB58String())\n\n    try {\n      // Deleted from the book\n      if (!entry) {\n        batch.delete(key)\n        return\n      }\n\n      const encodedData = Addresses.encode({\n        addrs: entry.addresses.map((address) => ({\n          multiaddr: address.multiaddr.bytes,\n          isCertified: address.isCertified\n        })),\n        certified_record: entry.record ? {\n          seq: entry.record.seqNumber,\n          raw: entry.record.raw\n        } : undefined\n      })\n\n      batch.put(key, encodedData)\n    } catch (err) {\n      log.error(err)\n    }\n  }\n\n  /**\n   * Add Key book data of the peer to the batch.\n   * @private\n   * @param {PeerId} peerId\n   * @param {Object} batch\n   */\n  _batchKeyBook (peerId, batch) {\n    const b32key = peerId.toString()\n    const key = new Key(`${NAMESPACE_KEYS}${b32key}`)\n\n    try {\n      // Deleted from the book\n      if (!peerId.pubKey) {\n        batch.delete(key)\n        return\n      }\n\n      const encodedData = peerId.marshalPubKey()\n\n      batch.put(key, encodedData)\n    } catch (err) {\n      log.error(err)\n    }\n  }\n\n  /**\n   * Add metadata book data of the peer to the batch.\n   * @private\n   * @param {PeerId} peerId\n   * @param {Object} batch\n   */\n  _batchMetadataBook (peerId, batch) {\n    const b32key = peerId.toString()\n    const dirtyMetada = this._dirtyMetadata.get(peerId.toB58String()) || []\n\n    try {\n      dirtyMetada.forEach((dirtyKey) => {\n        const key = new Key(`${NAMESPACE_METADATA}${b32key}/${dirtyKey}`)\n        const dirtyValue = this.metadataBook.getValue(peerId, dirtyKey)\n\n        if (dirtyValue) {\n          batch.put(key, dirtyValue)\n        } else {\n          batch.delete(key)\n        }\n      })\n    } catch (err) {\n      log.error(err)\n    }\n  }\n\n  /**\n   * Add proto book data of the peer to the batch.\n   * @private\n   * @param {PeerId} peerId\n   * @param {Object} batch\n   */\n  _batchProtoBook (peerId, batch) {\n    const b32key = peerId.toString()\n    const key = new Key(`${NAMESPACE_PROTOCOL}${b32key}`)\n\n    const protocols = this.protoBook.get(peerId)\n\n    try {\n      // Deleted from the book\n      if (!protocols) {\n        batch.delete(key)\n        return\n      }\n\n      const encodedData = Protocols.encode({ protocols })\n\n      batch.put(key, encodedData)\n    } catch (err) {\n      log.error(err)\n    }\n  }\n\n  /**\n   * Process datastore entry and add its data to the correct book.\n   * @private\n   * @param {Object} params\n   * @param {Key} params.key datastore key\n   * @param {Uint8Array} params.value datastore value stored\n   * @return {Promise<void>}\n   */\n  async _processDatastoreEntry ({ key, value }) {\n    try {\n      const keyParts = key.toString().split('/')\n      const peerId = PeerId.createFromCID(keyParts[3])\n\n      let decoded\n      switch (keyParts[2]) {\n        case 'addrs':\n          decoded = Addresses.decode(value)\n\n          this.addressBook._setData(\n            peerId,\n            {\n              addresses: decoded.addrs.map((address) => ({\n                multiaddr: multiaddr(address.multiaddr),\n                isCertified: Boolean(address.isCertified)\n              })),\n              record: decoded.certified_record ? {\n                raw: decoded.certified_record.raw,\n                seqNumber: decoded.certified_record.seq\n              } : undefined\n            },\n            { emit: false })\n          break\n        case 'keys':\n          decoded = await PeerId.createFromPubKey(value)\n\n          this.keyBook._setData(\n            decoded,\n            decoded,\n            { emit: false })\n          break\n        case 'metadata':\n          this.metadataBook._setValue(\n            peerId,\n            keyParts[4],\n            value,\n            { emit: false })\n          break\n        case 'protos':\n          decoded = Protocols.decode(value)\n\n          this.protoBook._setData(\n            peerId,\n            new Set(decoded.protocols),\n            { emit: false })\n          break\n        default:\n          log('invalid data persisted for: ', key.toString())\n      }\n    } catch (err) {\n      log.error(err)\n    }\n  }\n}\n\nmodule.exports = PersistentPeerStore\n"]},"metadata":{},"sourceType":"script"}