{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AbstractHandshake = exports.MIN_NONCE = void 0;\n\nconst buffer_1 = require(\"buffer\");\n\nconst aead_1 = __importDefault(require(\"bcrypto/lib/js/aead\"));\n\nconst x25519_1 = __importDefault(require(\"bcrypto/lib/js/x25519\"));\n\nconst sha256_1 = __importDefault(require(\"bcrypto/lib/js/sha256\"));\n\nconst utils_1 = require(\"../utils\");\n\nconst logger_1 = require(\"../logger\");\n\nexports.MIN_NONCE = 0;\n\nclass AbstractHandshake {\n  encryptWithAd(cs, ad, plaintext) {\n    const e = this.encrypt(cs.k, cs.n, ad, plaintext);\n    this.setNonce(cs, this.incrementNonce(cs.n));\n    return e;\n  }\n\n  decryptWithAd(cs, ad, ciphertext) {\n    const {\n      plaintext,\n      valid\n    } = this.decrypt(cs.k, cs.n, ad, ciphertext);\n    this.setNonce(cs, this.incrementNonce(cs.n));\n    return {\n      plaintext,\n      valid\n    };\n  } // Cipher state related\n\n\n  hasKey(cs) {\n    return !this.isEmptyKey(cs.k);\n  }\n\n  setNonce(cs, nonce) {\n    cs.n = nonce;\n  }\n\n  createEmptyKey() {\n    return buffer_1.Buffer.alloc(32);\n  }\n\n  isEmptyKey(k) {\n    const emptyKey = this.createEmptyKey();\n    return emptyKey.equals(k);\n  }\n\n  incrementNonce(n) {\n    return n + 1;\n  }\n\n  nonceToBytes(n) {\n    const nonce = buffer_1.Buffer.alloc(12);\n    nonce.writeUInt32LE(n, 4);\n    return nonce;\n  }\n\n  encrypt(k, n, ad, plaintext) {\n    const nonce = this.nonceToBytes(n);\n    const ctx = new aead_1.default();\n    plaintext = buffer_1.Buffer.from(plaintext);\n    ctx.init(k, nonce);\n    ctx.aad(ad);\n    ctx.encrypt(plaintext); // Encryption is done on the sent reference\n\n    return buffer_1.Buffer.concat([plaintext, ctx.final()]);\n  }\n\n  encryptAndHash(ss, plaintext) {\n    let ciphertext;\n\n    if (this.hasKey(ss.cs)) {\n      ciphertext = this.encryptWithAd(ss.cs, ss.h, plaintext);\n    } else {\n      ciphertext = plaintext;\n    }\n\n    this.mixHash(ss, ciphertext);\n    return ciphertext;\n  }\n\n  decrypt(k, n, ad, ciphertext) {\n    const nonce = this.nonceToBytes(n);\n    const ctx = new aead_1.default();\n    ciphertext = buffer_1.Buffer.from(ciphertext);\n    const tag = ciphertext.slice(ciphertext.length - 16);\n    ciphertext = ciphertext.slice(0, ciphertext.length - 16);\n    ctx.init(k, nonce);\n    ctx.aad(ad);\n    ctx.decrypt(ciphertext); // Decryption is done on the sent reference\n\n    return {\n      plaintext: ciphertext,\n      valid: ctx.verify(tag)\n    };\n  }\n\n  decryptAndHash(ss, ciphertext) {\n    let plaintext;\n    let valid = true;\n\n    if (this.hasKey(ss.cs)) {\n      ({\n        plaintext,\n        valid\n      } = this.decryptWithAd(ss.cs, ss.h, ciphertext));\n    } else {\n      plaintext = ciphertext;\n    }\n\n    this.mixHash(ss, ciphertext);\n    return {\n      plaintext,\n      valid\n    };\n  }\n\n  dh(privateKey, publicKey) {\n    try {\n      const derived = x25519_1.default.derive(publicKey, privateKey);\n      const result = buffer_1.Buffer.alloc(32);\n      derived.copy(result);\n      return result;\n    } catch (e) {\n      logger_1.logger(e.message);\n      return buffer_1.Buffer.alloc(32);\n    }\n  }\n\n  mixHash(ss, data) {\n    ss.h = this.getHash(ss.h, data);\n  }\n\n  getHash(a, b) {\n    return sha256_1.default.digest(buffer_1.Buffer.from([...a, ...b]));\n  }\n\n  mixKey(ss, ikm) {\n    const [ck, tempK] = utils_1.getHkdf(ss.ck, ikm);\n    ss.cs = this.initializeKey(tempK);\n    ss.ck = ck;\n  }\n\n  initializeKey(k) {\n    const n = exports.MIN_NONCE;\n    return {\n      k,\n      n\n    };\n  } // Symmetric state related\n\n\n  initializeSymmetric(protocolName) {\n    const protocolNameBytes = buffer_1.Buffer.from(protocolName, 'utf-8');\n    const h = this.hashProtocolName(protocolNameBytes);\n    const ck = h;\n    const key = this.createEmptyKey();\n    const cs = this.initializeKey(key);\n    return {\n      cs,\n      ck,\n      h\n    };\n  }\n\n  hashProtocolName(protocolName) {\n    if (protocolName.length <= 32) {\n      const h = buffer_1.Buffer.alloc(32);\n      protocolName.copy(h);\n      return h;\n    } else {\n      return this.getHash(protocolName, buffer_1.Buffer.alloc(0));\n    }\n  }\n\n  split(ss) {\n    const [tempk1, tempk2] = utils_1.getHkdf(ss.ck, buffer_1.Buffer.alloc(0));\n    const cs1 = this.initializeKey(tempk1);\n    const cs2 = this.initializeKey(tempk2);\n    return {\n      cs1,\n      cs2\n    };\n  }\n\n  writeMessageRegular(cs, payload) {\n    const ciphertext = this.encryptWithAd(cs, buffer_1.Buffer.alloc(0), payload);\n    const ne = this.createEmptyKey();\n    const ns = buffer_1.Buffer.alloc(0);\n    return {\n      ne,\n      ns,\n      ciphertext\n    };\n  }\n\n  readMessageRegular(cs, message) {\n    return this.decryptWithAd(cs, buffer_1.Buffer.alloc(0), message.ciphertext);\n  }\n\n}\n\nexports.AbstractHandshake = AbstractHandshake;","map":{"version":3,"sources":["../../../src/handshakes/abstract-handshake.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AbstractHandshake = exports.MIN_NONCE = void 0;\nconst buffer_1 = require(\"buffer\");\nconst aead_1 = __importDefault(require(\"bcrypto/lib/js/aead\"));\nconst x25519_1 = __importDefault(require(\"bcrypto/lib/js/x25519\"));\nconst sha256_1 = __importDefault(require(\"bcrypto/lib/js/sha256\"));\nconst utils_1 = require(\"../utils\");\nconst logger_1 = require(\"../logger\");\nexports.MIN_NONCE = 0;\nclass AbstractHandshake {\n    encryptWithAd(cs, ad, plaintext) {\n        const e = this.encrypt(cs.k, cs.n, ad, plaintext);\n        this.setNonce(cs, this.incrementNonce(cs.n));\n        return e;\n    }\n    decryptWithAd(cs, ad, ciphertext) {\n        const { plaintext, valid } = this.decrypt(cs.k, cs.n, ad, ciphertext);\n        this.setNonce(cs, this.incrementNonce(cs.n));\n        return { plaintext, valid };\n    }\n    // Cipher state related\n    hasKey(cs) {\n        return !this.isEmptyKey(cs.k);\n    }\n    setNonce(cs, nonce) {\n        cs.n = nonce;\n    }\n    createEmptyKey() {\n        return buffer_1.Buffer.alloc(32);\n    }\n    isEmptyKey(k) {\n        const emptyKey = this.createEmptyKey();\n        return emptyKey.equals(k);\n    }\n    incrementNonce(n) {\n        return n + 1;\n    }\n    nonceToBytes(n) {\n        const nonce = buffer_1.Buffer.alloc(12);\n        nonce.writeUInt32LE(n, 4);\n        return nonce;\n    }\n    encrypt(k, n, ad, plaintext) {\n        const nonce = this.nonceToBytes(n);\n        const ctx = new aead_1.default();\n        plaintext = buffer_1.Buffer.from(plaintext);\n        ctx.init(k, nonce);\n        ctx.aad(ad);\n        ctx.encrypt(plaintext);\n        // Encryption is done on the sent reference\n        return buffer_1.Buffer.concat([plaintext, ctx.final()]);\n    }\n    encryptAndHash(ss, plaintext) {\n        let ciphertext;\n        if (this.hasKey(ss.cs)) {\n            ciphertext = this.encryptWithAd(ss.cs, ss.h, plaintext);\n        }\n        else {\n            ciphertext = plaintext;\n        }\n        this.mixHash(ss, ciphertext);\n        return ciphertext;\n    }\n    decrypt(k, n, ad, ciphertext) {\n        const nonce = this.nonceToBytes(n);\n        const ctx = new aead_1.default();\n        ciphertext = buffer_1.Buffer.from(ciphertext);\n        const tag = ciphertext.slice(ciphertext.length - 16);\n        ciphertext = ciphertext.slice(0, ciphertext.length - 16);\n        ctx.init(k, nonce);\n        ctx.aad(ad);\n        ctx.decrypt(ciphertext);\n        // Decryption is done on the sent reference\n        return { plaintext: ciphertext, valid: ctx.verify(tag) };\n    }\n    decryptAndHash(ss, ciphertext) {\n        let plaintext;\n        let valid = true;\n        if (this.hasKey(ss.cs)) {\n            ({ plaintext, valid } = this.decryptWithAd(ss.cs, ss.h, ciphertext));\n        }\n        else {\n            plaintext = ciphertext;\n        }\n        this.mixHash(ss, ciphertext);\n        return { plaintext, valid };\n    }\n    dh(privateKey, publicKey) {\n        try {\n            const derived = x25519_1.default.derive(publicKey, privateKey);\n            const result = buffer_1.Buffer.alloc(32);\n            derived.copy(result);\n            return result;\n        }\n        catch (e) {\n            logger_1.logger(e.message);\n            return buffer_1.Buffer.alloc(32);\n        }\n    }\n    mixHash(ss, data) {\n        ss.h = this.getHash(ss.h, data);\n    }\n    getHash(a, b) {\n        return sha256_1.default.digest(buffer_1.Buffer.from([...a, ...b]));\n    }\n    mixKey(ss, ikm) {\n        const [ck, tempK] = utils_1.getHkdf(ss.ck, ikm);\n        ss.cs = this.initializeKey(tempK);\n        ss.ck = ck;\n    }\n    initializeKey(k) {\n        const n = exports.MIN_NONCE;\n        return { k, n };\n    }\n    // Symmetric state related\n    initializeSymmetric(protocolName) {\n        const protocolNameBytes = buffer_1.Buffer.from(protocolName, 'utf-8');\n        const h = this.hashProtocolName(protocolNameBytes);\n        const ck = h;\n        const key = this.createEmptyKey();\n        const cs = this.initializeKey(key);\n        return { cs, ck, h };\n    }\n    hashProtocolName(protocolName) {\n        if (protocolName.length <= 32) {\n            const h = buffer_1.Buffer.alloc(32);\n            protocolName.copy(h);\n            return h;\n        }\n        else {\n            return this.getHash(protocolName, buffer_1.Buffer.alloc(0));\n        }\n    }\n    split(ss) {\n        const [tempk1, tempk2] = utils_1.getHkdf(ss.ck, buffer_1.Buffer.alloc(0));\n        const cs1 = this.initializeKey(tempk1);\n        const cs2 = this.initializeKey(tempk2);\n        return { cs1, cs2 };\n    }\n    writeMessageRegular(cs, payload) {\n        const ciphertext = this.encryptWithAd(cs, buffer_1.Buffer.alloc(0), payload);\n        const ne = this.createEmptyKey();\n        const ns = buffer_1.Buffer.alloc(0);\n        return { ne, ns, ciphertext };\n    }\n    readMessageRegular(cs, message) {\n        return this.decryptWithAd(cs, buffer_1.Buffer.alloc(0), message.ciphertext);\n    }\n}\nexports.AbstractHandshake = AbstractHandshake;\n//# sourceMappingURL=abstract-handshake.js.map"]},"metadata":{},"sourceType":"script"}