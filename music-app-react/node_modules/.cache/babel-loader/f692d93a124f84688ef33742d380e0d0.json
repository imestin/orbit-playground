{"ast":null,"code":"'use strict';\n\nconst importer = require('ipfs-unixfs-importer');\n\nconst normaliseAddInput = require('ipfs-core-utils/src/files/normalise-input');\n\nconst {\n  parseChunkerString\n} = require('./utils');\n\nconst {\n  pipe\n} = require('it-pipe');\n\nconst {\n  withTimeoutOption\n} = require('../../utils');\n/**\n * @typedef {Uint8Array | Blob | String | Iterable<Uint8Array> | Iterable<number> | AsyncIterable<Uint8Array> | ReadableStream<Uint8Array>} FileContent\n *\n * @typedef {object} FileObject\n *  - If no path is specified, then the item will be added to the root level and will be given a name according to it's CID.\n *  - If no content is passed, then the item is treated as an empty directory.\n *  - One of path or content must be passed.\n * @property {string} [path] - The path you want to the file to be accessible at from the root CID _after_ it has been added\n * @property {FileContent} [content] - The contents of the file\n * @property {number | string} [mode] - File mode to store the entry with (see https://en.wikipedia.org/wiki/File_system_permissions#Numeric_notation)\n * @property {UnixTime} [mtime] - The modification time of the entry\n *\n * @typedef {FileContent | FileObject} Source\n * @typedef {Iterable<Source> | AsyncIterable<Source> | ReadableStream<Source>} FileStream\n *\n * @typedef {Date | UnixTimeObj | [number, number]} UnixTime - As an array of numbers, it must have two elements, as per the output of [`process.hrtime()`](https://nodejs.org/dist/latest/docs/api/process.html#process_process_hrtime_time).\n *\n * @typedef {object} UnixTimeObj\n * @property {number} secs - the number of seconds since (positive) or before (negative) the Unix Epoch began\n * @property {number} [nsecs] - the number of nanoseconds since the last full second.\n *\n * @typedef {object} UnixFSEntry\n * @property {string} path\n * @property {import('cids')} cid\n * @property {number} mode\n * @property {UnixTimeObj} mtime\n * @property {number} size\n */\n\n/**\n * @typedef {import('../add').AddOptions & _AddAllOptions} AddAllOptions\n * @typedef {object} _AddAllOptions\n * @property {boolean} [enableShardingExperiment] - allows to create directories with an unlimited number of entries currently size of unixfs directories is limited by the maximum block size. Note that this is an experimental feature (default: `false`)\n * @property {number} [shardSplitThreshold] - Directories with more than this number of files will be created as HAMT-sharded directories (default: `1000`)\n */\n\n/**\n * Import multiple files and data into IPFS.\n * @template {Record<string, any>} ExtraOptions\n * @callback AddAll\n * @param {FileStream} source\n * @param {AddAllOptions & import('../../utils').AbortOptions & ExtraOptions} [options]\n * @returns {AsyncIterable<UnixFSEntry>}\n */\n\n\nmodule.exports = ({\n  block,\n  gcLock,\n  preload,\n  pin,\n  options: constructorOptions\n}) => {\n  const isShardingEnabled = constructorOptions.EXPERIMENTAL && constructorOptions.EXPERIMENTAL.sharding; // eslint-disable-next-line valid-jsdoc\n\n  /**\n   * @type {AddAll<{}>}\n   */\n\n  async function* addAll(source, options) {\n    options = options || {};\n    const opts = {\n      shardSplitThreshold: isShardingEnabled ? 1000 : Infinity,\n      ...options,\n      strategy: 'balanced',\n      ...parseChunkerString(options.chunker)\n    }; // CID v0 is for multihashes encoded with sha2-256\n\n    if (opts.hashAlg && opts.hashAlg !== 'sha2-256' && opts.cidVersion !== 1) {\n      opts.cidVersion = 1;\n    }\n\n    if (opts.trickle) {\n      opts.strategy = 'trickle';\n    }\n\n    delete opts.trickle;\n\n    if (opts.progress) {\n      let total = 0;\n      const prog = opts.progress;\n\n      opts.progress = bytes => {\n        total += bytes;\n        prog(total);\n      };\n    }\n\n    const iterator = pipe(normaliseAddInput(source), source => importer(source, block, { ...opts,\n      pin: false\n    }), transformFile(opts), preloadFile(preload, opts), pinFile(pin, opts));\n    const releaseLock = await gcLock.readLock();\n\n    try {\n      yield* iterator;\n    } finally {\n      releaseLock();\n    }\n  }\n\n  return withTimeoutOption(addAll);\n};\n\nfunction transformFile(opts) {\n  return async function* (source) {\n    for await (const file of source) {\n      let cid = file.cid;\n\n      if (opts.cidVersion === 1) {\n        cid = cid.toV1();\n      }\n\n      let path = file.path ? file.path : cid.toString();\n\n      if (opts.wrapWithDirectory && !file.path) {\n        path = '';\n      }\n\n      yield {\n        path,\n        cid,\n        size: file.size,\n        mode: file.unixfs && file.unixfs.mode,\n        mtime: file.unixfs && file.unixfs.mtime\n      };\n    }\n  };\n}\n\nfunction preloadFile(preload, opts) {\n  return async function* (source) {\n    for await (const file of source) {\n      const isRootFile = !file.path || opts.wrapWithDirectory ? file.path === '' : !file.path.includes('/');\n      const shouldPreload = isRootFile && !opts.onlyHash && opts.preload !== false;\n\n      if (shouldPreload) {\n        preload(file.cid);\n      }\n\n      yield file;\n    }\n  };\n}\n\nfunction pinFile(pin, opts) {\n  return async function* (source) {\n    for await (const file of source) {\n      // Pin a file if it is the root dir of a recursive add or the single file\n      // of a direct add.\n      const isRootDir = !file.path.includes('/');\n      const shouldPin = (opts.pin == null ? true : opts.pin) && isRootDir && !opts.onlyHash;\n\n      if (shouldPin) {\n        // Note: addAsyncIterator() has already taken a GC lock, so tell\n        // pin.add() not to take a (second) GC lock\n        await pin.add(file.cid, {\n          preload: false,\n          lock: false\n        });\n      }\n\n      yield file;\n    }\n  };\n}","map":{"version":3,"sources":["/home/user/orbit-playground/music-app/node_modules/ipfs/src/core/components/add-all/index.js"],"names":["importer","require","normaliseAddInput","parseChunkerString","pipe","withTimeoutOption","module","exports","block","gcLock","preload","pin","options","constructorOptions","isShardingEnabled","EXPERIMENTAL","sharding","addAll","source","opts","shardSplitThreshold","Infinity","strategy","chunker","hashAlg","cidVersion","trickle","progress","total","prog","bytes","iterator","transformFile","preloadFile","pinFile","releaseLock","readLock","file","cid","toV1","path","toString","wrapWithDirectory","size","mode","unixfs","mtime","isRootFile","includes","shouldPreload","onlyHash","isRootDir","shouldPin","add","lock"],"mappings":"AAAA;;AAEA,MAAMA,QAAQ,GAAGC,OAAO,CAAC,sBAAD,CAAxB;;AACA,MAAMC,iBAAiB,GAAGD,OAAO,CAAC,2CAAD,CAAjC;;AACA,MAAM;AAAEE,EAAAA;AAAF,IAAyBF,OAAO,CAAC,SAAD,CAAtC;;AACA,MAAM;AAAEG,EAAAA;AAAF,IAAWH,OAAO,CAAC,SAAD,CAAxB;;AACA,MAAM;AAAEI,EAAAA;AAAF,IAAwBJ,OAAO,CAAC,aAAD,CAArC;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6BA;;;;;;;AAOA;;;;;;;;;;AASAK,MAAM,CAACC,OAAP,GAAiB,CAAC;AAAEC,EAAAA,KAAF;AAASC,EAAAA,MAAT;AAAiBC,EAAAA,OAAjB;AAA0BC,EAAAA,GAA1B;AAA+BC,EAAAA,OAAO,EAAEC;AAAxC,CAAD,KAAkE;AACjF,QAAMC,iBAAiB,GAAGD,kBAAkB,CAACE,YAAnB,IAAmCF,kBAAkB,CAACE,YAAnB,CAAgCC,QAA7F,CADiF,CAGjF;;AACA;;;;AAGA,kBAAiBC,MAAjB,CAAyBC,MAAzB,EAAiCN,OAAjC,EAA0C;AACxCA,IAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;AAEA,UAAMO,IAAI,GAAG;AACXC,MAAAA,mBAAmB,EAAEN,iBAAiB,GAAG,IAAH,GAAUO,QADrC;AAEX,SAAGT,OAFQ;AAGXU,MAAAA,QAAQ,EAAE,UAHC;AAIX,SAAGnB,kBAAkB,CAACS,OAAO,CAACW,OAAT;AAJV,KAAb,CAHwC,CAUxC;;AACA,QAAIJ,IAAI,CAACK,OAAL,IAAgBL,IAAI,CAACK,OAAL,KAAiB,UAAjC,IAA+CL,IAAI,CAACM,UAAL,KAAoB,CAAvE,EAA0E;AACxEN,MAAAA,IAAI,CAACM,UAAL,GAAkB,CAAlB;AACD;;AAED,QAAIN,IAAI,CAACO,OAAT,EAAkB;AAChBP,MAAAA,IAAI,CAACG,QAAL,GAAgB,SAAhB;AACD;;AAED,WAAOH,IAAI,CAACO,OAAZ;;AAEA,QAAIP,IAAI,CAACQ,QAAT,EAAmB;AACjB,UAAIC,KAAK,GAAG,CAAZ;AACA,YAAMC,IAAI,GAAGV,IAAI,CAACQ,QAAlB;;AAEAR,MAAAA,IAAI,CAACQ,QAAL,GAAiBG,KAAD,IAAW;AACzBF,QAAAA,KAAK,IAAIE,KAAT;AACAD,QAAAA,IAAI,CAACD,KAAD,CAAJ;AACD,OAHD;AAID;;AAED,UAAMG,QAAQ,GAAG3B,IAAI,CACnBF,iBAAiB,CAACgB,MAAD,CADE,EAEnBA,MAAM,IAAIlB,QAAQ,CAACkB,MAAD,EAASV,KAAT,EAAgB,EAChC,GAAGW,IAD6B;AAEhCR,MAAAA,GAAG,EAAE;AAF2B,KAAhB,CAFC,EAMnBqB,aAAa,CAACb,IAAD,CANM,EAOnBc,WAAW,CAACvB,OAAD,EAAUS,IAAV,CAPQ,EAQnBe,OAAO,CAACvB,GAAD,EAAMQ,IAAN,CARY,CAArB;AAWA,UAAMgB,WAAW,GAAG,MAAM1B,MAAM,CAAC2B,QAAP,EAA1B;;AAEA,QAAI;AACF,aAAQL,QAAR;AACD,KAFD,SAEU;AACRI,MAAAA,WAAW;AACZ;AACF;;AAED,SAAO9B,iBAAiB,CAACY,MAAD,CAAxB;AACD,CA3DD;;AA6DA,SAASe,aAAT,CAAwBb,IAAxB,EAA8B;AAC5B,SAAO,iBAAkBD,MAAlB,EAA0B;AAC/B,eAAW,MAAMmB,IAAjB,IAAyBnB,MAAzB,EAAiC;AAC/B,UAAIoB,GAAG,GAAGD,IAAI,CAACC,GAAf;;AAEA,UAAInB,IAAI,CAACM,UAAL,KAAoB,CAAxB,EAA2B;AACzBa,QAAAA,GAAG,GAAGA,GAAG,CAACC,IAAJ,EAAN;AACD;;AAED,UAAIC,IAAI,GAAGH,IAAI,CAACG,IAAL,GAAYH,IAAI,CAACG,IAAjB,GAAwBF,GAAG,CAACG,QAAJ,EAAnC;;AAEA,UAAItB,IAAI,CAACuB,iBAAL,IAA0B,CAACL,IAAI,CAACG,IAApC,EAA0C;AACxCA,QAAAA,IAAI,GAAG,EAAP;AACD;;AAED,YAAM;AACJA,QAAAA,IADI;AAEJF,QAAAA,GAFI;AAGJK,QAAAA,IAAI,EAAEN,IAAI,CAACM,IAHP;AAIJC,QAAAA,IAAI,EAAEP,IAAI,CAACQ,MAAL,IAAeR,IAAI,CAACQ,MAAL,CAAYD,IAJ7B;AAKJE,QAAAA,KAAK,EAAET,IAAI,CAACQ,MAAL,IAAeR,IAAI,CAACQ,MAAL,CAAYC;AAL9B,OAAN;AAOD;AACF,GAtBD;AAuBD;;AAED,SAASb,WAAT,CAAsBvB,OAAtB,EAA+BS,IAA/B,EAAqC;AACnC,SAAO,iBAAkBD,MAAlB,EAA0B;AAC/B,eAAW,MAAMmB,IAAjB,IAAyBnB,MAAzB,EAAiC;AAC/B,YAAM6B,UAAU,GAAG,CAACV,IAAI,CAACG,IAAN,IAAcrB,IAAI,CAACuB,iBAAnB,GACfL,IAAI,CAACG,IAAL,KAAc,EADC,GAEf,CAACH,IAAI,CAACG,IAAL,CAAUQ,QAAV,CAAmB,GAAnB,CAFL;AAIA,YAAMC,aAAa,GAAGF,UAAU,IAAI,CAAC5B,IAAI,CAAC+B,QAApB,IAAgC/B,IAAI,CAACT,OAAL,KAAiB,KAAvE;;AAEA,UAAIuC,aAAJ,EAAmB;AACjBvC,QAAAA,OAAO,CAAC2B,IAAI,CAACC,GAAN,CAAP;AACD;;AAED,YAAMD,IAAN;AACD;AACF,GAdD;AAeD;;AAED,SAASH,OAAT,CAAkBvB,GAAlB,EAAuBQ,IAAvB,EAA6B;AAC3B,SAAO,iBAAkBD,MAAlB,EAA0B;AAC/B,eAAW,MAAMmB,IAAjB,IAAyBnB,MAAzB,EAAiC;AAC/B;AACA;AACA,YAAMiC,SAAS,GAAG,CAACd,IAAI,CAACG,IAAL,CAAUQ,QAAV,CAAmB,GAAnB,CAAnB;AACA,YAAMI,SAAS,GAAG,CAACjC,IAAI,CAACR,GAAL,IAAY,IAAZ,GAAmB,IAAnB,GAA0BQ,IAAI,CAACR,GAAhC,KAAwCwC,SAAxC,IAAqD,CAAChC,IAAI,CAAC+B,QAA7E;;AAEA,UAAIE,SAAJ,EAAe;AACb;AACA;AACA,cAAMzC,GAAG,CAAC0C,GAAJ,CAAQhB,IAAI,CAACC,GAAb,EAAkB;AACtB5B,UAAAA,OAAO,EAAE,KADa;AAEtB4C,UAAAA,IAAI,EAAE;AAFgB,SAAlB,CAAN;AAID;;AAED,YAAMjB,IAAN;AACD;AACF,GAlBD;AAmBD","sourcesContent":["'use strict'\n\nconst importer = require('ipfs-unixfs-importer')\nconst normaliseAddInput = require('ipfs-core-utils/src/files/normalise-input')\nconst { parseChunkerString } = require('./utils')\nconst { pipe } = require('it-pipe')\nconst { withTimeoutOption } = require('../../utils')\n\n/**\n * @typedef {Uint8Array | Blob | String | Iterable<Uint8Array> | Iterable<number> | AsyncIterable<Uint8Array> | ReadableStream<Uint8Array>} FileContent\n *\n * @typedef {object} FileObject\n *  - If no path is specified, then the item will be added to the root level and will be given a name according to it's CID.\n *  - If no content is passed, then the item is treated as an empty directory.\n *  - One of path or content must be passed.\n * @property {string} [path] - The path you want to the file to be accessible at from the root CID _after_ it has been added\n * @property {FileContent} [content] - The contents of the file\n * @property {number | string} [mode] - File mode to store the entry with (see https://en.wikipedia.org/wiki/File_system_permissions#Numeric_notation)\n * @property {UnixTime} [mtime] - The modification time of the entry\n *\n * @typedef {FileContent | FileObject} Source\n * @typedef {Iterable<Source> | AsyncIterable<Source> | ReadableStream<Source>} FileStream\n *\n * @typedef {Date | UnixTimeObj | [number, number]} UnixTime - As an array of numbers, it must have two elements, as per the output of [`process.hrtime()`](https://nodejs.org/dist/latest/docs/api/process.html#process_process_hrtime_time).\n *\n * @typedef {object} UnixTimeObj\n * @property {number} secs - the number of seconds since (positive) or before (negative) the Unix Epoch began\n * @property {number} [nsecs] - the number of nanoseconds since the last full second.\n *\n * @typedef {object} UnixFSEntry\n * @property {string} path\n * @property {import('cids')} cid\n * @property {number} mode\n * @property {UnixTimeObj} mtime\n * @property {number} size\n */\n\n/**\n * @typedef {import('../add').AddOptions & _AddAllOptions} AddAllOptions\n * @typedef {object} _AddAllOptions\n * @property {boolean} [enableShardingExperiment] - allows to create directories with an unlimited number of entries currently size of unixfs directories is limited by the maximum block size. Note that this is an experimental feature (default: `false`)\n * @property {number} [shardSplitThreshold] - Directories with more than this number of files will be created as HAMT-sharded directories (default: `1000`)\n */\n\n/**\n * Import multiple files and data into IPFS.\n * @template {Record<string, any>} ExtraOptions\n * @callback AddAll\n * @param {FileStream} source\n * @param {AddAllOptions & import('../../utils').AbortOptions & ExtraOptions} [options]\n * @returns {AsyncIterable<UnixFSEntry>}\n */\n\nmodule.exports = ({ block, gcLock, preload, pin, options: constructorOptions }) => {\n  const isShardingEnabled = constructorOptions.EXPERIMENTAL && constructorOptions.EXPERIMENTAL.sharding\n\n  // eslint-disable-next-line valid-jsdoc\n  /**\n   * @type {AddAll<{}>}\n   */\n  async function * addAll (source, options) {\n    options = options || {}\n\n    const opts = {\n      shardSplitThreshold: isShardingEnabled ? 1000 : Infinity,\n      ...options,\n      strategy: 'balanced',\n      ...parseChunkerString(options.chunker)\n    }\n\n    // CID v0 is for multihashes encoded with sha2-256\n    if (opts.hashAlg && opts.hashAlg !== 'sha2-256' && opts.cidVersion !== 1) {\n      opts.cidVersion = 1\n    }\n\n    if (opts.trickle) {\n      opts.strategy = 'trickle'\n    }\n\n    delete opts.trickle\n\n    if (opts.progress) {\n      let total = 0\n      const prog = opts.progress\n\n      opts.progress = (bytes) => {\n        total += bytes\n        prog(total)\n      }\n    }\n\n    const iterator = pipe(\n      normaliseAddInput(source),\n      source => importer(source, block, {\n        ...opts,\n        pin: false\n      }),\n      transformFile(opts),\n      preloadFile(preload, opts),\n      pinFile(pin, opts)\n    )\n\n    const releaseLock = await gcLock.readLock()\n\n    try {\n      yield * iterator\n    } finally {\n      releaseLock()\n    }\n  }\n\n  return withTimeoutOption(addAll)\n}\n\nfunction transformFile (opts) {\n  return async function * (source) {\n    for await (const file of source) {\n      let cid = file.cid\n\n      if (opts.cidVersion === 1) {\n        cid = cid.toV1()\n      }\n\n      let path = file.path ? file.path : cid.toString()\n\n      if (opts.wrapWithDirectory && !file.path) {\n        path = ''\n      }\n\n      yield {\n        path,\n        cid,\n        size: file.size,\n        mode: file.unixfs && file.unixfs.mode,\n        mtime: file.unixfs && file.unixfs.mtime\n      }\n    }\n  }\n}\n\nfunction preloadFile (preload, opts) {\n  return async function * (source) {\n    for await (const file of source) {\n      const isRootFile = !file.path || opts.wrapWithDirectory\n        ? file.path === ''\n        : !file.path.includes('/')\n\n      const shouldPreload = isRootFile && !opts.onlyHash && opts.preload !== false\n\n      if (shouldPreload) {\n        preload(file.cid)\n      }\n\n      yield file\n    }\n  }\n}\n\nfunction pinFile (pin, opts) {\n  return async function * (source) {\n    for await (const file of source) {\n      // Pin a file if it is the root dir of a recursive add or the single file\n      // of a direct add.\n      const isRootDir = !file.path.includes('/')\n      const shouldPin = (opts.pin == null ? true : opts.pin) && isRootDir && !opts.onlyHash\n\n      if (shouldPin) {\n        // Note: addAsyncIterator() has already taken a GC lock, so tell\n        // pin.add() not to take a (second) GC lock\n        await pin.add(file.cid, {\n          preload: false,\n          lock: false\n        })\n      }\n\n      yield file\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}