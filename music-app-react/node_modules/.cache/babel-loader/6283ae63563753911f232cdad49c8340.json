{"ast":null,"code":"'use strict';\n\nconst path = require('path');\n\nconst CID = require('cids');\n\nconst notEmpty = e => e !== '' && e !== ' ';\n\nclass OrbitDBAddress {\n  constructor(root, path) {\n    this.root = root;\n    this.path = path;\n  }\n\n  toString() {\n    return OrbitDBAddress.join(this.root, this.path);\n  }\n\n  static isValid(address) {\n    address = address.toString().replace(/\\\\/g, '/');\n\n    const containsProtocolPrefix = (e, i) => !((i === 0 || i === 1) && address.toString().indexOf('/orbit') === 0 && e === 'orbitdb');\n\n    const parts = address.toString().split('/').filter(containsProtocolPrefix).filter(notEmpty);\n    let accessControllerHash;\n\n    const validateHash = hash => {\n      const prefixes = ['zd', 'Qm', 'ba', 'k5'];\n\n      for (const p of prefixes) {\n        if (hash.indexOf(p) > -1) {\n          return true;\n        }\n      }\n\n      return false;\n    };\n\n    try {\n      accessControllerHash = validateHash(parts[0]) ? new CID(parts[0]).toBaseEncodedString() : null;\n    } catch (e) {\n      return false;\n    }\n\n    return accessControllerHash !== null;\n  }\n\n  static parse(address) {\n    if (!address) {\n      throw new Error(`Not a valid OrbitDB address: ${address}`);\n    }\n\n    if (!OrbitDBAddress.isValid(address)) {\n      throw new Error(`Not a valid OrbitDB address: ${address}`);\n    }\n\n    address = address.toString().replace(/\\\\/g, '/');\n    const parts = address.toString().split('/').filter((e, i) => !((i === 0 || i === 1) && address.toString().indexOf('/orbit') === 0 && e === 'orbitdb')).filter(e => e !== '' && e !== ' ');\n    return new OrbitDBAddress(parts[0], parts.slice(1, parts.length).join('/'));\n  }\n\n  static join(...paths) {\n    return (path.posix || path).join('/orbitdb', ...paths);\n  }\n\n}\n\nmodule.exports = OrbitDBAddress;","map":{"version":3,"sources":["/home/user/orbit-playground/music-app/node_modules/orbit-db/src/orbit-db-address.js"],"names":["path","require","CID","notEmpty","e","OrbitDBAddress","constructor","root","toString","join","isValid","address","replace","containsProtocolPrefix","i","indexOf","parts","split","filter","accessControllerHash","validateHash","hash","prefixes","p","toBaseEncodedString","parse","Error","slice","length","paths","posix","module","exports"],"mappings":"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","sourcesContent":["'use strict'\nconst path = require('path')\nconst CID = require('cids')\n\nconst notEmpty = e => e !== '' && e !== ' '\n\nclass OrbitDBAddress {\n  constructor (root, path) {\n    this.root = root\n    this.path = path\n  }\n\n  toString () {\n    return OrbitDBAddress.join(this.root, this.path)\n  }\n\n  static isValid (address) {\n    address = address.toString().replace(/\\\\/g, '/')\n\n    const containsProtocolPrefix = (e, i) => !((i === 0 || i === 1) && address.toString().indexOf('/orbit') === 0 && e === 'orbitdb')\n\n    const parts = address.toString()\n      .split('/')\n      .filter(containsProtocolPrefix)\n      .filter(notEmpty)\n\n    let accessControllerHash\n\n    const validateHash = (hash) => {\n      const prefixes = ['zd', 'Qm', 'ba', 'k5']\n      for (const p of prefixes) {\n        if (hash.indexOf(p) > -1) {\n          return true\n        }\n      }\n      return false\n    }\n\n    try {\n      accessControllerHash = validateHash(parts[0])\n        ? new CID(parts[0]).toBaseEncodedString()\n        : null\n    } catch (e) {\n      return false\n    }\n\n    return accessControllerHash !== null\n  }\n\n  static parse (address) {\n    if (!address) { throw new Error(`Not a valid OrbitDB address: ${address}`) }\n\n    if (!OrbitDBAddress.isValid(address)) { throw new Error(`Not a valid OrbitDB address: ${address}`) }\n\n    address = address.toString().replace(/\\\\/g, '/')\n\n    const parts = address.toString()\n      .split('/')\n      .filter((e, i) => !((i === 0 || i === 1) && address.toString().indexOf('/orbit') === 0 && e === 'orbitdb'))\n      .filter(e => e !== '' && e !== ' ')\n\n    return new OrbitDBAddress(parts[0], parts.slice(1, parts.length).join('/'))\n  }\n\n  static join (...paths) {\n    return (path.posix || path).join('/orbitdb', ...paths)\n  }\n}\n\nmodule.exports = OrbitDBAddress\n"]},"metadata":{},"sourceType":"script"}