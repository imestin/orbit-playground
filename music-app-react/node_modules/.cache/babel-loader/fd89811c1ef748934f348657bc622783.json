{"ast":null,"code":"/*\n * Id is an object representation of a peer Id. a peer Id is a multihash\n */\n'use strict';\n\nconst mh = require('multihashes');\n\nconst CID = require('cids');\n\nconst cryptoKeys = require('libp2p-crypto/src/keys');\n\nconst withIs = require('class-is');\n\nconst {\n  PeerIdProto\n} = require('./proto');\n\nconst uint8ArrayEquals = require('uint8arrays/equals');\n\nconst uint8ArrayFromString = require('uint8arrays/from-string');\n\nconst uint8ArrayToString = require('uint8arrays/to-string');\n\nclass PeerId {\n  constructor(id, privKey, pubKey) {\n    if (!(id instanceof Uint8Array)) {\n      throw new Error('invalid id provided');\n    }\n\n    if (privKey && pubKey && !uint8ArrayEquals(privKey.public.bytes, pubKey.bytes)) {\n      throw new Error('inconsistent arguments');\n    }\n\n    this._id = id;\n    this._idB58String = mh.toB58String(this.id);\n    this._privKey = privKey;\n    this._pubKey = pubKey;\n  }\n\n  get id() {\n    return this._id;\n  }\n\n  set id(val) {\n    throw new Error('Id is immutable');\n  }\n\n  get privKey() {\n    return this._privKey;\n  }\n\n  set privKey(privKey) {\n    this._privKey = privKey;\n  }\n\n  get pubKey() {\n    if (this._pubKey) {\n      return this._pubKey;\n    }\n\n    if (this._privKey) {\n      return this._privKey.public;\n    }\n\n    try {\n      const decoded = mh.decode(this.id);\n\n      if (decoded.name === 'identity') {\n        this._pubKey = cryptoKeys.unmarshalPublicKey(decoded.digest);\n      }\n    } catch (_) {// Ignore, there is no valid public key\n    }\n\n    return this._pubKey;\n  }\n\n  set pubKey(pubKey) {\n    this._pubKey = pubKey;\n  } // Return the protobuf version of the public key, matching go ipfs formatting\n\n\n  marshalPubKey() {\n    if (this.pubKey) {\n      return cryptoKeys.marshalPublicKey(this.pubKey);\n    }\n  } // Return the protobuf version of the private key, matching go ipfs formatting\n\n\n  marshalPrivKey() {\n    if (this.privKey) {\n      return cryptoKeys.marshalPrivateKey(this.privKey);\n    }\n  } // Return the protobuf version of the peer-id\n\n\n  marshal(excludePriv) {\n    return PeerIdProto.encode({\n      id: this.toBytes(),\n      pubKey: this.marshalPubKey(),\n      privKey: excludePriv ? null : this.marshalPrivKey()\n    });\n  }\n\n  toPrint() {\n    let pid = this.toB58String(); // All sha256 nodes start with Qm\n    // We can skip the Qm to make the peer.ID more useful\n\n    if (pid.startsWith('Qm')) {\n      pid = pid.slice(2);\n    }\n\n    let maxRunes = 6;\n\n    if (pid.length < maxRunes) {\n      maxRunes = pid.length;\n    }\n\n    return '<peer.ID ' + pid.substr(0, maxRunes) + '>';\n  } // return the jsonified version of the key, matching the formatting\n  // of go-ipfs for its config file\n\n\n  toJSON() {\n    return {\n      id: this.toB58String(),\n      privKey: toB64Opt(this.marshalPrivKey()),\n      pubKey: toB64Opt(this.marshalPubKey())\n    };\n  } // encode/decode functions\n\n\n  toHexString() {\n    return mh.toHexString(this.id);\n  }\n\n  toBytes() {\n    return this.id;\n  }\n\n  toB58String() {\n    return this._idB58String;\n  } // return self-describing String representation\n  // in default format from RFC 0001: https://github.com/libp2p/specs/pull/209\n\n\n  toString() {\n    if (!this._idCIDString) {\n      const cid = new CID(1, 'libp2p-key', this.id, 'base32');\n      this._idCIDString = cid.toBaseEncodedString('base32');\n    }\n\n    return this._idCIDString;\n  }\n  /**\n   * Checks the equality of `this` peer against a given PeerId.\n   * @param {Uint8Array|PeerId} id\n   * @returns {boolean}\n   */\n\n\n  equals(id) {\n    if (id instanceof Uint8Array) {\n      return uint8ArrayEquals(this.id, id);\n    } else if (id.id) {\n      return uint8ArrayEquals(this.id, id.id);\n    } else {\n      throw new Error('not valid Id');\n    }\n  }\n  /**\n   * Checks the equality of `this` peer against a given PeerId.\n   * @deprecated Use `.equals`\n   * @param {Uint8Array|PeerId} id\n   * @returns {boolean}\n   */\n\n\n  isEqual(id) {\n    return this.equals(id);\n  }\n  /*\n   * Check if this PeerId instance is valid (privKey -> pubKey -> Id)\n   */\n\n\n  isValid() {\n    // TODO: needs better checking\n    return Boolean(this.privKey && this.privKey.public && this.privKey.public.bytes && this.pubKey.bytes instanceof Uint8Array && uint8ArrayEquals(this.privKey.public.bytes, this.pubKey.bytes));\n  }\n  /**\n   * Check if the PeerId has an inline public key.\n   * @returns {boolean}\n   */\n\n\n  hasInlinePublicKey() {\n    try {\n      const decoded = mh.decode(this.id);\n\n      if (decoded.name === 'identity') {\n        return true;\n      }\n    } catch (_) {// Ignore, there is no valid public key\n    }\n\n    return false;\n  }\n\n}\n\nconst PeerIdWithIs = withIs(PeerId, {\n  className: 'PeerId',\n  symbolName: '@libp2p/js-peer-id/PeerId'\n});\nexports = module.exports = PeerIdWithIs;\n\nconst computeDigest = pubKey => {\n  if (pubKey.bytes.length <= 42) {\n    return mh.encode(pubKey.bytes, 'identity');\n  } else {\n    return pubKey.hash();\n  }\n};\n\nconst computePeerId = async (privKey, pubKey) => {\n  const digest = await computeDigest(pubKey);\n  return new PeerIdWithIs(digest, privKey, pubKey);\n}; // generation\n\n\nexports.create = async opts => {\n  opts = opts || {};\n  opts.bits = opts.bits || 2048;\n  opts.keyType = opts.keyType || 'RSA';\n  const key = await cryptoKeys.generateKeyPair(opts.keyType, opts.bits);\n  return computePeerId(key, key.public);\n};\n\nexports.createFromHexString = str => {\n  return new PeerIdWithIs(mh.fromHexString(str));\n};\n\nexports.createFromBytes = buf => {\n  return new PeerIdWithIs(buf);\n};\n\nexports.createFromB58String = str => {\n  return exports.createFromCID(str); // B58String is CIDv0\n};\n\nconst validMulticodec = cid => {\n  // supported: 'libp2p-key' (CIDv1) and 'dag-pb' (CIDv0 converted to CIDv1)\n  return cid.codec === 'libp2p-key' || cid.codec === 'dag-pb';\n};\n\nexports.createFromCID = cid => {\n  cid = CID.isCID(cid) ? cid : new CID(cid);\n  if (!validMulticodec(cid)) throw new Error('Supplied PeerID CID has invalid multicodec: ' + cid.codec);\n  return new PeerIdWithIs(cid.multihash);\n}; // Public Key input will be a Uint8Array\n\n\nexports.createFromPubKey = async key => {\n  let buf = key;\n\n  if (typeof buf === 'string') {\n    buf = uint8ArrayFromString(key, 'base64pad');\n  }\n\n  if (!(buf instanceof Uint8Array)) {\n    throw new Error('Supplied key is neither a base64 string nor a Uint8Array');\n  }\n\n  const pubKey = await cryptoKeys.unmarshalPublicKey(buf);\n  return computePeerId(null, pubKey);\n}; // Private key input will be a string\n\n\nexports.createFromPrivKey = async key => {\n  if (typeof key === 'string') {\n    key = uint8ArrayFromString(key, 'base64pad');\n  }\n\n  if (!(key instanceof Uint8Array)) {\n    throw new Error('Supplied key is neither a base64 string nor a Uint8Array');\n  }\n\n  const privKey = await cryptoKeys.unmarshalPrivateKey(key);\n  return computePeerId(privKey, privKey.public);\n};\n\nexports.createFromJSON = async obj => {\n  const id = mh.fromB58String(obj.id);\n  const rawPrivKey = obj.privKey && uint8ArrayFromString(obj.privKey, 'base64pad');\n  const rawPubKey = obj.pubKey && uint8ArrayFromString(obj.pubKey, 'base64pad');\n  const pub = rawPubKey && (await cryptoKeys.unmarshalPublicKey(rawPubKey));\n\n  if (!rawPrivKey) {\n    return new PeerIdWithIs(id, null, pub);\n  }\n\n  const privKey = await cryptoKeys.unmarshalPrivateKey(rawPrivKey);\n  const privDigest = await computeDigest(privKey.public);\n  let pubDigest;\n\n  if (pub) {\n    pubDigest = await computeDigest(pub);\n  }\n\n  if (pub && !uint8ArrayEquals(privDigest, pubDigest)) {\n    throw new Error('Public and private key do not match');\n  }\n\n  if (id && !uint8ArrayEquals(privDigest, id)) {\n    throw new Error('Id and private key do not match');\n  }\n\n  return new PeerIdWithIs(id, privKey, pub);\n};\n\nexports.createFromProtobuf = async buf => {\n  if (typeof buf === 'string') {\n    buf = uint8ArrayFromString(buf, 'base16');\n  }\n\n  let {\n    id,\n    privKey,\n    pubKey\n  } = PeerIdProto.decode(buf);\n  privKey = privKey ? await cryptoKeys.unmarshalPrivateKey(privKey) : false;\n  pubKey = pubKey ? await cryptoKeys.unmarshalPublicKey(pubKey) : false;\n  let pubDigest;\n  let privDigest;\n\n  if (privKey) {\n    privDigest = await computeDigest(privKey.public);\n  }\n\n  if (pubKey) {\n    pubDigest = await computeDigest(pubKey);\n  }\n\n  if (privKey) {\n    if (pubKey) {\n      if (!uint8ArrayEquals(privDigest, pubDigest)) {\n        throw new Error('Public and private key do not match');\n      }\n    }\n\n    return new PeerIdWithIs(privDigest, privKey, privKey.public);\n  } // TODO: val id and pubDigest\n\n\n  if (pubKey) {\n    return new PeerIdWithIs(pubDigest, null, pubKey);\n  }\n\n  if (id) {\n    return new PeerIdWithIs(id);\n  }\n\n  throw new Error('Protobuf did not contain any usable key material');\n};\n\nexports.isPeerId = peerId => {\n  return Boolean(typeof peerId === 'object' && peerId._id && peerId._idB58String);\n};\n\nfunction toB64Opt(val) {\n  if (val) {\n    return uint8ArrayToString(val, 'base64pad');\n  }\n}","map":{"version":3,"sources":["/home/user/orbit-playground/music-app-react/node_modules/peer-id/src/index.js"],"names":["mh","require","CID","cryptoKeys","withIs","PeerIdProto","uint8ArrayEquals","uint8ArrayFromString","uint8ArrayToString","PeerId","constructor","id","privKey","pubKey","Uint8Array","Error","public","bytes","_id","_idB58String","toB58String","_privKey","_pubKey","val","decoded","decode","name","unmarshalPublicKey","digest","_","marshalPubKey","marshalPublicKey","marshalPrivKey","marshalPrivateKey","marshal","excludePriv","encode","toBytes","toPrint","pid","startsWith","slice","maxRunes","length","substr","toJSON","toB64Opt","toHexString","toString","_idCIDString","cid","toBaseEncodedString","equals","isEqual","isValid","Boolean","hasInlinePublicKey","PeerIdWithIs","className","symbolName","exports","module","computeDigest","hash","computePeerId","create","opts","bits","keyType","key","generateKeyPair","createFromHexString","str","fromHexString","createFromBytes","buf","createFromB58String","createFromCID","validMulticodec","codec","isCID","multihash","createFromPubKey","createFromPrivKey","unmarshalPrivateKey","createFromJSON","obj","fromB58String","rawPrivKey","rawPubKey","pub","privDigest","pubDigest","createFromProtobuf","isPeerId","peerId"],"mappings":"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","sourcesContent":["/*\n * Id is an object representation of a peer Id. a peer Id is a multihash\n */\n\n'use strict'\n\nconst mh = require('multihashes')\nconst CID = require('cids')\nconst cryptoKeys = require('libp2p-crypto/src/keys')\nconst withIs = require('class-is')\nconst { PeerIdProto } = require('./proto')\nconst uint8ArrayEquals = require('uint8arrays/equals')\nconst uint8ArrayFromString = require('uint8arrays/from-string')\nconst uint8ArrayToString = require('uint8arrays/to-string')\n\nclass PeerId {\n  constructor (id, privKey, pubKey) {\n    if (!(id instanceof Uint8Array)) {\n      throw new Error('invalid id provided')\n    }\n\n    if (privKey && pubKey && !uint8ArrayEquals(privKey.public.bytes, pubKey.bytes)) {\n      throw new Error('inconsistent arguments')\n    }\n\n    this._id = id\n    this._idB58String = mh.toB58String(this.id)\n    this._privKey = privKey\n    this._pubKey = pubKey\n  }\n\n  get id () {\n    return this._id\n  }\n\n  set id (val) {\n    throw new Error('Id is immutable')\n  }\n\n  get privKey () {\n    return this._privKey\n  }\n\n  set privKey (privKey) {\n    this._privKey = privKey\n  }\n\n  get pubKey () {\n    if (this._pubKey) {\n      return this._pubKey\n    }\n\n    if (this._privKey) {\n      return this._privKey.public\n    }\n\n    try {\n      const decoded = mh.decode(this.id)\n\n      if (decoded.name === 'identity') {\n        this._pubKey = cryptoKeys.unmarshalPublicKey(decoded.digest)\n      }\n    } catch (_) {\n      // Ignore, there is no valid public key\n    }\n\n    return this._pubKey\n  }\n\n  set pubKey (pubKey) {\n    this._pubKey = pubKey\n  }\n\n  // Return the protobuf version of the public key, matching go ipfs formatting\n  marshalPubKey () {\n    if (this.pubKey) {\n      return cryptoKeys.marshalPublicKey(this.pubKey)\n    }\n  }\n\n  // Return the protobuf version of the private key, matching go ipfs formatting\n  marshalPrivKey () {\n    if (this.privKey) {\n      return cryptoKeys.marshalPrivateKey(this.privKey)\n    }\n  }\n\n  // Return the protobuf version of the peer-id\n  marshal (excludePriv) {\n    return PeerIdProto.encode({\n      id: this.toBytes(),\n      pubKey: this.marshalPubKey(),\n      privKey: excludePriv ? null : this.marshalPrivKey()\n    })\n  }\n\n  toPrint () {\n    let pid = this.toB58String()\n    // All sha256 nodes start with Qm\n    // We can skip the Qm to make the peer.ID more useful\n    if (pid.startsWith('Qm')) {\n      pid = pid.slice(2)\n    }\n    let maxRunes = 6\n    if (pid.length < maxRunes) {\n      maxRunes = pid.length\n    }\n\n    return '<peer.ID ' + pid.substr(0, maxRunes) + '>'\n  }\n\n  // return the jsonified version of the key, matching the formatting\n  // of go-ipfs for its config file\n  toJSON () {\n    return {\n      id: this.toB58String(),\n      privKey: toB64Opt(this.marshalPrivKey()),\n      pubKey: toB64Opt(this.marshalPubKey())\n    }\n  }\n\n  // encode/decode functions\n  toHexString () {\n    return mh.toHexString(this.id)\n  }\n\n  toBytes () {\n    return this.id\n  }\n\n  toB58String () {\n    return this._idB58String\n  }\n\n  // return self-describing String representation\n  // in default format from RFC 0001: https://github.com/libp2p/specs/pull/209\n  toString () {\n    if (!this._idCIDString) {\n      const cid = new CID(1, 'libp2p-key', this.id, 'base32')\n      this._idCIDString = cid.toBaseEncodedString('base32')\n    }\n    return this._idCIDString\n  }\n\n  /**\n   * Checks the equality of `this` peer against a given PeerId.\n   * @param {Uint8Array|PeerId} id\n   * @returns {boolean}\n   */\n  equals (id) {\n    if (id instanceof Uint8Array) {\n      return uint8ArrayEquals(this.id, id)\n    } else if (id.id) {\n      return uint8ArrayEquals(this.id, id.id)\n    } else {\n      throw new Error('not valid Id')\n    }\n  }\n\n  /**\n   * Checks the equality of `this` peer against a given PeerId.\n   * @deprecated Use `.equals`\n   * @param {Uint8Array|PeerId} id\n   * @returns {boolean}\n   */\n  isEqual (id) {\n    return this.equals(id)\n  }\n\n  /*\n   * Check if this PeerId instance is valid (privKey -> pubKey -> Id)\n   */\n  isValid () {\n    // TODO: needs better checking\n    return Boolean(this.privKey &&\n      this.privKey.public &&\n      this.privKey.public.bytes &&\n      this.pubKey.bytes instanceof Uint8Array &&\n        uint8ArrayEquals(this.privKey.public.bytes, this.pubKey.bytes))\n  }\n\n  /**\n   * Check if the PeerId has an inline public key.\n   * @returns {boolean}\n   */\n  hasInlinePublicKey () {\n    try {\n      const decoded = mh.decode(this.id)\n      if (decoded.name === 'identity') {\n        return true\n      }\n    } catch (_) {\n      // Ignore, there is no valid public key\n    }\n\n    return false\n  }\n}\n\nconst PeerIdWithIs = withIs(PeerId, {\n  className: 'PeerId',\n  symbolName: '@libp2p/js-peer-id/PeerId'\n})\n\nexports = module.exports = PeerIdWithIs\n\nconst computeDigest = (pubKey) => {\n  if (pubKey.bytes.length <= 42) {\n    return mh.encode(pubKey.bytes, 'identity')\n  } else {\n    return pubKey.hash()\n  }\n}\n\nconst computePeerId = async (privKey, pubKey) => {\n  const digest = await computeDigest(pubKey)\n  return new PeerIdWithIs(digest, privKey, pubKey)\n}\n\n// generation\nexports.create = async (opts) => {\n  opts = opts || {}\n  opts.bits = opts.bits || 2048\n  opts.keyType = opts.keyType || 'RSA'\n\n  const key = await cryptoKeys.generateKeyPair(opts.keyType, opts.bits)\n  return computePeerId(key, key.public)\n}\n\nexports.createFromHexString = (str) => {\n  return new PeerIdWithIs(mh.fromHexString(str))\n}\n\nexports.createFromBytes = (buf) => {\n  return new PeerIdWithIs(buf)\n}\n\nexports.createFromB58String = (str) => {\n  return exports.createFromCID(str) // B58String is CIDv0\n}\n\nconst validMulticodec = (cid) => {\n  // supported: 'libp2p-key' (CIDv1) and 'dag-pb' (CIDv0 converted to CIDv1)\n  return cid.codec === 'libp2p-key' || cid.codec === 'dag-pb'\n}\n\nexports.createFromCID = (cid) => {\n  cid = CID.isCID(cid) ? cid : new CID(cid)\n  if (!validMulticodec(cid)) throw new Error('Supplied PeerID CID has invalid multicodec: ' + cid.codec)\n  return new PeerIdWithIs(cid.multihash)\n}\n\n// Public Key input will be a Uint8Array\nexports.createFromPubKey = async (key) => {\n  let buf = key\n\n  if (typeof buf === 'string') {\n    buf = uint8ArrayFromString(key, 'base64pad')\n  }\n\n  if (!(buf instanceof Uint8Array)) {\n    throw new Error('Supplied key is neither a base64 string nor a Uint8Array')\n  }\n\n  const pubKey = await cryptoKeys.unmarshalPublicKey(buf)\n  return computePeerId(null, pubKey)\n}\n\n// Private key input will be a string\nexports.createFromPrivKey = async (key) => {\n  if (typeof key === 'string') {\n    key = uint8ArrayFromString(key, 'base64pad')\n  }\n\n  if (!(key instanceof Uint8Array)) {\n    throw new Error('Supplied key is neither a base64 string nor a Uint8Array')\n  }\n\n  const privKey = await cryptoKeys.unmarshalPrivateKey(key)\n  return computePeerId(privKey, privKey.public)\n}\n\nexports.createFromJSON = async (obj) => {\n  const id = mh.fromB58String(obj.id)\n  const rawPrivKey = obj.privKey && uint8ArrayFromString(obj.privKey, 'base64pad')\n  const rawPubKey = obj.pubKey && uint8ArrayFromString(obj.pubKey, 'base64pad')\n  const pub = rawPubKey && await cryptoKeys.unmarshalPublicKey(rawPubKey)\n\n  if (!rawPrivKey) {\n    return new PeerIdWithIs(id, null, pub)\n  }\n\n  const privKey = await cryptoKeys.unmarshalPrivateKey(rawPrivKey)\n  const privDigest = await computeDigest(privKey.public)\n\n  let pubDigest\n\n  if (pub) {\n    pubDigest = await computeDigest(pub)\n  }\n\n  if (pub && !uint8ArrayEquals(privDigest, pubDigest)) {\n    throw new Error('Public and private key do not match')\n  }\n\n  if (id && !uint8ArrayEquals(privDigest, id)) {\n    throw new Error('Id and private key do not match')\n  }\n\n  return new PeerIdWithIs(id, privKey, pub)\n}\n\nexports.createFromProtobuf = async (buf) => {\n  if (typeof buf === 'string') {\n    buf = uint8ArrayFromString(buf, 'base16')\n  }\n\n  let { id, privKey, pubKey } = PeerIdProto.decode(buf)\n\n  privKey = privKey ? await cryptoKeys.unmarshalPrivateKey(privKey) : false\n  pubKey = pubKey ? await cryptoKeys.unmarshalPublicKey(pubKey) : false\n\n  let pubDigest\n  let privDigest\n\n  if (privKey) {\n    privDigest = await computeDigest(privKey.public)\n  }\n\n  if (pubKey) {\n    pubDigest = await computeDigest(pubKey)\n  }\n\n  if (privKey) {\n    if (pubKey) {\n      if (!uint8ArrayEquals(privDigest, pubDigest)) {\n        throw new Error('Public and private key do not match')\n      }\n    }\n    return new PeerIdWithIs(privDigest, privKey, privKey.public)\n  }\n\n  // TODO: val id and pubDigest\n\n  if (pubKey) {\n    return new PeerIdWithIs(pubDigest, null, pubKey)\n  }\n\n  if (id) {\n    return new PeerIdWithIs(id)\n  }\n\n  throw new Error('Protobuf did not contain any usable key material')\n}\n\nexports.isPeerId = (peerId) => {\n  return Boolean(typeof peerId === 'object' &&\n    peerId._id &&\n    peerId._idB58String)\n}\n\nfunction toB64Opt (val) {\n  if (val) {\n    return uint8ArrayToString(val, 'base64pad')\n  }\n}\n"]},"metadata":{},"sourceType":"script"}