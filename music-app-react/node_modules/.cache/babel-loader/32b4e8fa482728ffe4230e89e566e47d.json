{"ast":null,"code":"'use strict';\n\nconst exporter = require('ipfs-unixfs-exporter');\n\nconst toMfsPath = require('./utils/to-mfs-path');\n\nconst {\n  MFS_FILE_TYPES,\n  withTimeoutOption\n} = require('../../utils');\n\nconst toOutput = fsEntry => {\n  let type = 0;\n  let size = fsEntry.node.size || fsEntry.node.length;\n  let mode;\n  let mtime;\n\n  if (fsEntry.unixfs) {\n    size = fsEntry.unixfs.fileSize();\n    type = MFS_FILE_TYPES[fsEntry.unixfs.type];\n    mode = fsEntry.unixfs.mode;\n    mtime = fsEntry.unixfs.mtime;\n  }\n\n  const output = {\n    cid: fsEntry.cid,\n    name: fsEntry.name,\n    type,\n    size\n  };\n\n  if (mtime !== undefined) {\n    output.mtime = mtime;\n  }\n\n  if (mode !== undefined) {\n    output.mode = mode;\n  }\n\n  return output;\n};\n\nmodule.exports = context => {\n  return withTimeoutOption(async function* mfsLs(path, options = {}) {\n    const mfsPath = await toMfsPath(context, path, options);\n    const fsDir = await exporter(mfsPath.mfsPath, context.ipld); // single file/node\n\n    if (!fsDir.unixfs || !fsDir.unixfs.type.includes('directory')) {\n      yield toOutput(fsDir);\n      return;\n    } // directory, perhaps sharded\n\n\n    for await (const fsEntry of fsDir.content(options)) {\n      yield toOutput(fsEntry);\n    }\n  });\n};","map":{"version":3,"sources":["/home/user/orbit-playground/music-app/node_modules/ipfs/src/core/components/files/ls.js"],"names":["exporter","require","toMfsPath","MFS_FILE_TYPES","withTimeoutOption","toOutput","fsEntry","type","size","node","length","mode","mtime","unixfs","fileSize","output","cid","name","undefined","module","exports","context","mfsLs","path","options","mfsPath","fsDir","ipld","includes","content"],"mappings":"AAAA;;AAEA,MAAMA,QAAQ,GAAGC,OAAO,CAAC,sBAAD,CAAxB;;AACA,MAAMC,SAAS,GAAGD,OAAO,CAAC,qBAAD,CAAzB;;AACA,MAAM;AACJE,EAAAA,cADI;AAEJC,EAAAA;AAFI,IAGFH,OAAO,CAAC,aAAD,CAHX;;AAKA,MAAMI,QAAQ,GAAIC,OAAD,IAAa;AAC5B,MAAIC,IAAI,GAAG,CAAX;AACA,MAAIC,IAAI,GAAGF,OAAO,CAACG,IAAR,CAAaD,IAAb,IAAqBF,OAAO,CAACG,IAAR,CAAaC,MAA7C;AACA,MAAIC,IAAJ;AACA,MAAIC,KAAJ;;AAEA,MAAIN,OAAO,CAACO,MAAZ,EAAoB;AAClBL,IAAAA,IAAI,GAAGF,OAAO,CAACO,MAAR,CAAeC,QAAf,EAAP;AACAP,IAAAA,IAAI,GAAGJ,cAAc,CAACG,OAAO,CAACO,MAAR,CAAeN,IAAhB,CAArB;AACAI,IAAAA,IAAI,GAAGL,OAAO,CAACO,MAAR,CAAeF,IAAtB;AACAC,IAAAA,KAAK,GAAGN,OAAO,CAACO,MAAR,CAAeD,KAAvB;AACD;;AAED,QAAMG,MAAM,GAAG;AACbC,IAAAA,GAAG,EAAEV,OAAO,CAACU,GADA;AAEbC,IAAAA,IAAI,EAAEX,OAAO,CAACW,IAFD;AAGbV,IAAAA,IAHa;AAIbC,IAAAA;AAJa,GAAf;;AAOA,MAAII,KAAK,KAAKM,SAAd,EAAyB;AACvBH,IAAAA,MAAM,CAACH,KAAP,GAAeA,KAAf;AACD;;AAED,MAAID,IAAI,KAAKO,SAAb,EAAwB;AACtBH,IAAAA,MAAM,CAACJ,IAAP,GAAcA,IAAd;AACD;;AAED,SAAOI,MAAP;AACD,CA7BD;;AA+BAI,MAAM,CAACC,OAAP,GAAkBC,OAAD,IAAa;AAC5B,SAAOjB,iBAAiB,CAAC,gBAAiBkB,KAAjB,CAAwBC,IAAxB,EAA8BC,OAAO,GAAG,EAAxC,EAA4C;AACnE,UAAMC,OAAO,GAAG,MAAMvB,SAAS,CAACmB,OAAD,EAAUE,IAAV,EAAgBC,OAAhB,CAA/B;AACA,UAAME,KAAK,GAAG,MAAM1B,QAAQ,CAACyB,OAAO,CAACA,OAAT,EAAkBJ,OAAO,CAACM,IAA1B,CAA5B,CAFmE,CAInE;;AACA,QAAI,CAACD,KAAK,CAACb,MAAP,IAAiB,CAACa,KAAK,CAACb,MAAN,CAAaN,IAAb,CAAkBqB,QAAlB,CAA2B,WAA3B,CAAtB,EAA+D;AAC7D,YAAMvB,QAAQ,CAACqB,KAAD,CAAd;AAEA;AACD,KATkE,CAWnE;;;AACA,eAAW,MAAMpB,OAAjB,IAA4BoB,KAAK,CAACG,OAAN,CAAcL,OAAd,CAA5B,EAAoD;AAClD,YAAMnB,QAAQ,CAACC,OAAD,CAAd;AACD;AACF,GAfuB,CAAxB;AAgBD,CAjBD","sourcesContent":["'use strict'\n\nconst exporter = require('ipfs-unixfs-exporter')\nconst toMfsPath = require('./utils/to-mfs-path')\nconst {\n  MFS_FILE_TYPES,\n  withTimeoutOption\n} = require('../../utils')\n\nconst toOutput = (fsEntry) => {\n  let type = 0\n  let size = fsEntry.node.size || fsEntry.node.length\n  let mode\n  let mtime\n\n  if (fsEntry.unixfs) {\n    size = fsEntry.unixfs.fileSize()\n    type = MFS_FILE_TYPES[fsEntry.unixfs.type]\n    mode = fsEntry.unixfs.mode\n    mtime = fsEntry.unixfs.mtime\n  }\n\n  const output = {\n    cid: fsEntry.cid,\n    name: fsEntry.name,\n    type,\n    size\n  }\n\n  if (mtime !== undefined) {\n    output.mtime = mtime\n  }\n\n  if (mode !== undefined) {\n    output.mode = mode\n  }\n\n  return output\n}\n\nmodule.exports = (context) => {\n  return withTimeoutOption(async function * mfsLs (path, options = {}) {\n    const mfsPath = await toMfsPath(context, path, options)\n    const fsDir = await exporter(mfsPath.mfsPath, context.ipld)\n\n    // single file/node\n    if (!fsDir.unixfs || !fsDir.unixfs.type.includes('directory')) {\n      yield toOutput(fsDir)\n\n      return\n    }\n\n    // directory, perhaps sharded\n    for await (const fsEntry of fsDir.content(options)) {\n      yield toOutput(fsEntry)\n    }\n  })\n}\n"]},"metadata":{},"sourceType":"script"}