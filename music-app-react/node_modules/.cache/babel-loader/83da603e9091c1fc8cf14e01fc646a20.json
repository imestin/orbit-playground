{"ast":null,"code":"'use strict';\n\nconst {\n  EventEmitter\n} = require('events');\n\nconst debug = require('debug');\n\nconst globalThis = require('ipfs-utils/src/globalthis');\n\nconst log = debug('libp2p');\nlog.error = debug('libp2p:error');\n\nconst errCode = require('err-code');\n\nconst PeerId = require('peer-id');\n\nconst peerRouting = require('./peer-routing');\n\nconst contentRouting = require('./content-routing');\n\nconst getPeer = require('./get-peer');\n\nconst {\n  validate: validateConfig\n} = require('./config');\n\nconst {\n  codes,\n  messages\n} = require('./errors');\n\nconst AddressManager = require('./address-manager');\n\nconst ConnectionManager = require('./connection-manager');\n\nconst Circuit = require('./circuit');\n\nconst Dialer = require('./dialer');\n\nconst Keychain = require('./keychain');\n\nconst Metrics = require('./metrics');\n\nconst TransportManager = require('./transport-manager');\n\nconst Upgrader = require('./upgrader');\n\nconst PeerStore = require('./peer-store');\n\nconst PubsubAdapter = require('./pubsub-adapter');\n\nconst PersistentPeerStore = require('./peer-store/persistent');\n\nconst Registrar = require('./registrar');\n\nconst ping = require('./ping');\n\nconst {\n  IdentifyService,\n  multicodecs: IDENTIFY_PROTOCOLS\n} = require('./identify');\n/**\n * @fires Libp2p#error Emitted when an error occurs\n * @fires Libp2p#peer:connect Emitted when a peer is connected to this node\n * @fires Libp2p#peer:disconnect Emitted when a peer disconnects from this node\n * @fires Libp2p#peer:discovery Emitted when a peer is discovered\n */\n\n\nclass Libp2p extends EventEmitter {\n  constructor(_options) {\n    super(); // validateConfig will ensure the config is correct,\n    // and add default values where appropriate\n\n    this._options = validateConfig(_options);\n    this.peerId = this._options.peerId;\n    this.datastore = this._options.datastore;\n    this.peerStore = this.datastore && this._options.peerStore.persistence ? new PersistentPeerStore({\n      peerId: this.peerId,\n      datastore: this.datastore,\n      ...this._options.peerStore\n    }) : new PeerStore({\n      peerId: this.peerId\n    }); // Addresses {listen, announce, noAnnounce}\n\n    this.addresses = this._options.addresses;\n    this.addressManager = new AddressManager(this._options.addresses);\n    this._modules = this._options.modules;\n    this._config = this._options.config;\n    this._transport = []; // Transport instances/references\n\n    this._discovery = new Map(); // Discovery service instances/references\n    // Create the Connection Manager\n\n    if (this._options.connectionManager.minPeers) {\n      // Remove in 0.29\n      this._options.connectionManager.minConnections = this._options.connectionManager.minPeers;\n    }\n\n    this.connectionManager = new ConnectionManager(this, {\n      autoDial: this._config.peerDiscovery.autoDial,\n      ...this._options.connectionManager\n    }); // Create Metrics\n\n    if (this._options.metrics.enabled) {\n      this.metrics = new Metrics({ ...this._options.metrics,\n        connectionManager: this.connectionManager\n      });\n    } // Create keychain\n\n\n    if (this._options.keychain && this._options.keychain.datastore) {\n      log('creating keychain');\n      const keychainOpts = Keychain.generateOptions();\n      this.keychain = new Keychain(this._options.keychain.datastore, {\n        passPhrase: this._options.keychain.pass,\n        ...keychainOpts,\n        ...this._options.keychain\n      });\n      log('keychain constructed');\n    } // Setup the Upgrader\n\n\n    this.upgrader = new Upgrader({\n      localPeer: this.peerId,\n      metrics: this.metrics,\n      onConnection: connection => this.connectionManager.onConnect(connection),\n      onConnectionEnd: connection => this.connectionManager.onDisconnect(connection)\n    }); // Setup the transport manager\n\n    this.transportManager = new TransportManager({\n      libp2p: this,\n      upgrader: this.upgrader,\n      faultTolerance: this._options.transportManager.faultTolerance\n    }); // Create the Registrar\n\n    this.registrar = new Registrar({\n      peerStore: this.peerStore,\n      connectionManager: this.connectionManager\n    });\n    this.handle = this.handle.bind(this);\n    this.registrar.handle = this.handle; // Attach crypto channels\n\n    if (!this._modules.connEncryption || !this._modules.connEncryption.length) {\n      throw errCode(new Error(messages.CONN_ENCRYPTION_REQUIRED), codes.CONN_ENCRYPTION_REQUIRED);\n    }\n\n    const cryptos = this._modules.connEncryption;\n    cryptos.forEach(crypto => {\n      this.upgrader.cryptos.set(crypto.protocol, crypto);\n    });\n    this.dialer = new Dialer({\n      transportManager: this.transportManager,\n      peerStore: this.peerStore,\n      concurrency: this._options.dialer.maxParallelDials,\n      perPeerLimit: this._options.dialer.maxDialsPerPeer,\n      timeout: this._options.dialer.dialTimeout\n    });\n\n    this._modules.transport.forEach(Transport => {\n      const key = Transport.prototype[Symbol.toStringTag];\n      const transportOptions = this._config.transport[key];\n      this.transportManager.add(key, Transport, transportOptions);\n    });\n\n    if (this._config.relay.enabled) {\n      this.transportManager.add(Circuit.prototype[Symbol.toStringTag], Circuit);\n    } // Attach stream multiplexers\n\n\n    if (this._modules.streamMuxer) {\n      const muxers = this._modules.streamMuxer;\n      muxers.forEach(muxer => {\n        this.upgrader.muxers.set(muxer.multicodec, muxer);\n      }); // Add the identify service since we can multiplex\n\n      this.identifyService = new IdentifyService({\n        libp2p: this,\n        protocols: this.upgrader.protocols\n      });\n      this.handle(Object.values(IDENTIFY_PROTOCOLS), this.identifyService.handleMessage);\n    } // Attach private network protector\n\n\n    if (this._modules.connProtector) {\n      this.upgrader.protector = this._modules.connProtector;\n    } else if (globalThis.process !== undefined && globalThis.process.env && globalThis.process.env.LIBP2P_FORCE_PNET) {\n      throw new Error('Private network is enforced, but no protector was provided');\n    } // dht provided components (peerRouting, contentRouting, dht)\n\n\n    if (this._modules.dht) {\n      const DHT = this._modules.dht;\n      this._dht = new DHT({\n        libp2p: this,\n        dialer: this.dialer,\n        peerId: this.peerId,\n        peerStore: this.peerStore,\n        registrar: this.registrar,\n        datastore: this.datastore,\n        ...this._config.dht\n      });\n    } // Create pubsub if provided\n\n\n    if (this._modules.pubsub) {\n      const Pubsub = this._modules.pubsub; // using pubsub adapter with *DEPRECATED* handlers functionality\n\n      this.pubsub = PubsubAdapter(Pubsub, this, this._config.pubsub);\n    } // Attach remaining APIs\n    // peer and content routing will automatically get modules from _modules and _dht\n\n\n    this.peerRouting = peerRouting(this);\n    this.contentRouting = contentRouting(this); // Mount default protocols\n\n    ping.mount(this);\n    this._onDiscoveryPeer = this._onDiscoveryPeer.bind(this);\n  }\n  /**\n   * Overrides EventEmitter.emit to conditionally emit errors\n   * if there is a handler. If not, errors will be logged.\n   * @param {string} eventName\n   * @param  {...any} args\n   * @returns {void}\n   */\n\n\n  emit(eventName, ...args) {\n    if (eventName === 'error' && !this._events.error) {\n      log.error(...args);\n    } else {\n      super.emit(eventName, ...args);\n    }\n  }\n  /**\n   * Starts the libp2p node and all its subsystems\n   *\n   * @returns {Promise<void>}\n   */\n\n\n  async start() {\n    log('libp2p is starting');\n\n    try {\n      await this._onStarting();\n      await this._onDidStart();\n      log('libp2p has started');\n    } catch (err) {\n      this.emit('error', err);\n      log.error('An error occurred starting libp2p', err);\n      await this.stop();\n      throw err;\n    }\n  }\n  /**\n   * Stop the libp2p node by closing its listeners and open connections\n   * @async\n   * @returns {void}\n   */\n\n\n  async stop() {\n    log('libp2p is stopping');\n\n    try {\n      for (const service of this._discovery.values()) {\n        service.removeListener('peer', this._onDiscoveryPeer);\n      }\n\n      await Promise.all(Array.from(this._discovery.values(), s => s.stop()));\n      this._discovery = new Map();\n      await this.peerStore.stop();\n      await this.connectionManager.stop();\n      await Promise.all([this.pubsub && this.pubsub.stop(), this._dht && this._dht.stop(), this.metrics && this.metrics.stop()]);\n      await this.transportManager.close();\n      ping.unmount(this);\n      this.dialer.destroy();\n    } catch (err) {\n      if (err) {\n        log.error(err);\n        this.emit('error', err);\n      }\n    }\n\n    this._isStarted = false;\n    log('libp2p has stopped');\n  }\n  /**\n   * Load keychain keys from the datastore.\n   * Imports the private key as 'self', if needed.\n   * @async\n   * @returns {void}\n   */\n\n\n  async loadKeychain() {\n    try {\n      await this.keychain.findKeyByName('self');\n    } catch (err) {\n      await this.keychain.importPeer('self', this.peerId);\n    }\n  }\n\n  isStarted() {\n    return this._isStarted;\n  }\n  /**\n   * Gets a Map of the current connections. The keys are the stringified\n   * `PeerId` of the peer. The value is an array of Connections to that peer.\n   * @returns {Map<string, Connection[]>}\n   */\n\n\n  get connections() {\n    return this.connectionManager.connections;\n  }\n  /**\n   * Dials to the provided peer. If successful, the known metadata of the\n   * peer will be added to the nodes `peerStore`\n   * @param {PeerId|Multiaddr|string} peer The peer to dial\n   * @param {object} options\n   * @param {AbortSignal} [options.signal]\n   * @returns {Promise<Connection>}\n   */\n\n\n  dial(peer, options) {\n    return this.dialProtocol(peer, null, options);\n  }\n  /**\n   * Dials to the provided peer and handshakes with the given protocol.\n   * If successful, the known metadata of the peer will be added to the nodes `peerStore`,\n   * and the `Connection` will be returned\n   * @async\n   * @param {PeerId|Multiaddr|string} peer The peer to dial\n   * @param {string[]|string} protocols\n   * @param {object} options\n   * @param {AbortSignal} [options.signal]\n   * @returns {Promise<Connection|*>}\n   */\n\n\n  async dialProtocol(peer, protocols, options) {\n    const {\n      id,\n      multiaddrs\n    } = getPeer(peer);\n    let connection = this.connectionManager.get(id);\n\n    if (!connection) {\n      connection = await this.dialer.connectToPeer(peer, options);\n    } else if (multiaddrs) {\n      this.peerStore.addressBook.add(id, multiaddrs);\n    } // If a protocol was provided, create a new stream\n\n\n    if (protocols) {\n      return connection.newStream(protocols);\n    }\n\n    return connection;\n  }\n  /**\n   * Get peer advertising multiaddrs by concating the addresses used\n   * by transports to listen with the announce addresses.\n   * Duplicated addresses and noAnnounce addresses are filtered out.\n   * @return {Array<Multiaddr>}\n   */\n\n\n  get multiaddrs() {\n    // Filter noAnnounce multiaddrs\n    const filterMa = this.addressManager.getNoAnnounceAddrs(); // Create advertising list\n\n    return this.transportManager.getAddrs().concat(this.addressManager.getAnnounceAddrs()).filter((ma, index, array) => {\n      // Filter out if repeated\n      if (array.findIndex(otherMa => otherMa.equals(ma)) !== index) {\n        return false;\n      } // Filter out if in noAnnounceMultiaddrs\n\n\n      if (filterMa.find(fm => fm.equals(ma))) {\n        return false;\n      }\n\n      return true;\n    });\n  }\n  /**\n   * Disconnects all connections to the given `peer`\n   * @param {PeerId|multiaddr|string} peer the peer to close connections to\n   * @returns {Promise<void>}\n   */\n\n\n  async hangUp(peer) {\n    const {\n      id\n    } = getPeer(peer);\n    const connections = this.connectionManager.connections.get(id.toB58String());\n\n    if (!connections) {\n      return;\n    }\n\n    await Promise.all(connections.map(connection => {\n      return connection.close();\n    }));\n  }\n  /**\n   * Pings the given peer in order to obtain the operation latency.\n   * @param {PeerId|Multiaddr|string} peer The peer to ping\n   * @returns {Promise<number>}\n   */\n\n\n  ping(peer) {\n    const {\n      id,\n      multiaddrs\n    } = getPeer(peer); // If received multiaddr, ping it\n\n    if (multiaddrs) {\n      return ping(this, multiaddrs[0]);\n    }\n\n    return ping(this, id);\n  }\n  /**\n   * Registers the `handler` for each protocol\n   * @param {string[]|string} protocols\n   * @param {function({ connection:*, stream:*, protocol:string })} handler\n   */\n\n\n  handle(protocols, handler) {\n    protocols = Array.isArray(protocols) ? protocols : [protocols];\n    protocols.forEach(protocol => {\n      this.upgrader.protocols.set(protocol, handler);\n    }); // Only push if libp2p is running\n\n    if (this.isStarted() && this.identifyService) {\n      this.identifyService.pushToPeerStore(this.peerStore);\n    }\n  }\n  /**\n   * Removes the handler for each protocol. The protocol\n   * will no longer be supported on streams.\n   * @param {string[]|string} protocols\n   */\n\n\n  unhandle(protocols) {\n    protocols = Array.isArray(protocols) ? protocols : [protocols];\n    protocols.forEach(protocol => {\n      this.upgrader.protocols.delete(protocol);\n    }); // Only push if libp2p is running\n\n    if (this.isStarted() && this.identifyService) {\n      this.identifyService.pushToPeerStore(this.peerStore);\n    }\n  }\n\n  async _onStarting() {\n    // Listen on the provided transports\n    await this.transportManager.listen(); // Start PeerStore\n\n    await this.peerStore.start();\n\n    if (this._config.pubsub.enabled) {\n      this.pubsub && this.pubsub.start();\n    } // DHT subsystem\n\n\n    if (this._config.dht.enabled) {\n      this._dht && this._dht.start(); // TODO: this should be modified once random-walk is used as\n      // the other discovery modules\n\n      this._dht.on('peer', this._onDiscoveryPeer);\n    } // Start metrics if present\n\n\n    this.metrics && this.metrics.start();\n  }\n  /**\n   * Called when libp2p has started and before it returns\n   * @private\n   */\n\n\n  async _onDidStart() {\n    this._isStarted = true;\n    this.peerStore.on('peer', peerId => {\n      this.emit('peer:discovery', peerId);\n\n      this._maybeConnect(peerId);\n    }); // Once we start, emit any peers we may have already discovered\n    // TODO: this should be removed, as we already discovered these peers in the past\n\n    for (const peer of this.peerStore.peers.values()) {\n      this.emit('peer:discovery', peer.id);\n    }\n\n    this.connectionManager.start(); // Peer discovery\n\n    await this._setupPeerDiscovery();\n  }\n  /**\n   * Called whenever peer discovery services emit `peer` events.\n   * Known peers may be emitted.\n   * @private\n   * @param {{ id: PeerId, multiaddrs: Array<Multiaddr>, protocols: Array<string> }} peer\n   */\n\n\n  _onDiscoveryPeer(peer) {\n    if (peer.id.toB58String() === this.peerId.toB58String()) {\n      log.error(new Error(codes.ERR_DISCOVERED_SELF));\n      return;\n    }\n\n    peer.multiaddrs && this.peerStore.addressBook.add(peer.id, peer.multiaddrs);\n    peer.protocols && this.peerStore.protoBook.set(peer.id, peer.protocols);\n  }\n  /**\n   * Will dial to the given `peerId` if the current number of\n   * connected peers is less than the configured `ConnectionManager`\n   * minConnections.\n   * @private\n   * @param {PeerId} peerId\n   */\n\n\n  async _maybeConnect(peerId) {\n    // If auto dialing is on and we have no connection to the peer, check if we should dial\n    if (this._config.peerDiscovery.autoDial === true && !this.connectionManager.get(peerId)) {\n      const minConnections = this._options.connectionManager.minConnections || 0;\n\n      if (minConnections > this.connectionManager.size) {\n        log('connecting to discovered peer %s', peerId.toB58String());\n\n        try {\n          await this.dialer.connectToPeer(peerId);\n        } catch (err) {\n          log.error('could not connect to discovered peer', err);\n        }\n      }\n    }\n  }\n  /**\n   * Initializes and starts peer discovery services\n   *\n   * @async\n   * @private\n   */\n\n\n  async _setupPeerDiscovery() {\n    const setupService = DiscoveryService => {\n      let config = {\n        enabled: true // on by default\n\n      };\n\n      if (DiscoveryService.tag && this._config.peerDiscovery && this._config.peerDiscovery[DiscoveryService.tag]) {\n        config = { ...config,\n          ...this._config.peerDiscovery[DiscoveryService.tag]\n        };\n      }\n\n      if (config.enabled && !this._discovery.has(DiscoveryService.tag)) {\n        // not already added\n        let discoveryService;\n\n        if (typeof DiscoveryService === 'function') {\n          discoveryService = new DiscoveryService(Object.assign({}, config, {\n            peerId: this.peerId,\n            libp2p: this\n          }));\n        } else {\n          discoveryService = DiscoveryService;\n        }\n\n        discoveryService.on('peer', this._onDiscoveryPeer);\n\n        this._discovery.set(DiscoveryService.tag, discoveryService);\n      }\n    }; // Discovery modules\n\n\n    for (const DiscoveryService of this._modules.peerDiscovery || []) {\n      setupService(DiscoveryService);\n    } // Transport modules with discovery\n\n\n    for (const Transport of this.transportManager.getTransports()) {\n      if (Transport.discovery) {\n        setupService(Transport.discovery);\n      }\n    }\n\n    await Promise.all(Array.from(this._discovery.values(), d => d.start()));\n  }\n\n}\n/**\n * Like `new Libp2p(options)` except it will create a `PeerId`\n * instance if one is not provided in options.\n * @param {object} options Libp2p configuration options\n * @returns {Libp2p}\n */\n\n\nLibp2p.create = async function create(options = {}) {\n  if (options.peerId) {\n    return new Libp2p(options);\n  }\n\n  const peerId = await PeerId.create();\n  options.peerId = peerId;\n  return new Libp2p(options);\n};\n\nmodule.exports = Libp2p;","map":{"version":3,"sources":["/home/user/orbit-playground/music-app/node_modules/libp2p/src/index.js"],"names":["EventEmitter","require","debug","globalThis","log","error","errCode","PeerId","peerRouting","contentRouting","getPeer","validate","validateConfig","codes","messages","AddressManager","ConnectionManager","Circuit","Dialer","Keychain","Metrics","TransportManager","Upgrader","PeerStore","PubsubAdapter","PersistentPeerStore","Registrar","ping","IdentifyService","multicodecs","IDENTIFY_PROTOCOLS","Libp2p","constructor","_options","peerId","datastore","peerStore","persistence","addresses","addressManager","_modules","modules","_config","config","_transport","_discovery","Map","connectionManager","minPeers","minConnections","autoDial","peerDiscovery","metrics","enabled","keychain","keychainOpts","generateOptions","passPhrase","pass","upgrader","localPeer","onConnection","connection","onConnect","onConnectionEnd","onDisconnect","transportManager","libp2p","faultTolerance","registrar","handle","bind","connEncryption","length","Error","CONN_ENCRYPTION_REQUIRED","cryptos","forEach","crypto","set","protocol","dialer","concurrency","maxParallelDials","perPeerLimit","maxDialsPerPeer","timeout","dialTimeout","transport","Transport","key","prototype","Symbol","toStringTag","transportOptions","add","relay","streamMuxer","muxers","muxer","multicodec","identifyService","protocols","Object","values","handleMessage","connProtector","protector","process","undefined","env","LIBP2P_FORCE_PNET","dht","DHT","_dht","pubsub","Pubsub","mount","_onDiscoveryPeer","emit","eventName","args","_events","start","_onStarting","_onDidStart","err","stop","service","removeListener","Promise","all","Array","from","s","close","unmount","destroy","_isStarted","loadKeychain","findKeyByName","importPeer","isStarted","connections","dial","peer","options","dialProtocol","id","multiaddrs","get","connectToPeer","addressBook","newStream","filterMa","getNoAnnounceAddrs","getAddrs","concat","getAnnounceAddrs","filter","ma","index","array","findIndex","otherMa","equals","find","fm","hangUp","toB58String","map","handler","isArray","pushToPeerStore","unhandle","delete","listen","on","_maybeConnect","peers","_setupPeerDiscovery","ERR_DISCOVERED_SELF","protoBook","size","setupService","DiscoveryService","tag","has","discoveryService","assign","getTransports","discovery","d","create","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { EventEmitter } = require('events')\nconst debug = require('debug')\nconst globalThis = require('ipfs-utils/src/globalthis')\nconst log = debug('libp2p')\nlog.error = debug('libp2p:error')\n\nconst errCode = require('err-code')\nconst PeerId = require('peer-id')\n\nconst peerRouting = require('./peer-routing')\nconst contentRouting = require('./content-routing')\nconst getPeer = require('./get-peer')\nconst { validate: validateConfig } = require('./config')\nconst { codes, messages } = require('./errors')\n\nconst AddressManager = require('./address-manager')\nconst ConnectionManager = require('./connection-manager')\nconst Circuit = require('./circuit')\nconst Dialer = require('./dialer')\nconst Keychain = require('./keychain')\nconst Metrics = require('./metrics')\nconst TransportManager = require('./transport-manager')\nconst Upgrader = require('./upgrader')\nconst PeerStore = require('./peer-store')\nconst PubsubAdapter = require('./pubsub-adapter')\nconst PersistentPeerStore = require('./peer-store/persistent')\nconst Registrar = require('./registrar')\nconst ping = require('./ping')\nconst {\n  IdentifyService,\n  multicodecs: IDENTIFY_PROTOCOLS\n} = require('./identify')\n\n/**\n * @fires Libp2p#error Emitted when an error occurs\n * @fires Libp2p#peer:connect Emitted when a peer is connected to this node\n * @fires Libp2p#peer:disconnect Emitted when a peer disconnects from this node\n * @fires Libp2p#peer:discovery Emitted when a peer is discovered\n */\nclass Libp2p extends EventEmitter {\n  constructor (_options) {\n    super()\n    // validateConfig will ensure the config is correct,\n    // and add default values where appropriate\n    this._options = validateConfig(_options)\n\n    this.peerId = this._options.peerId\n    this.datastore = this._options.datastore\n\n    this.peerStore = (this.datastore && this._options.peerStore.persistence)\n      ? new PersistentPeerStore({\n        peerId: this.peerId,\n        datastore: this.datastore,\n        ...this._options.peerStore\n      })\n      : new PeerStore({ peerId: this.peerId })\n\n    // Addresses {listen, announce, noAnnounce}\n    this.addresses = this._options.addresses\n    this.addressManager = new AddressManager(this._options.addresses)\n\n    this._modules = this._options.modules\n    this._config = this._options.config\n    this._transport = [] // Transport instances/references\n    this._discovery = new Map() // Discovery service instances/references\n\n    // Create the Connection Manager\n    if (this._options.connectionManager.minPeers) { // Remove in 0.29\n      this._options.connectionManager.minConnections = this._options.connectionManager.minPeers\n    }\n    this.connectionManager = new ConnectionManager(this, {\n      autoDial: this._config.peerDiscovery.autoDial,\n      ...this._options.connectionManager\n    })\n\n    // Create Metrics\n    if (this._options.metrics.enabled) {\n      this.metrics = new Metrics({\n        ...this._options.metrics,\n        connectionManager: this.connectionManager\n      })\n    }\n\n    // Create keychain\n    if (this._options.keychain && this._options.keychain.datastore) {\n      log('creating keychain')\n\n      const keychainOpts = Keychain.generateOptions()\n\n      this.keychain = new Keychain(this._options.keychain.datastore, {\n        passPhrase: this._options.keychain.pass,\n        ...keychainOpts,\n        ...this._options.keychain\n      })\n\n      log('keychain constructed')\n    }\n\n    // Setup the Upgrader\n    this.upgrader = new Upgrader({\n      localPeer: this.peerId,\n      metrics: this.metrics,\n      onConnection: (connection) => this.connectionManager.onConnect(connection),\n      onConnectionEnd: (connection) => this.connectionManager.onDisconnect(connection)\n    })\n\n    // Setup the transport manager\n    this.transportManager = new TransportManager({\n      libp2p: this,\n      upgrader: this.upgrader,\n      faultTolerance: this._options.transportManager.faultTolerance\n    })\n\n    // Create the Registrar\n    this.registrar = new Registrar({\n      peerStore: this.peerStore,\n      connectionManager: this.connectionManager\n    })\n\n    this.handle = this.handle.bind(this)\n    this.registrar.handle = this.handle\n\n    // Attach crypto channels\n    if (!this._modules.connEncryption || !this._modules.connEncryption.length) {\n      throw errCode(new Error(messages.CONN_ENCRYPTION_REQUIRED), codes.CONN_ENCRYPTION_REQUIRED)\n    }\n    const cryptos = this._modules.connEncryption\n    cryptos.forEach((crypto) => {\n      this.upgrader.cryptos.set(crypto.protocol, crypto)\n    })\n\n    this.dialer = new Dialer({\n      transportManager: this.transportManager,\n      peerStore: this.peerStore,\n      concurrency: this._options.dialer.maxParallelDials,\n      perPeerLimit: this._options.dialer.maxDialsPerPeer,\n      timeout: this._options.dialer.dialTimeout\n    })\n\n    this._modules.transport.forEach((Transport) => {\n      const key = Transport.prototype[Symbol.toStringTag]\n      const transportOptions = this._config.transport[key]\n      this.transportManager.add(key, Transport, transportOptions)\n    })\n\n    if (this._config.relay.enabled) {\n      this.transportManager.add(Circuit.prototype[Symbol.toStringTag], Circuit)\n    }\n\n    // Attach stream multiplexers\n    if (this._modules.streamMuxer) {\n      const muxers = this._modules.streamMuxer\n      muxers.forEach((muxer) => {\n        this.upgrader.muxers.set(muxer.multicodec, muxer)\n      })\n\n      // Add the identify service since we can multiplex\n      this.identifyService = new IdentifyService({\n        libp2p: this,\n        protocols: this.upgrader.protocols\n      })\n      this.handle(Object.values(IDENTIFY_PROTOCOLS), this.identifyService.handleMessage)\n    }\n\n    // Attach private network protector\n    if (this._modules.connProtector) {\n      this.upgrader.protector = this._modules.connProtector\n    } else if (globalThis.process !== undefined && globalThis.process.env && globalThis.process.env.LIBP2P_FORCE_PNET) {\n      throw new Error('Private network is enforced, but no protector was provided')\n    }\n\n    // dht provided components (peerRouting, contentRouting, dht)\n    if (this._modules.dht) {\n      const DHT = this._modules.dht\n      this._dht = new DHT({\n        libp2p: this,\n        dialer: this.dialer,\n        peerId: this.peerId,\n        peerStore: this.peerStore,\n        registrar: this.registrar,\n        datastore: this.datastore,\n        ...this._config.dht\n      })\n    }\n\n    // Create pubsub if provided\n    if (this._modules.pubsub) {\n      const Pubsub = this._modules.pubsub\n      // using pubsub adapter with *DEPRECATED* handlers functionality\n      this.pubsub = PubsubAdapter(Pubsub, this, this._config.pubsub)\n    }\n\n    // Attach remaining APIs\n    // peer and content routing will automatically get modules from _modules and _dht\n    this.peerRouting = peerRouting(this)\n    this.contentRouting = contentRouting(this)\n\n    // Mount default protocols\n    ping.mount(this)\n\n    this._onDiscoveryPeer = this._onDiscoveryPeer.bind(this)\n  }\n\n  /**\n   * Overrides EventEmitter.emit to conditionally emit errors\n   * if there is a handler. If not, errors will be logged.\n   * @param {string} eventName\n   * @param  {...any} args\n   * @returns {void}\n   */\n  emit (eventName, ...args) {\n    if (eventName === 'error' && !this._events.error) {\n      log.error(...args)\n    } else {\n      super.emit(eventName, ...args)\n    }\n  }\n\n  /**\n   * Starts the libp2p node and all its subsystems\n   *\n   * @returns {Promise<void>}\n   */\n  async start () {\n    log('libp2p is starting')\n\n    try {\n      await this._onStarting()\n      await this._onDidStart()\n      log('libp2p has started')\n    } catch (err) {\n      this.emit('error', err)\n      log.error('An error occurred starting libp2p', err)\n      await this.stop()\n      throw err\n    }\n  }\n\n  /**\n   * Stop the libp2p node by closing its listeners and open connections\n   * @async\n   * @returns {void}\n   */\n  async stop () {\n    log('libp2p is stopping')\n\n    try {\n      for (const service of this._discovery.values()) {\n        service.removeListener('peer', this._onDiscoveryPeer)\n      }\n\n      await Promise.all(Array.from(this._discovery.values(), s => s.stop()))\n\n      this._discovery = new Map()\n\n      await this.peerStore.stop()\n      await this.connectionManager.stop()\n\n      await Promise.all([\n        this.pubsub && this.pubsub.stop(),\n        this._dht && this._dht.stop(),\n        this.metrics && this.metrics.stop()\n      ])\n\n      await this.transportManager.close()\n\n      ping.unmount(this)\n      this.dialer.destroy()\n    } catch (err) {\n      if (err) {\n        log.error(err)\n        this.emit('error', err)\n      }\n    }\n    this._isStarted = false\n    log('libp2p has stopped')\n  }\n\n  /**\n   * Load keychain keys from the datastore.\n   * Imports the private key as 'self', if needed.\n   * @async\n   * @returns {void}\n   */\n  async loadKeychain () {\n    try {\n      await this.keychain.findKeyByName('self')\n    } catch (err) {\n      await this.keychain.importPeer('self', this.peerId)\n    }\n  }\n\n  isStarted () {\n    return this._isStarted\n  }\n\n  /**\n   * Gets a Map of the current connections. The keys are the stringified\n   * `PeerId` of the peer. The value is an array of Connections to that peer.\n   * @returns {Map<string, Connection[]>}\n   */\n  get connections () {\n    return this.connectionManager.connections\n  }\n\n  /**\n   * Dials to the provided peer. If successful, the known metadata of the\n   * peer will be added to the nodes `peerStore`\n   * @param {PeerId|Multiaddr|string} peer The peer to dial\n   * @param {object} options\n   * @param {AbortSignal} [options.signal]\n   * @returns {Promise<Connection>}\n   */\n  dial (peer, options) {\n    return this.dialProtocol(peer, null, options)\n  }\n\n  /**\n   * Dials to the provided peer and handshakes with the given protocol.\n   * If successful, the known metadata of the peer will be added to the nodes `peerStore`,\n   * and the `Connection` will be returned\n   * @async\n   * @param {PeerId|Multiaddr|string} peer The peer to dial\n   * @param {string[]|string} protocols\n   * @param {object} options\n   * @param {AbortSignal} [options.signal]\n   * @returns {Promise<Connection|*>}\n   */\n  async dialProtocol (peer, protocols, options) {\n    const { id, multiaddrs } = getPeer(peer)\n    let connection = this.connectionManager.get(id)\n\n    if (!connection) {\n      connection = await this.dialer.connectToPeer(peer, options)\n    } else if (multiaddrs) {\n      this.peerStore.addressBook.add(id, multiaddrs)\n    }\n\n    // If a protocol was provided, create a new stream\n    if (protocols) {\n      return connection.newStream(protocols)\n    }\n\n    return connection\n  }\n\n  /**\n   * Get peer advertising multiaddrs by concating the addresses used\n   * by transports to listen with the announce addresses.\n   * Duplicated addresses and noAnnounce addresses are filtered out.\n   * @return {Array<Multiaddr>}\n   */\n  get multiaddrs () {\n    // Filter noAnnounce multiaddrs\n    const filterMa = this.addressManager.getNoAnnounceAddrs()\n\n    // Create advertising list\n    return this.transportManager.getAddrs()\n      .concat(this.addressManager.getAnnounceAddrs())\n      .filter((ma, index, array) => {\n        // Filter out if repeated\n        if (array.findIndex((otherMa) => otherMa.equals(ma)) !== index) {\n          return false\n        }\n\n        // Filter out if in noAnnounceMultiaddrs\n        if (filterMa.find((fm) => fm.equals(ma))) {\n          return false\n        }\n\n        return true\n      })\n  }\n\n  /**\n   * Disconnects all connections to the given `peer`\n   * @param {PeerId|multiaddr|string} peer the peer to close connections to\n   * @returns {Promise<void>}\n   */\n  async hangUp (peer) {\n    const { id } = getPeer(peer)\n\n    const connections = this.connectionManager.connections.get(id.toB58String())\n\n    if (!connections) {\n      return\n    }\n\n    await Promise.all(\n      connections.map(connection => {\n        return connection.close()\n      })\n    )\n  }\n\n  /**\n   * Pings the given peer in order to obtain the operation latency.\n   * @param {PeerId|Multiaddr|string} peer The peer to ping\n   * @returns {Promise<number>}\n   */\n  ping (peer) {\n    const { id, multiaddrs } = getPeer(peer)\n\n    // If received multiaddr, ping it\n    if (multiaddrs) {\n      return ping(this, multiaddrs[0])\n    }\n\n    return ping(this, id)\n  }\n\n  /**\n   * Registers the `handler` for each protocol\n   * @param {string[]|string} protocols\n   * @param {function({ connection:*, stream:*, protocol:string })} handler\n   */\n  handle (protocols, handler) {\n    protocols = Array.isArray(protocols) ? protocols : [protocols]\n    protocols.forEach(protocol => {\n      this.upgrader.protocols.set(protocol, handler)\n    })\n\n    // Only push if libp2p is running\n    if (this.isStarted() && this.identifyService) {\n      this.identifyService.pushToPeerStore(this.peerStore)\n    }\n  }\n\n  /**\n   * Removes the handler for each protocol. The protocol\n   * will no longer be supported on streams.\n   * @param {string[]|string} protocols\n   */\n  unhandle (protocols) {\n    protocols = Array.isArray(protocols) ? protocols : [protocols]\n    protocols.forEach(protocol => {\n      this.upgrader.protocols.delete(protocol)\n    })\n\n    // Only push if libp2p is running\n    if (this.isStarted() && this.identifyService) {\n      this.identifyService.pushToPeerStore(this.peerStore)\n    }\n  }\n\n  async _onStarting () {\n    // Listen on the provided transports\n    await this.transportManager.listen()\n\n    // Start PeerStore\n    await this.peerStore.start()\n\n    if (this._config.pubsub.enabled) {\n      this.pubsub && this.pubsub.start()\n    }\n\n    // DHT subsystem\n    if (this._config.dht.enabled) {\n      this._dht && this._dht.start()\n\n      // TODO: this should be modified once random-walk is used as\n      // the other discovery modules\n      this._dht.on('peer', this._onDiscoveryPeer)\n    }\n\n    // Start metrics if present\n    this.metrics && this.metrics.start()\n  }\n\n  /**\n   * Called when libp2p has started and before it returns\n   * @private\n   */\n  async _onDidStart () {\n    this._isStarted = true\n\n    this.peerStore.on('peer', peerId => {\n      this.emit('peer:discovery', peerId)\n      this._maybeConnect(peerId)\n    })\n\n    // Once we start, emit any peers we may have already discovered\n    // TODO: this should be removed, as we already discovered these peers in the past\n    for (const peer of this.peerStore.peers.values()) {\n      this.emit('peer:discovery', peer.id)\n    }\n\n    this.connectionManager.start()\n\n    // Peer discovery\n    await this._setupPeerDiscovery()\n  }\n\n  /**\n   * Called whenever peer discovery services emit `peer` events.\n   * Known peers may be emitted.\n   * @private\n   * @param {{ id: PeerId, multiaddrs: Array<Multiaddr>, protocols: Array<string> }} peer\n   */\n  _onDiscoveryPeer (peer) {\n    if (peer.id.toB58String() === this.peerId.toB58String()) {\n      log.error(new Error(codes.ERR_DISCOVERED_SELF))\n      return\n    }\n\n    peer.multiaddrs && this.peerStore.addressBook.add(peer.id, peer.multiaddrs)\n    peer.protocols && this.peerStore.protoBook.set(peer.id, peer.protocols)\n  }\n\n  /**\n   * Will dial to the given `peerId` if the current number of\n   * connected peers is less than the configured `ConnectionManager`\n   * minConnections.\n   * @private\n   * @param {PeerId} peerId\n   */\n  async _maybeConnect (peerId) {\n    // If auto dialing is on and we have no connection to the peer, check if we should dial\n    if (this._config.peerDiscovery.autoDial === true && !this.connectionManager.get(peerId)) {\n      const minConnections = this._options.connectionManager.minConnections || 0\n      if (minConnections > this.connectionManager.size) {\n        log('connecting to discovered peer %s', peerId.toB58String())\n        try {\n          await this.dialer.connectToPeer(peerId)\n        } catch (err) {\n          log.error('could not connect to discovered peer', err)\n        }\n      }\n    }\n  }\n\n  /**\n   * Initializes and starts peer discovery services\n   *\n   * @async\n   * @private\n   */\n  async _setupPeerDiscovery () {\n    const setupService = (DiscoveryService) => {\n      let config = {\n        enabled: true // on by default\n      }\n\n      if (DiscoveryService.tag &&\n        this._config.peerDiscovery &&\n        this._config.peerDiscovery[DiscoveryService.tag]) {\n        config = { ...config, ...this._config.peerDiscovery[DiscoveryService.tag] }\n      }\n\n      if (config.enabled &&\n        !this._discovery.has(DiscoveryService.tag)) { // not already added\n        let discoveryService\n\n        if (typeof DiscoveryService === 'function') {\n          discoveryService = new DiscoveryService(Object.assign({}, config, {\n            peerId: this.peerId,\n            libp2p: this\n          }))\n        } else {\n          discoveryService = DiscoveryService\n        }\n\n        discoveryService.on('peer', this._onDiscoveryPeer)\n        this._discovery.set(DiscoveryService.tag, discoveryService)\n      }\n    }\n\n    // Discovery modules\n    for (const DiscoveryService of this._modules.peerDiscovery || []) {\n      setupService(DiscoveryService)\n    }\n\n    // Transport modules with discovery\n    for (const Transport of this.transportManager.getTransports()) {\n      if (Transport.discovery) {\n        setupService(Transport.discovery)\n      }\n    }\n\n    await Promise.all(Array.from(this._discovery.values(), d => d.start()))\n  }\n}\n\n/**\n * Like `new Libp2p(options)` except it will create a `PeerId`\n * instance if one is not provided in options.\n * @param {object} options Libp2p configuration options\n * @returns {Libp2p}\n */\nLibp2p.create = async function create (options = {}) {\n  if (options.peerId) {\n    return new Libp2p(options)\n  }\n\n  const peerId = await PeerId.create()\n\n  options.peerId = peerId\n  return new Libp2p(options)\n}\n\nmodule.exports = Libp2p\n"]},"metadata":{},"sourceType":"script"}