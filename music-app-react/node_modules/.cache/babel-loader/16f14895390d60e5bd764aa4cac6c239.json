{"ast":null,"code":"'use strict';\n\nconst tempdir = require('ipfs-utils/src/temp-dir');\n\nconst TextEncoder = require('ipfs-utils/src/text-encoder');\n\nconst TextDecoder = require('ipfs-utils/src/text-decoder');\n\nexports.utf8Encoder = new TextEncoder('utf8');\nexports.utf8Decoder = new TextDecoder('utf8');\n\nexports.filter = (iterable, filterer) => {\n  return async function* () {\n    for await (const value of iterable) {\n      const keep = await filterer(value);\n      if (!keep) continue;\n      yield value;\n    }\n  }();\n}; // Not just sort, because the sorter is given all the values and should return\n// them all sorted\n\n\nexports.sortAll = (iterable, sorter) => {\n  return async function* () {\n    let values = [];\n\n    for await (const value of iterable) values.push(value);\n\n    values = await sorter(values);\n\n    for (const value of values) yield value;\n  }();\n};\n\nexports.take = (iterable, n) => {\n  return async function* () {\n    if (n <= 0) return;\n    let i = 0;\n\n    for await (const value of iterable) {\n      yield value;\n      i++;\n      if (i >= n) return;\n    }\n  }();\n};\n\nexports.map = (iterable, mapper) => {\n  return async function* () {\n    for await (const value of iterable) {\n      yield mapper(value);\n    }\n  }();\n};\n\nexports.replaceStartWith = function (s, r) {\n  const matcher = new RegExp('^' + r);\n  return s.replace(matcher, '');\n};\n\nexports.tmpdir = tempdir;","map":{"version":3,"sources":["/home/user/orbit-playground/music-app/node_modules/interface-datastore/src/utils.js"],"names":["tempdir","require","TextEncoder","TextDecoder","exports","utf8Encoder","utf8Decoder","filter","iterable","filterer","value","keep","sortAll","sorter","values","push","take","n","i","map","mapper","replaceStartWith","s","r","matcher","RegExp","replace","tmpdir"],"mappings":"AAAA;;AAEA,MAAMA,OAAO,GAAGC,OAAO,CAAC,yBAAD,CAAvB;;AACA,MAAMC,WAAW,GAAGD,OAAO,CAAC,6BAAD,CAA3B;;AACA,MAAME,WAAW,GAAGF,OAAO,CAAC,6BAAD,CAA3B;;AAEAG,OAAO,CAACC,WAAR,GAAsB,IAAIH,WAAJ,CAAgB,MAAhB,CAAtB;AACAE,OAAO,CAACE,WAAR,GAAsB,IAAIH,WAAJ,CAAgB,MAAhB,CAAtB;;AAEAC,OAAO,CAACG,MAAR,GAAiB,CAACC,QAAD,EAAWC,QAAX,KAAwB;AACvC,SAAQ,mBAAoB;AAC1B,eAAW,MAAMC,KAAjB,IAA0BF,QAA1B,EAAoC;AAClC,YAAMG,IAAI,GAAG,MAAMF,QAAQ,CAACC,KAAD,CAA3B;AACA,UAAI,CAACC,IAAL,EAAW;AACX,YAAMD,KAAN;AACD;AACF,GANM,EAAP;AAOD,CARD,C,CAUA;AACA;;;AACAN,OAAO,CAACQ,OAAR,GAAkB,CAACJ,QAAD,EAAWK,MAAX,KAAsB;AACtC,SAAQ,mBAAoB;AAC1B,QAAIC,MAAM,GAAG,EAAb;;AACA,eAAW,MAAMJ,KAAjB,IAA0BF,QAA1B,EAAoCM,MAAM,CAACC,IAAP,CAAYL,KAAZ;;AACpCI,IAAAA,MAAM,GAAG,MAAMD,MAAM,CAACC,MAAD,CAArB;;AACA,SAAK,MAAMJ,KAAX,IAAoBI,MAApB,EAA4B,MAAMJ,KAAN;AAC7B,GALM,EAAP;AAMD,CAPD;;AASAN,OAAO,CAACY,IAAR,GAAe,CAACR,QAAD,EAAWS,CAAX,KAAiB;AAC9B,SAAQ,mBAAoB;AAC1B,QAAIA,CAAC,IAAI,CAAT,EAAY;AACZ,QAAIC,CAAC,GAAG,CAAR;;AACA,eAAW,MAAMR,KAAjB,IAA0BF,QAA1B,EAAoC;AAClC,YAAME,KAAN;AACAQ,MAAAA,CAAC;AACD,UAAIA,CAAC,IAAID,CAAT,EAAY;AACb;AACF,GARM,EAAP;AASD,CAVD;;AAYAb,OAAO,CAACe,GAAR,GAAc,CAACX,QAAD,EAAWY,MAAX,KAAsB;AAClC,SAAQ,mBAAoB;AAC1B,eAAW,MAAMV,KAAjB,IAA0BF,QAA1B,EAAoC;AAClC,YAAMY,MAAM,CAACV,KAAD,CAAZ;AACD;AACF,GAJM,EAAP;AAKD,CAND;;AAQAN,OAAO,CAACiB,gBAAR,GAA2B,UAAUC,CAAV,EAAaC,CAAb,EAAgB;AACzC,QAAMC,OAAO,GAAG,IAAIC,MAAJ,CAAW,MAAMF,CAAjB,CAAhB;AACA,SAAOD,CAAC,CAACI,OAAF,CAAUF,OAAV,EAAmB,EAAnB,CAAP;AACD,CAHD;;AAKApB,OAAO,CAACuB,MAAR,GAAiB3B,OAAjB","sourcesContent":["'use strict'\n\nconst tempdir = require('ipfs-utils/src/temp-dir')\nconst TextEncoder = require('ipfs-utils/src/text-encoder')\nconst TextDecoder = require('ipfs-utils/src/text-decoder')\n\nexports.utf8Encoder = new TextEncoder('utf8')\nexports.utf8Decoder = new TextDecoder('utf8')\n\nexports.filter = (iterable, filterer) => {\n  return (async function * () {\n    for await (const value of iterable) {\n      const keep = await filterer(value)\n      if (!keep) continue\n      yield value\n    }\n  })()\n}\n\n// Not just sort, because the sorter is given all the values and should return\n// them all sorted\nexports.sortAll = (iterable, sorter) => {\n  return (async function * () {\n    let values = []\n    for await (const value of iterable) values.push(value)\n    values = await sorter(values)\n    for (const value of values) yield value\n  })()\n}\n\nexports.take = (iterable, n) => {\n  return (async function * () {\n    if (n <= 0) return\n    let i = 0\n    for await (const value of iterable) {\n      yield value\n      i++\n      if (i >= n) return\n    }\n  })()\n}\n\nexports.map = (iterable, mapper) => {\n  return (async function * () {\n    for await (const value of iterable) {\n      yield mapper(value)\n    }\n  })()\n}\n\nexports.replaceStartWith = function (s, r) {\n  const matcher = new RegExp('^' + r)\n  return s.replace(matcher, '')\n}\n\nexports.tmpdir = tempdir\n"]},"metadata":{},"sourceType":"script"}