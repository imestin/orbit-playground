{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n/* eslint-disable @typescript-eslint/ban-ts-comment */\n// @ts-ignore\n\n\nconst pubsub_1 = require(\"libp2p-interfaces/src/pubsub\");\n\nconst message_cache_1 = require(\"./message-cache\");\n\nconst message_1 = require(\"./message\");\n\nconst constants = __importStar(require(\"./constants\"));\n\nconst heartbeat_1 = require(\"./heartbeat\");\n\nconst get_gossip_peers_1 = require(\"./get-gossip-peers\");\n\nconst utils_1 = require(\"./utils\");\n\nconst score_1 = require(\"./score\");\n\nconst tracer_1 = require(\"./tracer\"); // @ts-ignore\n\n\nconst TimeCache = require(\"time-cache\");\n\nconst PeerId = require(\"peer-id\"); // @ts-ignore\n\n\nconst Envelope = require(\"libp2p/src/record/envelope\"); // @ts-ignore\n\n\nconst Pubsub = require(\"libp2p-interfaces/src/pubsub\");\n\nclass Gossipsub extends Pubsub {\n  // TODO: add remaining props\n\n  /**\n   * @param {Libp2p} libp2p\n   * @param {Object} [options]\n   * @param {bool} [options.emitSelf] if publish should emit to self, if subscribed, defaults to false\n   * @param {bool} [options.gossipIncoming] if incoming messages on a subscribed topic should be automatically gossiped, defaults to true\n   * @param {bool} [options.fallbackToFloodsub] if dial should fallback to floodsub, defaults to true\n   * @param {bool} [options.floodPublish] if self-published messages should be sent to all peers, defaults to true\n   * @param {bool} [options.doPX] whether PX is enabled; this should be enabled in bootstrappers and other well connected/trusted nodes. defaults to false\n   * @param {function} [options.msgIdFn] override the default message id function\n   * @param {Object} [options.messageCache] override the default MessageCache\n   * @param {bool} [options.signMessages] if we want to sign outgoing messages or not (default: true)\n   * @param {bool} [options.strictSigning] if message signing is required for incoming messages or not (default: true)\n   * @param {Object} [options.scoreParams] peer score parameters\n   * @param {Object} [options.scoreThresholds] peer score thresholds\n   * @param {AddrInfo[]} [options.directPeers] peers with which we will maintain direct connections\n   * @constructor\n   */\n  constructor(libp2p, options = {}) {\n    const multicodecs = [constants.GossipsubIDv11, constants.GossipsubIDv10];\n    const opts = Object.assign(Object.assign({\n      gossipIncoming: true,\n      fallbackToFloodsub: true,\n      floodPublish: true,\n      doPX: false,\n      directPeers: [],\n      D: constants.GossipsubD,\n      Dlo: constants.GossipsubDlo,\n      Dhi: constants.GossipsubDhi,\n      Dscore: constants.GossipsubDscore,\n      Dout: constants.GossipsubDout,\n      Dlazy: constants.GossipsubDlazy,\n      signMessages: true,\n      strictSigning: true\n    }, options), {\n      scoreParams: score_1.createPeerScoreParams(options.scoreParams),\n      scoreThresholds: score_1.createPeerScoreThresholds(options.scoreThresholds)\n    }); // Also wants to get notified of peers connected using floodsub\n\n    if (opts.fallbackToFloodsub) {\n      multicodecs.push(constants.FloodsubID);\n    }\n\n    super(Object.assign({\n      debugName: 'libp2p:gossipsub',\n      multicodecs,\n      libp2p\n    }, opts));\n    this._options = opts;\n    /**\n     * Direct peers\n     * @type {Set<string>}\n     */\n\n    this.direct = new Set(opts.directPeers.map(p => p.id.toB58String())); // set direct peer addresses in the address book\n\n    opts.directPeers.forEach(p => {\n      libp2p.peerStore.addressBook.add(p.id, p.addrs);\n    });\n    /**\n     * Cache of seen messages\n     *\n     * @type {TimeCache}\n     */\n\n    this.seenCache = new TimeCache();\n    /**\n     * Map of topic meshes\n     * topic => peer id set\n     *\n     * @type {Map<string, Set<string>>}\n     */\n\n    this.mesh = new Map();\n    /**\n     * Map of topics to set of peers. These mesh peers are the ones to which we are publishing without a topic membership\n     * topic => peer id set\n     *\n     * @type {Map<string, Set<string>>}\n     */\n\n    this.fanout = new Map();\n    /**\n     * Map of last publish time for fanout topics\n     * topic => last publish time\n     *\n     * @type {Map<string, number>}\n     */\n\n    this.lastpub = new Map();\n    /**\n     * Map of pending messages to gossip\n     * peer id => control messages\n     *\n     * @type {Map<string, Array<ControlIHave object>> }\n     */\n\n    this.gossip = new Map();\n    /**\n     * Map of control messages\n     * peer id => control message\n     *\n     * @type {Map<string, ControlMessage object>}\n     */\n\n    this.control = new Map();\n    /**\n     * Number of IHAVEs received from peer in the last heartbeat\n     * @type {Map<string, number>}\n     */\n\n    this.peerhave = new Map();\n    /**\n     * Number of messages we have asked from peer in the last heartbeat\n     * @type {Map<string, number>}\n     */\n\n    this.iasked = new Map();\n    /**\n     * Prune backoff map\n     */\n\n    this.backoff = new Map();\n    /**\n     * Connection direction cache, marks peers with outbound connections\n     * peer id => direction\n     *\n     * @type {Map<string, boolean>}\n     */\n\n    this.outbound = new Map();\n    /**\n     * Use the overriden mesgIdFn or the default one.\n     */\n\n    this.defaultMsgIdFn = msg => pubsub_1.utils.msgId(msg.from, msg.seqno);\n\n    this._msgIdFn = options.msgIdFn || this.defaultMsgIdFn;\n    /**\n     * A message cache that contains the messages for last few hearbeat ticks\n     *\n     */\n\n    this.messageCache = options.messageCache || new message_cache_1.MessageCache(constants.GossipsubHistoryGossip, constants.GossipsubHistoryLength, this._msgIdFn);\n    /**\n     * A heartbeat timer that maintains the mesh\n     */\n\n    this.heartbeat = new heartbeat_1.Heartbeat(this);\n    /**\n     * Number of heartbeats since the beginning of time\n     * This allows us to amortize some resource cleanup -- eg: backoff cleanup\n     */\n\n    this.heartbeatTicks = 0;\n    /**\n     * Tracks IHAVE/IWANT promises broken by peers\n     */\n\n    this.gossipTracer = new tracer_1.IWantTracer(this._msgIdFn);\n    /**\n     * libp2p\n     */\n\n    this._libp2p = libp2p;\n    /**\n     * Peer score tracking\n     */\n\n    this.score = new score_1.PeerScore(this._options.scoreParams, libp2p.connectionManager, this._msgIdFn);\n  }\n  /**\n   * Decode a Uint8Array into an RPC object\n   * Overrided to use an extended protocol-specific protobuf decoder\n   * @override\n   * @param {Uint8Array} bytes\n   * @returns {RPC}\n   */\n\n\n  _decodeRpc(bytes) {\n    return message_1.RPCCodec.decode(bytes);\n  }\n  /**\n   * Encode an RPC object into a Uint8Array\n   * Overrided to use an extended protocol-specific protobuf encoder\n   * @override\n   * @param {RPC} rpc\n   * @returns {Uint8Array}\n   */\n\n\n  _encodeRpc(rpc) {\n    return message_1.RPCCodec.encode(rpc);\n  }\n  /**\n   * Add a peer to the router\n   * @override\n   * @param {PeerId} peerId\n   * @param {string} protocol\n   * @returns {PeerStreams}\n   */\n\n\n  _addPeer(peerId, protocol) {\n    const p = super._addPeer(peerId, protocol); // Add to peer scoring\n\n\n    this.score.addPeer(peerId.toB58String()); // track the connection direction\n\n    let outbound = false;\n\n    for (const c of this._libp2p.connectionManager.getAll(peerId)) {\n      if (c.stat.direction === 'outbound') {\n        if (Array.from(c.registry.values()).some(rvalue => protocol === rvalue.protocol)) {\n          outbound = true;\n          break;\n        }\n      }\n    }\n\n    this.outbound.set(p, outbound);\n    return p;\n  }\n  /**\n   * Removes a peer from the router\n   * @override\n   * @param {PeerId} peer\n   * @returns {Peer}\n   */\n\n\n  _removePeer(peerId) {\n    const peerStreams = super._removePeer(peerId);\n\n    const id = peerId.toB58String(); // Remove this peer from the mesh\n    // eslint-disable-next-line no-unused-vars\n\n    for (const peers of this.mesh.values()) {\n      peers.delete(id);\n    } // Remove this peer from the fanout\n    // eslint-disable-next-line no-unused-vars\n\n\n    for (const peers of this.fanout.values()) {\n      peers.delete(id);\n    } // Remove from gossip mapping\n\n\n    this.gossip.delete(id); // Remove from control mapping\n\n    this.control.delete(id); // Remove from backoff mapping\n\n    this.outbound.delete(id); // Remove from peer scoring\n\n    this.score.removePeer(id);\n    return peerStreams;\n  }\n  /**\n   * Handles an rpc request from a peer\n   *\n   * @override\n   * @param {String} idB58Str\n   * @param {PeerStreams} peerStreams\n   * @param {RPC} rpc\n   * @returns {boolean}\n   */\n\n\n  _processRpc(id, peerStreams, rpc) {\n    if (super._processRpc(id, peerStreams, rpc)) {\n      if (rpc.control) {\n        this._processRpcControlMessage(id, rpc.control);\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Handles an rpc control message from a peer\n   * @param {string} id peer id\n   * @param {ControlMessage} controlMsg\n   * @returns {void}\n   */\n\n\n  _processRpcControlMessage(id, controlMsg) {\n    if (!controlMsg) {\n      return;\n    }\n\n    const iwant = this._handleIHave(id, controlMsg.ihave);\n\n    const ihave = this._handleIWant(id, controlMsg.iwant);\n\n    const prune = this._handleGraft(id, controlMsg.graft);\n\n    this._handlePrune(id, controlMsg.prune);\n\n    if (!iwant.length && !ihave.length && !prune.length) {\n      return;\n    }\n\n    const outRpc = utils_1.createGossipRpc(ihave, {\n      iwant,\n      prune\n    });\n\n    this._sendRpc(id, outRpc);\n  }\n  /**\n   * Process incoming message,\n   * emitting locally and forwarding on to relevant floodsub and gossipsub peers\n   * @override\n   * @param {InMessage} msg\n   * @returns {Promise<void>}\n   */\n\n\n  _processRpcMessage(msg) {\n    const _super = Object.create(null, {\n      _processRpcMessage: {\n        get: () => super._processRpcMessage\n      }\n    });\n\n    return __awaiter(this, void 0, void 0, function* () {\n      const msgID = this.getMsgId(msg); // Ignore if we've already seen the message\n\n      if (this.seenCache.has(msgID)) {\n        this.score.duplicateMessage(msg);\n        return;\n      }\n\n      this.seenCache.put(msgID);\n      this.score.validateMessage(msg);\n      yield _super._processRpcMessage.call(this, msg);\n    });\n  }\n  /**\n   * Whether to accept a message from a peer\n   * @override\n   * @param {string} id\n   * @returns {boolean}\n   */\n\n\n  _acceptFrom(id) {\n    return this.direct.has(id) || this.score.score(id) >= this._options.scoreThresholds.graylistThreshold;\n  }\n  /**\n   * Validate incoming message\n   * @override\n   * @param {InMessage} message\n   * @returns {Promise<void>}\n   */\n\n\n  validate(message) {\n    const _super = Object.create(null, {\n      validate: {\n        get: () => super.validate\n      }\n    });\n\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        yield _super.validate.call(this, message);\n      } catch (e) {\n        this.score.rejectMessage(message, e.code);\n        this.gossipTracer.rejectMessage(message, e.code);\n        throw e;\n      }\n    });\n  }\n  /**\n   * Handles IHAVE messages\n   * @param {string} id peer id\n   * @param {Array<ControlIHave>} ihave\n   * @returns {ControlIWant}\n   */\n\n\n  _handleIHave(id, ihave) {\n    if (!ihave.length) {\n      return [];\n    } // we ignore IHAVE gossip from any peer whose score is below the gossips threshold\n\n\n    const score = this.score.score(id);\n\n    if (score < this._options.scoreThresholds.gossipThreshold) {\n      this.log('IHAVE: ignoring peer %s with score below threshold [ score = %d ]', id, score);\n      return [];\n    } // IHAVE flood protection\n\n\n    const peerhave = (this.peerhave.get(id) || 0) + 1;\n    this.peerhave.set(id, peerhave);\n\n    if (peerhave > constants.GossipsubMaxIHaveMessages) {\n      this.log('IHAVE: peer %s has advertised too many times (%d) within this heartbeat interval; ignoring', id, peerhave);\n      return [];\n    }\n\n    const iasked = this.iasked.get(id) || 0;\n\n    if (iasked >= constants.GossipsubMaxIHaveLength) {\n      this.log('IHAVE: peer %s has already advertised too many messages (%d); ignoring', id, iasked);\n      return [];\n    }\n\n    const iwant = new Set();\n    ihave.forEach(({\n      topicID,\n      messageIDs\n    }) => {\n      if (!topicID || !this.mesh.has(topicID)) {\n        return;\n      }\n\n      messageIDs.forEach(msgID => {\n        if (this.seenCache.has(msgID)) {\n          return;\n        }\n\n        iwant.add(msgID);\n      });\n    });\n\n    if (!iwant.size) {\n      return [];\n    }\n\n    let iask = iwant.size;\n\n    if (iask + iasked > constants.GossipsubMaxIHaveLength) {\n      iask = constants.GossipsubMaxIHaveLength - iasked;\n    }\n\n    this.log('IHAVE: Asking for %d out of %d messages from %s', iask, iwant.size, id);\n    let iwantList = Array.from(iwant); // ask in random order\n\n    utils_1.shuffle(iwantList); // truncate to the messages we are actually asking for and update the iasked counter\n\n    iwantList = iwantList.slice(0, iask);\n    this.iasked.set(id, iasked + iask);\n    this.gossipTracer.addPromise(id, iwantList);\n    return [{\n      messageIDs: iwantList\n    }];\n  }\n  /**\n   * Handles IWANT messages\n   * Returns messages to send back to peer\n   * @param {string} id peer id\n   * @param {Array<ControlIWant>} iwant\n   * @returns {Array<Message>}\n   */\n\n\n  _handleIWant(id, iwant) {\n    if (!iwant.length) {\n      return [];\n    } // we don't respond to IWANT requests from any per whose score is below the gossip threshold\n\n\n    const score = this.score.score(id);\n\n    if (score < this._options.scoreThresholds.gossipThreshold) {\n      this.log('IWANT: ignoring peer %s with score below threshold [score = %d]', id, score);\n      return [];\n    } // @type {Map<string, Message>}\n\n\n    const ihave = new Map();\n    iwant.forEach(({\n      messageIDs\n    }) => {\n      messageIDs.forEach(msgID => {\n        const [msg, count] = this.messageCache.getForPeer(msgID, id);\n\n        if (!msg) {\n          return;\n        }\n\n        if (count > constants.GossipsubGossipRetransmission) {\n          this.log('IWANT: Peer %s has asked for message %s too many times: ignoring request', id, msgID);\n          return;\n        }\n\n        ihave.set(msgID, msg);\n      });\n    });\n\n    if (!ihave.size) {\n      return [];\n    }\n\n    this.log('IWANT: Sending %d messages to %s', ihave.size, id);\n    return Array.from(ihave.values()).map(pubsub_1.utils.normalizeOutRpcMessage);\n  }\n  /**\n   * Handles Graft messages\n   * @param {string} id peer id\n   * @param {Array<ControlGraft>} graft\n   * @return {Array<ControlPrune>}\n   */\n\n\n  _handleGraft(id, graft) {\n    const prune = [];\n    const score = this.score.score(id);\n\n    const now = this._now();\n\n    let doPX = this._options.doPX;\n    graft.forEach(({\n      topicID\n    }) => {\n      var _a;\n\n      if (!topicID) {\n        return;\n      }\n\n      const peersInMesh = this.mesh.get(topicID);\n\n      if (!peersInMesh) {\n        // don't do PX when there is an unknown topic to avoid leaking our peers\n        doPX = false; // spam hardening: ignore GRAFTs for unknown topics\n\n        return;\n      } // check if peer is already in the mesh; if so do nothing\n\n\n      if (peersInMesh.has(id)) {\n        return;\n      } // we don't GRAFT to/from direct peers; complain loudly if this happens\n\n\n      if (this.direct.has(id)) {\n        this.log('GRAFT: ignoring request from direct peer %s', id); // this is possibly a bug from a non-reciprical configuration; send a PRUNE\n\n        prune.push(topicID); // but don't px\n\n        doPX = false;\n        return;\n      } // make sure we are not backing off that peer\n\n\n      const expire = (_a = this.backoff.get(topicID)) === null || _a === void 0 ? void 0 : _a.get(id);\n\n      if (typeof expire === 'number' && now < expire) {\n        this.log('GRAFT: ignoring backed off peer %s', id); // add behavioral penalty\n\n        this.score.addPenalty(id, 1); // no PX\n\n        doPX = false; // check the flood cutoff -- is the GRAFT coming too fast?\n\n        const floodCutoff = expire + constants.GossipsubGraftFloodThreshold - constants.GossipsubPruneBackoff;\n\n        if (now < floodCutoff) {\n          // extra penalty\n          this.score.addPenalty(id, 1);\n        } // refresh the backoff\n\n\n        this._addBackoff(id, topicID);\n\n        prune.push(topicID);\n        return;\n      } // check the score\n\n\n      if (score < 0) {\n        // we don't GRAFT peers with negative score\n        this.log('GRAFT: ignoring peer %s with negative score: score=%d, topic=%s', id, score, topicID); // we do send them PRUNE however, because it's a matter of protocol correctness\n\n        prune.push(topicID); // but we won't PX to them\n\n        doPX = false; // add/refresh backoff so that we don't reGRAFT too early even if the score decays\n\n        this._addBackoff(id, topicID);\n\n        return;\n      } // check the number of mesh peers; if it is at (or over) Dhi, we only accept grafts\n      // from peers with outbound connections; this is a defensive check to restrict potential\n      // mesh takeover attacks combined with love bombing\n\n\n      if (peersInMesh.size >= this._options.Dhi && !this.outbound.get(id)) {\n        prune.push(topicID);\n\n        this._addBackoff(id, topicID);\n\n        return;\n      }\n\n      this.log('GRAFT: Add mesh link from %s in %s', id, topicID);\n      this.score.graft(id, topicID);\n      peersInMesh.add(id);\n    });\n\n    if (!prune.length) {\n      return [];\n    }\n\n    return prune.map(topic => this._makePrune(id, topic, doPX));\n  }\n  /**\n   * Handles Prune messages\n   * @param {string} id peer id\n   * @param {Array<ControlPrune>} prune\n   * @returns {void}\n   */\n\n\n  _handlePrune(id, prune) {\n    const score = this.score.score(id);\n    prune.forEach(({\n      topicID,\n      backoff,\n      peers\n    }) => {\n      if (!topicID) {\n        return;\n      }\n\n      const peersInMesh = this.mesh.get(topicID);\n\n      if (!peersInMesh) {\n        return;\n      }\n\n      this.log('PRUNE: Remove mesh link to %s in %s', id, topicID);\n      this.score.prune(id, topicID);\n      peersInMesh.delete(id); // is there a backoff specified by the peer? if so obey it\n\n      if (typeof backoff === 'number' && backoff > 0) {\n        this._doAddBackoff(id, topicID, backoff * 1000);\n      } else {\n        this._addBackoff(id, topicID);\n      } // PX\n\n\n      if (peers && peers.length) {\n        // we ignore PX from peers with insufficient scores\n        if (score < this._options.scoreThresholds.acceptPXThreshold) {\n          this.log('PRUNE: ignoring PX from peer %s with insufficient score [score = %d, topic = %s]', id, score, topicID);\n          return;\n        }\n\n        this._pxConnect(peers);\n      }\n    });\n  }\n  /**\n   * Add standard backoff log for a peer in a topic\n   * @param {string} id\n   * @param {string} topic\n   * @returns {void}\n   */\n\n\n  _addBackoff(id, topic) {\n    this._doAddBackoff(id, topic, constants.GossipsubPruneBackoff);\n  }\n  /**\n   * Add backoff expiry interval for a peer in a topic\n   * @param {string} id\n   * @param {string} topic\n   * @param {number} interval backoff duration in milliseconds\n   * @returns {void}\n   */\n\n\n  _doAddBackoff(id, topic, interval) {\n    let backoff = this.backoff.get(topic);\n\n    if (!backoff) {\n      backoff = new Map();\n      this.backoff.set(topic, backoff);\n    }\n\n    const expire = this._now() + interval;\n    const existingExpire = backoff.get(id) || 0;\n\n    if (existingExpire < expire) {\n      backoff.set(id, expire);\n    }\n  }\n  /**\n   * Apply penalties from broken IHAVE/IWANT promises\n   * @returns {void}\n   */\n\n\n  _applyIwantPenalties() {\n    this.gossipTracer.getBrokenPromises().forEach((count, p) => {\n      this.log('peer %s didn\\'t follow up in %d IWANT requests; adding penalty', p, count);\n      this.score.addPenalty(p, count);\n    });\n  }\n  /**\n   * Clear expired backoff expiries\n   * @returns {void}\n   */\n\n\n  _clearBackoff() {\n    // we only clear once every GossipsubPruneBackoffTicks ticks to avoid iterating over the maps too much\n    if (this.heartbeatTicks % constants.GossipsubPruneBackoffTicks !== 0) {\n      return;\n    }\n\n    const now = this._now();\n\n    this.backoff.forEach((backoff, topic) => {\n      backoff.forEach((expire, id) => {\n        if (expire < now) {\n          backoff.delete(id);\n        }\n      });\n\n      if (backoff.size === 0) {\n        this.backoff.delete(topic);\n      }\n    });\n  }\n  /**\n   * Maybe reconnect to direct peers\n   * @returns {void}\n   */\n\n\n  _directConnect() {\n    // we only do this every few ticks to allow pending connections to complete and account for\n    // restarts/downtime\n    if (this.heartbeatTicks % constants.GossipsubDirectConnectTicks !== 0) {\n      return;\n    }\n\n    const toconnect = [];\n    this.direct.forEach(id => {\n      const peer = this.peers.get(id);\n\n      if (!peer || !peer.isWritable) {\n        toconnect.push(id);\n      }\n    });\n\n    if (toconnect.length) {\n      toconnect.forEach(id => {\n        this._connect(id);\n      });\n    }\n  }\n  /**\n   * Maybe attempt connection given signed peer records\n   * @param {PeerInfo[]} peers\n   * @returns {Promise<void>}\n   */\n\n\n  _pxConnect(peers) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (peers.length > constants.GossipsubPrunePeers) {\n        utils_1.shuffle(peers);\n        peers = peers.slice(0, constants.GossipsubPrunePeers);\n      }\n\n      const toconnect = [];\n      yield Promise.all(peers.map(pi => __awaiter(this, void 0, void 0, function* () {\n        if (!pi.peerID) {\n          return;\n        }\n\n        const p = PeerId.createFromBytes(pi.peerID);\n        const id = p.toB58String();\n\n        if (this.peers.has(id)) {\n          return;\n        }\n\n        if (!pi.signedPeerRecord) {\n          toconnect.push(id);\n          return;\n        } // The peer sent us a signed record\n        // This is not a record from the peer who sent the record, but another peer who is connected with it\n        // Ensure that it is valid\n\n\n        try {\n          const envelope = yield Envelope.openAndCertify(pi.signedPeerRecord, 'libp2p-peer-record');\n          const eid = envelope.peerId.toB58String();\n\n          if (id !== eid) {\n            this.log('bogus peer record obtained through px: peer ID %s doesn\\'t match expected peer %s', eid, id);\n            return;\n          }\n\n          if (!this._libp2p.peerStore.addressBook.consumePeerRecord(envelope)) {\n            this.log('bogus peer record obtained through px: could not add peer record to address book');\n            return;\n          }\n\n          toconnect.push(id);\n        } catch (e) {\n          this.log('bogus peer record obtained through px: invalid signature or not a peer record');\n        }\n      })));\n\n      if (!toconnect.length) {\n        return;\n      }\n\n      toconnect.forEach(id => this._connect(id));\n    });\n  }\n  /**\n   * Mounts the gossipsub protocol onto the libp2p node and sends our\n   * our subscriptions to every peer connected\n   * @override\n   * @returns {void}\n   */\n\n\n  start() {\n    super.start();\n    this.heartbeat.start();\n    this.score.start(); // connect to direct peers\n\n    this._directPeerInitial = setTimeout(() => {\n      this.direct.forEach(id => {\n        this._connect(id);\n      });\n    }, constants.GossipsubDirectConnectInitialDelay);\n  }\n  /**\n   * Unmounts the gossipsub protocol and shuts down every connection\n   * @override\n   * @returns {void}\n   */\n\n\n  stop() {\n    super.stop();\n    this.heartbeat.stop();\n    this.score.stop();\n    this.mesh = new Map();\n    this.fanout = new Map();\n    this.lastpub = new Map();\n    this.gossip = new Map();\n    this.control = new Map();\n    this.peerhave = new Map();\n    this.iasked = new Map();\n    this.backoff = new Map();\n    this.outbound = new Map();\n    this.gossipTracer.clear();\n    clearTimeout(this._directPeerInitial);\n  }\n  /**\n   * Connect to a peer using the gossipsub protocol\n   * @param {string} id\n   * @returns {void}\n   */\n\n\n  _connect(id) {\n    this.log('Initiating connection with %s', id);\n\n    this._libp2p.dialProtocol(PeerId.createFromB58String(id), this.multicodecs);\n  }\n  /**\n   * Subscribes to a topic\n   * @override\n   * @param {string} topic\n   * @returns {void}\n   */\n\n\n  subscribe(topic) {\n    super.subscribe(topic);\n    this.join(topic);\n  }\n  /**\n   * Unsubscribe to a topic\n   * @override\n   * @param {string} topic\n   * @returns {void}\n   */\n\n\n  unsubscribe(topic) {\n    super.unsubscribe(topic);\n    this.leave(topic);\n  }\n  /**\n   * Join topic\n   * @param {string} topic\n   * @returns {void}\n   */\n\n\n  join(topic) {\n    if (!this.started) {\n      throw new Error('Gossipsub has not started');\n    }\n\n    this.log('JOIN %s', topic);\n    const fanoutPeers = this.fanout.get(topic);\n\n    if (fanoutPeers) {\n      // these peers have a score above the publish threshold, which may be negative\n      // so drop the ones with a negative score\n      fanoutPeers.forEach(id => {\n        if (this.score.score(id) < 0) {\n          fanoutPeers.delete(id);\n        }\n      });\n\n      if (fanoutPeers.size < this._options.D) {\n        // we need more peers; eager, as this would get fixed in the next heartbeat\n        get_gossip_peers_1.getGossipPeers(this, topic, this._options.D - fanoutPeers.size, id => {\n          // filter our current peers, direct peers, and peers with negative scores\n          return !fanoutPeers.has(id) && !this.direct.has(id) && this.score.score(id) >= 0;\n        }).forEach(id => fanoutPeers.add(id));\n      }\n\n      this.mesh.set(topic, fanoutPeers);\n      this.fanout.delete(topic);\n      this.lastpub.delete(topic);\n    } else {\n      const peers = get_gossip_peers_1.getGossipPeers(this, topic, this._options.D, id => {\n        // filter direct peers and peers with negative score\n        return !this.direct.has(id) && this.score.score(id) >= 0;\n      });\n      this.mesh.set(topic, peers);\n    }\n\n    this.mesh.get(topic).forEach(id => {\n      this.log('JOIN: Add mesh link to %s in %s', id, topic);\n\n      this._sendGraft(id, topic);\n    });\n  }\n  /**\n   * Leave topic\n   * @param {string} topic\n   * @returns {void}\n   */\n\n\n  leave(topic) {\n    if (!this.started) {\n      throw new Error('Gossipsub has not started');\n    }\n\n    this.log('LEAVE %s', topic); // Send PRUNE to mesh peers\n\n    const meshPeers = this.mesh.get(topic);\n\n    if (meshPeers) {\n      meshPeers.forEach(id => {\n        this.log('LEAVE: Remove mesh link to %s in %s', id, topic);\n\n        this._sendPrune(id, topic);\n      });\n      this.mesh.delete(topic);\n    }\n  }\n  /**\n   * Override the default implementation in BasicPubSub.\n   * If we don't provide msgIdFn in constructor option, it's the same.\n   * @override\n   * @param {Message} msg the message object\n   * @returns {string} message id as string\n   */\n\n\n  getMsgId(msg) {\n    return this._msgIdFn(msg);\n  }\n  /**\n   * Publish messages\n   *\n   * @override\n   * @param {InMessage} msg\n   * @returns {void}\n   */\n\n\n  _publish(msg) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (msg.receivedFrom !== this.peerId.toB58String()) {\n        this.score.deliverMessage(msg);\n        this.gossipTracer.deliverMessage(msg);\n      }\n\n      const msgID = this.getMsgId(msg); // put in seen cache\n\n      this.seenCache.put(msgID);\n      this.messageCache.put(msg);\n      const tosend = new Set();\n      msg.topicIDs.forEach(topic => {\n        const peersInTopic = this.topics.get(topic);\n\n        if (!peersInTopic) {\n          return;\n        }\n\n        if (this._options.floodPublish && msg.from === this.peerId.toB58String()) {\n          // flood-publish behavior\n          // send to direct peers and _all_ peers meeting the publishThreshold\n          peersInTopic.forEach(id => {\n            if (this.direct.has(id) || this.score.score(id) >= this._options.scoreThresholds.publishThreshold) {\n              tosend.add(id);\n            }\n          });\n        } else {\n          // non-flood-publish behavior\n          // send to direct peers, subscribed floodsub peers\n          // and some mesh peers above publishThreshold\n          // direct peers\n          this.direct.forEach(id => {\n            tosend.add(id);\n          }); // floodsub peers\n\n          peersInTopic.forEach(id => {\n            const score = this.score.score(id);\n            const peerStreams = this.peers.get(id);\n\n            if (!peerStreams) {\n              return;\n            }\n\n            if (peerStreams.protocol === constants.FloodsubID && score >= this._options.scoreThresholds.publishThreshold) {\n              tosend.add(id);\n            }\n          }); // Gossipsub peers handling\n\n          let meshPeers = this.mesh.get(topic);\n\n          if (!meshPeers || !meshPeers.size) {\n            // We are not in the mesh for topic, use fanout peers\n            meshPeers = this.fanout.get(topic);\n\n            if (!meshPeers) {\n              // If we are not in the fanout, then pick peers in topic above the publishThreshold\n              const peers = get_gossip_peers_1.getGossipPeers(this, topic, this._options.D, id => {\n                return this.score.score(id) >= this._options.scoreThresholds.publishThreshold;\n              });\n\n              if (peers.size > 0) {\n                meshPeers = peers;\n                this.fanout.set(topic, peers);\n              } else {\n                meshPeers = new Set();\n              }\n            } // Store the latest publishing time\n\n\n            this.lastpub.set(topic, this._now());\n          }\n\n          meshPeers.forEach(peer => {\n            tosend.add(peer);\n          });\n        }\n      }); // Publish messages to peers\n\n      const rpc = utils_1.createGossipRpc([pubsub_1.utils.normalizeOutRpcMessage(msg)]);\n      tosend.forEach(id => {\n        if (id === msg.from) {\n          return;\n        }\n\n        this._sendRpc(id, rpc);\n      });\n    });\n  }\n  /**\n   * Sends a GRAFT message to a peer\n   * @param {string} id peer id\n   * @param {string} topic\n   * @returns {void}\n   */\n\n\n  _sendGraft(id, topic) {\n    const graft = [{\n      topicID: topic\n    }];\n    const out = utils_1.createGossipRpc([], {\n      graft\n    });\n\n    this._sendRpc(id, out);\n  }\n  /**\n   * Sends a PRUNE message to a peer\n   * @param {string} id peer id\n   * @param {string} topic\n   * @returns {void}\n   */\n\n\n  _sendPrune(id, topic) {\n    const prune = [this._makePrune(id, topic, this._options.doPX)];\n    const out = utils_1.createGossipRpc([], {\n      prune\n    });\n\n    this._sendRpc(id, out);\n  }\n  /**\n   * @override\n   */\n\n\n  _sendRpc(id, outRpc) {\n    const peerStreams = this.peers.get(id);\n\n    if (!peerStreams || !peerStreams.isWritable) {\n      return;\n    } // piggyback control message retries\n\n\n    const ctrl = this.control.get(id);\n\n    if (ctrl) {\n      this._piggybackControl(id, outRpc, ctrl);\n\n      this.control.delete(id);\n    } // piggyback gossip\n\n\n    const ihave = this.gossip.get(id);\n\n    if (ihave) {\n      this._piggybackGossip(id, outRpc, ihave);\n\n      this.gossip.delete(id);\n    }\n\n    peerStreams.write(message_1.RPCCodec.encode(outRpc));\n  }\n\n  _piggybackControl(id, outRpc, ctrl) {\n    const tograft = (ctrl.graft || []).filter(({\n      topicID\n    }) => (topicID && this.mesh.get(topicID) || new Set()).has(id));\n    const toprune = (ctrl.prune || []).filter(({\n      topicID\n    }) => !(topicID && this.mesh.get(topicID) || new Set()).has(id));\n\n    if (!tograft.length && !toprune.length) {\n      return;\n    }\n\n    if (outRpc.control) {\n      outRpc.control.graft = outRpc.control.graft.concat(tograft);\n      outRpc.control.prune = outRpc.control.prune.concat(toprune);\n    } else {\n      outRpc.control = {\n        ihave: [],\n        iwant: [],\n        graft: tograft,\n        prune: toprune\n      };\n    }\n  }\n\n  _piggybackGossip(id, outRpc, ihave) {\n    if (!outRpc.control) {\n      outRpc.control = {\n        ihave: [],\n        iwant: [],\n        graft: [],\n        prune: []\n      };\n    }\n\n    outRpc.control.ihave = ihave;\n  }\n  /**\n   * Send graft and prune messages\n   * @param {Map<string, Array<string>>} tograft peer id => topic[]\n   * @param {Map<string, Array<string>>} toprune peer id => topic[]\n   */\n\n\n  _sendGraftPrune(tograft, toprune, noPX) {\n    const doPX = this._options.doPX;\n\n    for (const [id, topics] of tograft) {\n      const graft = topics.map(topicID => ({\n        topicID\n      }));\n      let prune = []; // If a peer also has prunes, process them now\n\n      const pruning = toprune.get(id);\n\n      if (pruning) {\n        prune = pruning.map(topicID => this._makePrune(id, topicID, doPX && !noPX.get(id)));\n        toprune.delete(id);\n      }\n\n      const outRpc = utils_1.createGossipRpc([], {\n        graft,\n        prune\n      });\n\n      this._sendRpc(id, outRpc);\n    }\n\n    for (const [id, topics] of toprune) {\n      const prune = topics.map(topicID => this._makePrune(id, topicID, doPX && !noPX.get(id)));\n      const outRpc = utils_1.createGossipRpc([], {\n        prune\n      });\n\n      this._sendRpc(id, outRpc);\n    }\n  }\n  /**\n   * Emits gossip to peers in a particular topic\n   * @param {string} topic\n   * @param {Set<string>} exclude peers to exclude\n   * @returns {void}\n   */\n\n\n  _emitGossip(topic, exclude) {\n    const messageIDs = this.messageCache.getGossipIDs(topic);\n\n    if (!messageIDs.length) {\n      return;\n    } // shuffle to emit in random order\n\n\n    utils_1.shuffle(messageIDs); // if we are emitting more than GossipsubMaxIHaveLength ids, truncate the list\n\n    if (messageIDs.length > constants.GossipsubMaxIHaveLength) {\n      // we do the truncation (with shuffling) per peer below\n      this.log('too many messages for gossip; will truncate IHAVE list (%d messages)', messageIDs.length);\n    } // Send gossip to GossipFactor peers above threshold with a minimum of D_lazy\n    // First we collect the peers above gossipThreshold that are not in the exclude set\n    // and then randomly select from that set\n    // We also exclude direct peers, as there is no reason to emit gossip to them\n\n\n    const peersToGossip = [];\n    const topicPeers = this.topics.get(topic);\n\n    if (!topicPeers) {\n      // no topic peers, no gossip\n      return;\n    }\n\n    topicPeers.forEach(id => {\n      const peerStreams = this.peers.get(id);\n\n      if (!peerStreams) {\n        return;\n      }\n\n      if (!exclude.has(id) && !this.direct.has(id) && utils_1.hasGossipProtocol(peerStreams.protocol) && this.score.score(id) >= this._options.scoreThresholds.gossipThreshold) {\n        peersToGossip.push(id);\n      }\n    });\n    let target = this._options.Dlazy;\n    const factor = constants.GossipsubGossipFactor * peersToGossip.length;\n\n    if (factor > target) {\n      target = factor;\n    }\n\n    if (target > peersToGossip.length) {\n      target = peersToGossip.length;\n    } else {\n      utils_1.shuffle(peersToGossip);\n    } // Emit the IHAVE gossip to the selected peers up to the target\n\n\n    peersToGossip.slice(0, target).forEach(id => {\n      let peerMessageIDs = messageIDs;\n\n      if (messageIDs.length > constants.GossipsubMaxIHaveLength) {\n        // shuffle and slice message IDs per peer so that we emit a different set for each peer\n        // we have enough reduncancy in the system that this will significantly increase the message\n        // coverage when we do truncate\n        peerMessageIDs = utils_1.shuffle(peerMessageIDs.slice()).slice(0, constants.GossipsubMaxIHaveLength);\n      }\n\n      this._pushGossip(id, {\n        topicID: topic,\n        messageIDs: peerMessageIDs\n      });\n    });\n  }\n  /**\n   * Flush gossip and control messages\n   */\n\n\n  _flush() {\n    // send gossip first, which will also piggyback control\n    for (const [peer, ihave] of this.gossip.entries()) {\n      this.gossip.delete(peer);\n      const out = utils_1.createGossipRpc([], {\n        ihave\n      });\n\n      this._sendRpc(peer, out);\n    } // send the remaining control messages\n\n\n    for (const [peer, control] of this.control.entries()) {\n      this.control.delete(peer);\n      const out = utils_1.createGossipRpc([], {\n        graft: control.graft,\n        prune: control.prune\n      });\n\n      this._sendRpc(peer, out);\n    }\n  }\n  /**\n   * Adds new IHAVE messages to pending gossip\n   * @param {PeerStreams} peerStreams\n   * @param {Array<ControlIHave>} controlIHaveMsgs\n   * @returns {void}\n   */\n\n\n  _pushGossip(id, controlIHaveMsgs) {\n    this.log('Add gossip to %s', id);\n    const gossip = this.gossip.get(id) || [];\n    this.gossip.set(id, gossip.concat(controlIHaveMsgs));\n  }\n  /**\n   * Returns the current time in milliseconds\n   * @returns {number}\n   */\n\n\n  _now() {\n    return Date.now();\n  }\n  /**\n   * Make a PRUNE control message for a peer in a topic\n   * @param {string} id\n   * @param {string} topic\n   * @param {boolean} doPX\n   * @returns {ControlPrune}\n   */\n\n\n  _makePrune(id, topic, doPX) {\n    if (this.peers.get(id).protocol === constants.GossipsubIDv10) {\n      // Gossipsub v1.0 -- no backoff, the peer won't be able to parse it anyway\n      return {\n        topicID: topic,\n        peers: []\n      };\n    } // backoff is measured in seconds\n    // GossipsubPruneBackoff is measured in milliseconds\n\n\n    const backoff = constants.GossipsubPruneBackoff / 1000;\n    const px = [];\n\n    if (doPX) {\n      // select peers for Peer eXchange\n      const peers = get_gossip_peers_1.getGossipPeers(this, topic, constants.GossipsubPrunePeers, xid => {\n        return xid !== id && this.score.score(xid) >= 0;\n      });\n      peers.forEach(p => {\n        // see if we have a signed record to send back; if we don't, just send\n        // the peer ID and let the pruned peer find them in the DHT -- we can't trust\n        // unsigned address records through PX anyways\n        // Finding signed records in the DHT is not supported at the time of writing in js-libp2p\n        const peerId = PeerId.createFromB58String(p);\n        px.push({\n          peerID: peerId.toBytes(),\n          signedPeerRecord: this._libp2p.peerStore.addressBook.getRawEnvelope(peerId)\n        });\n      });\n    }\n\n    return {\n      topicID: topic,\n      peers: px,\n      backoff: backoff\n    };\n  }\n\n}\n\nGossipsub.multicodec = constants.GossipsubIDv11;\nmodule.exports = Gossipsub;","map":{"version":3,"sources":["/home/user/orbit-playground/music-app/node_modules/libp2p-gossipsub/src/index.js"],"names":["__createBinding","Object","create","o","m","k","k2","undefined","defineProperty","enumerable","get","__setModuleDefault","v","value","__importStar","mod","__esModule","result","hasOwnProperty","call","__awaiter","thisArg","_arguments","P","generator","adopt","resolve","Promise","reject","fulfilled","step","next","e","rejected","done","then","apply","pubsub_1","require","message_cache_1","message_1","constants","heartbeat_1","get_gossip_peers_1","utils_1","score_1","tracer_1","TimeCache","PeerId","Envelope","Pubsub","Gossipsub","constructor","libp2p","options","multicodecs","GossipsubIDv11","GossipsubIDv10","opts","assign","gossipIncoming","fallbackToFloodsub","floodPublish","doPX","directPeers","D","GossipsubD","Dlo","GossipsubDlo","Dhi","GossipsubDhi","Dscore","GossipsubDscore","Dout","GossipsubDout","Dlazy","GossipsubDlazy","signMessages","strictSigning","scoreParams","createPeerScoreParams","scoreThresholds","createPeerScoreThresholds","push","FloodsubID","debugName","_options","direct","Set","map","p","id","toB58String","forEach","peerStore","addressBook","add","addrs","seenCache","mesh","Map","fanout","lastpub","gossip","control","peerhave","iasked","backoff","outbound","defaultMsgIdFn","msg","utils","msgId","from","seqno","_msgIdFn","msgIdFn","messageCache","MessageCache","GossipsubHistoryGossip","GossipsubHistoryLength","heartbeat","Heartbeat","heartbeatTicks","gossipTracer","IWantTracer","_libp2p","score","PeerScore","connectionManager","_decodeRpc","bytes","RPCCodec","decode","_encodeRpc","rpc","encode","_addPeer","peerId","protocol","addPeer","c","getAll","stat","direction","Array","registry","values","some","rvalue","set","_removePeer","peerStreams","peers","delete","removePeer","_processRpc","_processRpcControlMessage","controlMsg","iwant","_handleIHave","ihave","_handleIWant","prune","_handleGraft","graft","_handlePrune","length","outRpc","createGossipRpc","_sendRpc","_processRpcMessage","_super","msgID","getMsgId","has","duplicateMessage","put","validateMessage","_acceptFrom","graylistThreshold","validate","message","rejectMessage","code","gossipThreshold","log","GossipsubMaxIHaveMessages","GossipsubMaxIHaveLength","topicID","messageIDs","size","iask","iwantList","shuffle","slice","addPromise","count","getForPeer","GossipsubGossipRetransmission","normalizeOutRpcMessage","now","_now","_a","peersInMesh","expire","addPenalty","floodCutoff","GossipsubGraftFloodThreshold","GossipsubPruneBackoff","_addBackoff","topic","_makePrune","_doAddBackoff","acceptPXThreshold","_pxConnect","interval","existingExpire","_applyIwantPenalties","getBrokenPromises","_clearBackoff","GossipsubPruneBackoffTicks","_directConnect","GossipsubDirectConnectTicks","toconnect","peer","isWritable","_connect","GossipsubPrunePeers","all","pi","peerID","createFromBytes","signedPeerRecord","envelope","openAndCertify","eid","consumePeerRecord","start","_directPeerInitial","setTimeout","GossipsubDirectConnectInitialDelay","stop","clear","clearTimeout","dialProtocol","createFromB58String","subscribe","join","unsubscribe","leave","started","Error","fanoutPeers","getGossipPeers","_sendGraft","meshPeers","_sendPrune","_publish","receivedFrom","deliverMessage","tosend","topicIDs","peersInTopic","topics","publishThreshold","out","ctrl","_piggybackControl","_piggybackGossip","write","tograft","filter","toprune","concat","_sendGraftPrune","noPX","pruning","_emitGossip","exclude","getGossipIDs","peersToGossip","topicPeers","hasGossipProtocol","target","factor","GossipsubGossipFactor","peerMessageIDs","_pushGossip","_flush","entries","controlIHaveMsgs","Date","px","xid","toBytes","getRawEnvelope","multicodec","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n/* eslint-disable @typescript-eslint/ban-ts-comment */\n// @ts-ignore\nconst pubsub_1 = require(\"libp2p-interfaces/src/pubsub\");\nconst message_cache_1 = require(\"./message-cache\");\nconst message_1 = require(\"./message\");\nconst constants = __importStar(require(\"./constants\"));\nconst heartbeat_1 = require(\"./heartbeat\");\nconst get_gossip_peers_1 = require(\"./get-gossip-peers\");\nconst utils_1 = require(\"./utils\");\nconst score_1 = require(\"./score\");\nconst tracer_1 = require(\"./tracer\");\n// @ts-ignore\nconst TimeCache = require(\"time-cache\");\nconst PeerId = require(\"peer-id\");\n// @ts-ignore\nconst Envelope = require(\"libp2p/src/record/envelope\");\n// @ts-ignore\nconst Pubsub = require(\"libp2p-interfaces/src/pubsub\");\nclass Gossipsub extends Pubsub {\n    // TODO: add remaining props\n    /**\n     * @param {Libp2p} libp2p\n     * @param {Object} [options]\n     * @param {bool} [options.emitSelf] if publish should emit to self, if subscribed, defaults to false\n     * @param {bool} [options.gossipIncoming] if incoming messages on a subscribed topic should be automatically gossiped, defaults to true\n     * @param {bool} [options.fallbackToFloodsub] if dial should fallback to floodsub, defaults to true\n     * @param {bool} [options.floodPublish] if self-published messages should be sent to all peers, defaults to true\n     * @param {bool} [options.doPX] whether PX is enabled; this should be enabled in bootstrappers and other well connected/trusted nodes. defaults to false\n     * @param {function} [options.msgIdFn] override the default message id function\n     * @param {Object} [options.messageCache] override the default MessageCache\n     * @param {bool} [options.signMessages] if we want to sign outgoing messages or not (default: true)\n     * @param {bool} [options.strictSigning] if message signing is required for incoming messages or not (default: true)\n     * @param {Object} [options.scoreParams] peer score parameters\n     * @param {Object} [options.scoreThresholds] peer score thresholds\n     * @param {AddrInfo[]} [options.directPeers] peers with which we will maintain direct connections\n     * @constructor\n     */\n    constructor(libp2p, options = {}) {\n        const multicodecs = [constants.GossipsubIDv11, constants.GossipsubIDv10];\n        const opts = Object.assign(Object.assign({ gossipIncoming: true, fallbackToFloodsub: true, floodPublish: true, doPX: false, directPeers: [], D: constants.GossipsubD, Dlo: constants.GossipsubDlo, Dhi: constants.GossipsubDhi, Dscore: constants.GossipsubDscore, Dout: constants.GossipsubDout, Dlazy: constants.GossipsubDlazy, signMessages: true, strictSigning: true }, options), { scoreParams: score_1.createPeerScoreParams(options.scoreParams), scoreThresholds: score_1.createPeerScoreThresholds(options.scoreThresholds) });\n        // Also wants to get notified of peers connected using floodsub\n        if (opts.fallbackToFloodsub) {\n            multicodecs.push(constants.FloodsubID);\n        }\n        super(Object.assign({ debugName: 'libp2p:gossipsub', multicodecs,\n            libp2p }, opts));\n        this._options = opts;\n        /**\n         * Direct peers\n         * @type {Set<string>}\n         */\n        this.direct = new Set(opts.directPeers.map(p => p.id.toB58String()));\n        // set direct peer addresses in the address book\n        opts.directPeers.forEach(p => {\n            libp2p.peerStore.addressBook.add(p.id, p.addrs);\n        });\n        /**\n         * Cache of seen messages\n         *\n         * @type {TimeCache}\n         */\n        this.seenCache = new TimeCache();\n        /**\n         * Map of topic meshes\n         * topic => peer id set\n         *\n         * @type {Map<string, Set<string>>}\n         */\n        this.mesh = new Map();\n        /**\n         * Map of topics to set of peers. These mesh peers are the ones to which we are publishing without a topic membership\n         * topic => peer id set\n         *\n         * @type {Map<string, Set<string>>}\n         */\n        this.fanout = new Map();\n        /**\n         * Map of last publish time for fanout topics\n         * topic => last publish time\n         *\n         * @type {Map<string, number>}\n         */\n        this.lastpub = new Map();\n        /**\n         * Map of pending messages to gossip\n         * peer id => control messages\n         *\n         * @type {Map<string, Array<ControlIHave object>> }\n         */\n        this.gossip = new Map();\n        /**\n         * Map of control messages\n         * peer id => control message\n         *\n         * @type {Map<string, ControlMessage object>}\n         */\n        this.control = new Map();\n        /**\n         * Number of IHAVEs received from peer in the last heartbeat\n         * @type {Map<string, number>}\n         */\n        this.peerhave = new Map();\n        /**\n         * Number of messages we have asked from peer in the last heartbeat\n         * @type {Map<string, number>}\n         */\n        this.iasked = new Map();\n        /**\n         * Prune backoff map\n         */\n        this.backoff = new Map();\n        /**\n         * Connection direction cache, marks peers with outbound connections\n         * peer id => direction\n         *\n         * @type {Map<string, boolean>}\n         */\n        this.outbound = new Map();\n        /**\n         * Use the overriden mesgIdFn or the default one.\n         */\n        this.defaultMsgIdFn = (msg) => pubsub_1.utils.msgId(msg.from, msg.seqno);\n        this._msgIdFn = options.msgIdFn || this.defaultMsgIdFn;\n        /**\n         * A message cache that contains the messages for last few hearbeat ticks\n         *\n         */\n        this.messageCache = options.messageCache || new message_cache_1.MessageCache(constants.GossipsubHistoryGossip, constants.GossipsubHistoryLength, this._msgIdFn);\n        /**\n         * A heartbeat timer that maintains the mesh\n         */\n        this.heartbeat = new heartbeat_1.Heartbeat(this);\n        /**\n         * Number of heartbeats since the beginning of time\n         * This allows us to amortize some resource cleanup -- eg: backoff cleanup\n         */\n        this.heartbeatTicks = 0;\n        /**\n         * Tracks IHAVE/IWANT promises broken by peers\n         */\n        this.gossipTracer = new tracer_1.IWantTracer(this._msgIdFn);\n        /**\n         * libp2p\n         */\n        this._libp2p = libp2p;\n        /**\n         * Peer score tracking\n         */\n        this.score = new score_1.PeerScore(this._options.scoreParams, libp2p.connectionManager, this._msgIdFn);\n    }\n    /**\n     * Decode a Uint8Array into an RPC object\n     * Overrided to use an extended protocol-specific protobuf decoder\n     * @override\n     * @param {Uint8Array} bytes\n     * @returns {RPC}\n     */\n    _decodeRpc(bytes) {\n        return message_1.RPCCodec.decode(bytes);\n    }\n    /**\n     * Encode an RPC object into a Uint8Array\n     * Overrided to use an extended protocol-specific protobuf encoder\n     * @override\n     * @param {RPC} rpc\n     * @returns {Uint8Array}\n     */\n    _encodeRpc(rpc) {\n        return message_1.RPCCodec.encode(rpc);\n    }\n    /**\n     * Add a peer to the router\n     * @override\n     * @param {PeerId} peerId\n     * @param {string} protocol\n     * @returns {PeerStreams}\n     */\n    _addPeer(peerId, protocol) {\n        const p = super._addPeer(peerId, protocol);\n        // Add to peer scoring\n        this.score.addPeer(peerId.toB58String());\n        // track the connection direction\n        let outbound = false;\n        for (const c of this._libp2p.connectionManager.getAll(peerId)) {\n            if (c.stat.direction === 'outbound') {\n                if (Array.from(c.registry.values()).some(rvalue => protocol === rvalue.protocol)) {\n                    outbound = true;\n                    break;\n                }\n            }\n        }\n        this.outbound.set(p, outbound);\n        return p;\n    }\n    /**\n     * Removes a peer from the router\n     * @override\n     * @param {PeerId} peer\n     * @returns {Peer}\n     */\n    _removePeer(peerId) {\n        const peerStreams = super._removePeer(peerId);\n        const id = peerId.toB58String();\n        // Remove this peer from the mesh\n        // eslint-disable-next-line no-unused-vars\n        for (const peers of this.mesh.values()) {\n            peers.delete(id);\n        }\n        // Remove this peer from the fanout\n        // eslint-disable-next-line no-unused-vars\n        for (const peers of this.fanout.values()) {\n            peers.delete(id);\n        }\n        // Remove from gossip mapping\n        this.gossip.delete(id);\n        // Remove from control mapping\n        this.control.delete(id);\n        // Remove from backoff mapping\n        this.outbound.delete(id);\n        // Remove from peer scoring\n        this.score.removePeer(id);\n        return peerStreams;\n    }\n    /**\n     * Handles an rpc request from a peer\n     *\n     * @override\n     * @param {String} idB58Str\n     * @param {PeerStreams} peerStreams\n     * @param {RPC} rpc\n     * @returns {boolean}\n     */\n    _processRpc(id, peerStreams, rpc) {\n        if (super._processRpc(id, peerStreams, rpc)) {\n            if (rpc.control) {\n                this._processRpcControlMessage(id, rpc.control);\n            }\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Handles an rpc control message from a peer\n     * @param {string} id peer id\n     * @param {ControlMessage} controlMsg\n     * @returns {void}\n     */\n    _processRpcControlMessage(id, controlMsg) {\n        if (!controlMsg) {\n            return;\n        }\n        const iwant = this._handleIHave(id, controlMsg.ihave);\n        const ihave = this._handleIWant(id, controlMsg.iwant);\n        const prune = this._handleGraft(id, controlMsg.graft);\n        this._handlePrune(id, controlMsg.prune);\n        if (!iwant.length && !ihave.length && !prune.length) {\n            return;\n        }\n        const outRpc = utils_1.createGossipRpc(ihave, { iwant, prune });\n        this._sendRpc(id, outRpc);\n    }\n    /**\n     * Process incoming message,\n     * emitting locally and forwarding on to relevant floodsub and gossipsub peers\n     * @override\n     * @param {InMessage} msg\n     * @returns {Promise<void>}\n     */\n    _processRpcMessage(msg) {\n        const _super = Object.create(null, {\n            _processRpcMessage: { get: () => super._processRpcMessage }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            const msgID = this.getMsgId(msg);\n            // Ignore if we've already seen the message\n            if (this.seenCache.has(msgID)) {\n                this.score.duplicateMessage(msg);\n                return;\n            }\n            this.seenCache.put(msgID);\n            this.score.validateMessage(msg);\n            yield _super._processRpcMessage.call(this, msg);\n        });\n    }\n    /**\n     * Whether to accept a message from a peer\n     * @override\n     * @param {string} id\n     * @returns {boolean}\n     */\n    _acceptFrom(id) {\n        return this.direct.has(id) || this.score.score(id) >= this._options.scoreThresholds.graylistThreshold;\n    }\n    /**\n     * Validate incoming message\n     * @override\n     * @param {InMessage} message\n     * @returns {Promise<void>}\n     */\n    validate(message) {\n        const _super = Object.create(null, {\n            validate: { get: () => super.validate }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                yield _super.validate.call(this, message);\n            }\n            catch (e) {\n                this.score.rejectMessage(message, e.code);\n                this.gossipTracer.rejectMessage(message, e.code);\n                throw e;\n            }\n        });\n    }\n    /**\n     * Handles IHAVE messages\n     * @param {string} id peer id\n     * @param {Array<ControlIHave>} ihave\n     * @returns {ControlIWant}\n     */\n    _handleIHave(id, ihave) {\n        if (!ihave.length) {\n            return [];\n        }\n        // we ignore IHAVE gossip from any peer whose score is below the gossips threshold\n        const score = this.score.score(id);\n        if (score < this._options.scoreThresholds.gossipThreshold) {\n            this.log('IHAVE: ignoring peer %s with score below threshold [ score = %d ]', id, score);\n            return [];\n        }\n        // IHAVE flood protection\n        const peerhave = (this.peerhave.get(id) || 0) + 1;\n        this.peerhave.set(id, peerhave);\n        if (peerhave > constants.GossipsubMaxIHaveMessages) {\n            this.log('IHAVE: peer %s has advertised too many times (%d) within this heartbeat interval; ignoring', id, peerhave);\n            return [];\n        }\n        const iasked = this.iasked.get(id) || 0;\n        if (iasked >= constants.GossipsubMaxIHaveLength) {\n            this.log('IHAVE: peer %s has already advertised too many messages (%d); ignoring', id, iasked);\n            return [];\n        }\n        const iwant = new Set();\n        ihave.forEach(({ topicID, messageIDs }) => {\n            if (!topicID || !this.mesh.has(topicID)) {\n                return;\n            }\n            messageIDs.forEach((msgID) => {\n                if (this.seenCache.has(msgID)) {\n                    return;\n                }\n                iwant.add(msgID);\n            });\n        });\n        if (!iwant.size) {\n            return [];\n        }\n        let iask = iwant.size;\n        if (iask + iasked > constants.GossipsubMaxIHaveLength) {\n            iask = constants.GossipsubMaxIHaveLength - iasked;\n        }\n        this.log('IHAVE: Asking for %d out of %d messages from %s', iask, iwant.size, id);\n        let iwantList = Array.from(iwant);\n        // ask in random order\n        utils_1.shuffle(iwantList);\n        // truncate to the messages we are actually asking for and update the iasked counter\n        iwantList = iwantList.slice(0, iask);\n        this.iasked.set(id, iasked + iask);\n        this.gossipTracer.addPromise(id, iwantList);\n        return [{\n                messageIDs: iwantList\n            }];\n    }\n    /**\n     * Handles IWANT messages\n     * Returns messages to send back to peer\n     * @param {string} id peer id\n     * @param {Array<ControlIWant>} iwant\n     * @returns {Array<Message>}\n     */\n    _handleIWant(id, iwant) {\n        if (!iwant.length) {\n            return [];\n        }\n        // we don't respond to IWANT requests from any per whose score is below the gossip threshold\n        const score = this.score.score(id);\n        if (score < this._options.scoreThresholds.gossipThreshold) {\n            this.log('IWANT: ignoring peer %s with score below threshold [score = %d]', id, score);\n            return [];\n        }\n        // @type {Map<string, Message>}\n        const ihave = new Map();\n        iwant.forEach(({ messageIDs }) => {\n            messageIDs.forEach((msgID) => {\n                const [msg, count] = this.messageCache.getForPeer(msgID, id);\n                if (!msg) {\n                    return;\n                }\n                if (count > constants.GossipsubGossipRetransmission) {\n                    this.log('IWANT: Peer %s has asked for message %s too many times: ignoring request', id, msgID);\n                    return;\n                }\n                ihave.set(msgID, msg);\n            });\n        });\n        if (!ihave.size) {\n            return [];\n        }\n        this.log('IWANT: Sending %d messages to %s', ihave.size, id);\n        return Array.from(ihave.values()).map(pubsub_1.utils.normalizeOutRpcMessage);\n    }\n    /**\n     * Handles Graft messages\n     * @param {string} id peer id\n     * @param {Array<ControlGraft>} graft\n     * @return {Array<ControlPrune>}\n     */\n    _handleGraft(id, graft) {\n        const prune = [];\n        const score = this.score.score(id);\n        const now = this._now();\n        let doPX = this._options.doPX;\n        graft.forEach(({ topicID }) => {\n            var _a;\n            if (!topicID) {\n                return;\n            }\n            const peersInMesh = this.mesh.get(topicID);\n            if (!peersInMesh) {\n                // don't do PX when there is an unknown topic to avoid leaking our peers\n                doPX = false;\n                // spam hardening: ignore GRAFTs for unknown topics\n                return;\n            }\n            // check if peer is already in the mesh; if so do nothing\n            if (peersInMesh.has(id)) {\n                return;\n            }\n            // we don't GRAFT to/from direct peers; complain loudly if this happens\n            if (this.direct.has(id)) {\n                this.log('GRAFT: ignoring request from direct peer %s', id);\n                // this is possibly a bug from a non-reciprical configuration; send a PRUNE\n                prune.push(topicID);\n                // but don't px\n                doPX = false;\n                return;\n            }\n            // make sure we are not backing off that peer\n            const expire = (_a = this.backoff.get(topicID)) === null || _a === void 0 ? void 0 : _a.get(id);\n            if (typeof expire === 'number' && now < expire) {\n                this.log('GRAFT: ignoring backed off peer %s', id);\n                // add behavioral penalty\n                this.score.addPenalty(id, 1);\n                // no PX\n                doPX = false;\n                // check the flood cutoff -- is the GRAFT coming too fast?\n                const floodCutoff = expire + constants.GossipsubGraftFloodThreshold - constants.GossipsubPruneBackoff;\n                if (now < floodCutoff) {\n                    // extra penalty\n                    this.score.addPenalty(id, 1);\n                }\n                // refresh the backoff\n                this._addBackoff(id, topicID);\n                prune.push(topicID);\n                return;\n            }\n            // check the score\n            if (score < 0) {\n                // we don't GRAFT peers with negative score\n                this.log('GRAFT: ignoring peer %s with negative score: score=%d, topic=%s', id, score, topicID);\n                // we do send them PRUNE however, because it's a matter of protocol correctness\n                prune.push(topicID);\n                // but we won't PX to them\n                doPX = false;\n                // add/refresh backoff so that we don't reGRAFT too early even if the score decays\n                this._addBackoff(id, topicID);\n                return;\n            }\n            // check the number of mesh peers; if it is at (or over) Dhi, we only accept grafts\n            // from peers with outbound connections; this is a defensive check to restrict potential\n            // mesh takeover attacks combined with love bombing\n            if (peersInMesh.size >= this._options.Dhi && !this.outbound.get(id)) {\n                prune.push(topicID);\n                this._addBackoff(id, topicID);\n                return;\n            }\n            this.log('GRAFT: Add mesh link from %s in %s', id, topicID);\n            this.score.graft(id, topicID);\n            peersInMesh.add(id);\n        });\n        if (!prune.length) {\n            return [];\n        }\n        return prune.map(topic => this._makePrune(id, topic, doPX));\n    }\n    /**\n     * Handles Prune messages\n     * @param {string} id peer id\n     * @param {Array<ControlPrune>} prune\n     * @returns {void}\n     */\n    _handlePrune(id, prune) {\n        const score = this.score.score(id);\n        prune.forEach(({ topicID, backoff, peers }) => {\n            if (!topicID) {\n                return;\n            }\n            const peersInMesh = this.mesh.get(topicID);\n            if (!peersInMesh) {\n                return;\n            }\n            this.log('PRUNE: Remove mesh link to %s in %s', id, topicID);\n            this.score.prune(id, topicID);\n            peersInMesh.delete(id);\n            // is there a backoff specified by the peer? if so obey it\n            if (typeof backoff === 'number' && backoff > 0) {\n                this._doAddBackoff(id, topicID, backoff * 1000);\n            }\n            else {\n                this._addBackoff(id, topicID);\n            }\n            // PX\n            if (peers && peers.length) {\n                // we ignore PX from peers with insufficient scores\n                if (score < this._options.scoreThresholds.acceptPXThreshold) {\n                    this.log('PRUNE: ignoring PX from peer %s with insufficient score [score = %d, topic = %s]', id, score, topicID);\n                    return;\n                }\n                this._pxConnect(peers);\n            }\n        });\n    }\n    /**\n     * Add standard backoff log for a peer in a topic\n     * @param {string} id\n     * @param {string} topic\n     * @returns {void}\n     */\n    _addBackoff(id, topic) {\n        this._doAddBackoff(id, topic, constants.GossipsubPruneBackoff);\n    }\n    /**\n     * Add backoff expiry interval for a peer in a topic\n     * @param {string} id\n     * @param {string} topic\n     * @param {number} interval backoff duration in milliseconds\n     * @returns {void}\n     */\n    _doAddBackoff(id, topic, interval) {\n        let backoff = this.backoff.get(topic);\n        if (!backoff) {\n            backoff = new Map();\n            this.backoff.set(topic, backoff);\n        }\n        const expire = this._now() + interval;\n        const existingExpire = backoff.get(id) || 0;\n        if (existingExpire < expire) {\n            backoff.set(id, expire);\n        }\n    }\n    /**\n     * Apply penalties from broken IHAVE/IWANT promises\n     * @returns {void}\n     */\n    _applyIwantPenalties() {\n        this.gossipTracer.getBrokenPromises().forEach((count, p) => {\n            this.log('peer %s didn\\'t follow up in %d IWANT requests; adding penalty', p, count);\n            this.score.addPenalty(p, count);\n        });\n    }\n    /**\n     * Clear expired backoff expiries\n     * @returns {void}\n     */\n    _clearBackoff() {\n        // we only clear once every GossipsubPruneBackoffTicks ticks to avoid iterating over the maps too much\n        if (this.heartbeatTicks % constants.GossipsubPruneBackoffTicks !== 0) {\n            return;\n        }\n        const now = this._now();\n        this.backoff.forEach((backoff, topic) => {\n            backoff.forEach((expire, id) => {\n                if (expire < now) {\n                    backoff.delete(id);\n                }\n            });\n            if (backoff.size === 0) {\n                this.backoff.delete(topic);\n            }\n        });\n    }\n    /**\n     * Maybe reconnect to direct peers\n     * @returns {void}\n     */\n    _directConnect() {\n        // we only do this every few ticks to allow pending connections to complete and account for\n        // restarts/downtime\n        if (this.heartbeatTicks % constants.GossipsubDirectConnectTicks !== 0) {\n            return;\n        }\n        const toconnect = [];\n        this.direct.forEach(id => {\n            const peer = this.peers.get(id);\n            if (!peer || !peer.isWritable) {\n                toconnect.push(id);\n            }\n        });\n        if (toconnect.length) {\n            toconnect.forEach(id => {\n                this._connect(id);\n            });\n        }\n    }\n    /**\n     * Maybe attempt connection given signed peer records\n     * @param {PeerInfo[]} peers\n     * @returns {Promise<void>}\n     */\n    _pxConnect(peers) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (peers.length > constants.GossipsubPrunePeers) {\n                utils_1.shuffle(peers);\n                peers = peers.slice(0, constants.GossipsubPrunePeers);\n            }\n            const toconnect = [];\n            yield Promise.all(peers.map((pi) => __awaiter(this, void 0, void 0, function* () {\n                if (!pi.peerID) {\n                    return;\n                }\n                const p = PeerId.createFromBytes(pi.peerID);\n                const id = p.toB58String();\n                if (this.peers.has(id)) {\n                    return;\n                }\n                if (!pi.signedPeerRecord) {\n                    toconnect.push(id);\n                    return;\n                }\n                // The peer sent us a signed record\n                // This is not a record from the peer who sent the record, but another peer who is connected with it\n                // Ensure that it is valid\n                try {\n                    const envelope = yield Envelope.openAndCertify(pi.signedPeerRecord, 'libp2p-peer-record');\n                    const eid = envelope.peerId.toB58String();\n                    if (id !== eid) {\n                        this.log('bogus peer record obtained through px: peer ID %s doesn\\'t match expected peer %s', eid, id);\n                        return;\n                    }\n                    if (!this._libp2p.peerStore.addressBook.consumePeerRecord(envelope)) {\n                        this.log('bogus peer record obtained through px: could not add peer record to address book');\n                        return;\n                    }\n                    toconnect.push(id);\n                }\n                catch (e) {\n                    this.log('bogus peer record obtained through px: invalid signature or not a peer record');\n                }\n            })));\n            if (!toconnect.length) {\n                return;\n            }\n            toconnect.forEach(id => this._connect(id));\n        });\n    }\n    /**\n     * Mounts the gossipsub protocol onto the libp2p node and sends our\n     * our subscriptions to every peer connected\n     * @override\n     * @returns {void}\n     */\n    start() {\n        super.start();\n        this.heartbeat.start();\n        this.score.start();\n        // connect to direct peers\n        this._directPeerInitial = setTimeout(() => {\n            this.direct.forEach(id => {\n                this._connect(id);\n            });\n        }, constants.GossipsubDirectConnectInitialDelay);\n    }\n    /**\n     * Unmounts the gossipsub protocol and shuts down every connection\n     * @override\n     * @returns {void}\n     */\n    stop() {\n        super.stop();\n        this.heartbeat.stop();\n        this.score.stop();\n        this.mesh = new Map();\n        this.fanout = new Map();\n        this.lastpub = new Map();\n        this.gossip = new Map();\n        this.control = new Map();\n        this.peerhave = new Map();\n        this.iasked = new Map();\n        this.backoff = new Map();\n        this.outbound = new Map();\n        this.gossipTracer.clear();\n        clearTimeout(this._directPeerInitial);\n    }\n    /**\n     * Connect to a peer using the gossipsub protocol\n     * @param {string} id\n     * @returns {void}\n     */\n    _connect(id) {\n        this.log('Initiating connection with %s', id);\n        this._libp2p.dialProtocol(PeerId.createFromB58String(id), this.multicodecs);\n    }\n    /**\n     * Subscribes to a topic\n     * @override\n     * @param {string} topic\n     * @returns {void}\n     */\n    subscribe(topic) {\n        super.subscribe(topic);\n        this.join(topic);\n    }\n    /**\n     * Unsubscribe to a topic\n     * @override\n     * @param {string} topic\n     * @returns {void}\n     */\n    unsubscribe(topic) {\n        super.unsubscribe(topic);\n        this.leave(topic);\n    }\n    /**\n     * Join topic\n     * @param {string} topic\n     * @returns {void}\n     */\n    join(topic) {\n        if (!this.started) {\n            throw new Error('Gossipsub has not started');\n        }\n        this.log('JOIN %s', topic);\n        const fanoutPeers = this.fanout.get(topic);\n        if (fanoutPeers) {\n            // these peers have a score above the publish threshold, which may be negative\n            // so drop the ones with a negative score\n            fanoutPeers.forEach(id => {\n                if (this.score.score(id) < 0) {\n                    fanoutPeers.delete(id);\n                }\n            });\n            if (fanoutPeers.size < this._options.D) {\n                // we need more peers; eager, as this would get fixed in the next heartbeat\n                get_gossip_peers_1.getGossipPeers(this, topic, this._options.D - fanoutPeers.size, (id) => {\n                    // filter our current peers, direct peers, and peers with negative scores\n                    return !fanoutPeers.has(id) && !this.direct.has(id) && this.score.score(id) >= 0;\n                }).forEach(id => fanoutPeers.add(id));\n            }\n            this.mesh.set(topic, fanoutPeers);\n            this.fanout.delete(topic);\n            this.lastpub.delete(topic);\n        }\n        else {\n            const peers = get_gossip_peers_1.getGossipPeers(this, topic, this._options.D, (id) => {\n                // filter direct peers and peers with negative score\n                return !this.direct.has(id) && this.score.score(id) >= 0;\n            });\n            this.mesh.set(topic, peers);\n        }\n        this.mesh.get(topic).forEach((id) => {\n            this.log('JOIN: Add mesh link to %s in %s', id, topic);\n            this._sendGraft(id, topic);\n        });\n    }\n    /**\n     * Leave topic\n     * @param {string} topic\n     * @returns {void}\n     */\n    leave(topic) {\n        if (!this.started) {\n            throw new Error('Gossipsub has not started');\n        }\n        this.log('LEAVE %s', topic);\n        // Send PRUNE to mesh peers\n        const meshPeers = this.mesh.get(topic);\n        if (meshPeers) {\n            meshPeers.forEach((id) => {\n                this.log('LEAVE: Remove mesh link to %s in %s', id, topic);\n                this._sendPrune(id, topic);\n            });\n            this.mesh.delete(topic);\n        }\n    }\n    /**\n     * Override the default implementation in BasicPubSub.\n     * If we don't provide msgIdFn in constructor option, it's the same.\n     * @override\n     * @param {Message} msg the message object\n     * @returns {string} message id as string\n     */\n    getMsgId(msg) {\n        return this._msgIdFn(msg);\n    }\n    /**\n     * Publish messages\n     *\n     * @override\n     * @param {InMessage} msg\n     * @returns {void}\n     */\n    _publish(msg) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (msg.receivedFrom !== this.peerId.toB58String()) {\n                this.score.deliverMessage(msg);\n                this.gossipTracer.deliverMessage(msg);\n            }\n            const msgID = this.getMsgId(msg);\n            // put in seen cache\n            this.seenCache.put(msgID);\n            this.messageCache.put(msg);\n            const tosend = new Set();\n            msg.topicIDs.forEach((topic) => {\n                const peersInTopic = this.topics.get(topic);\n                if (!peersInTopic) {\n                    return;\n                }\n                if (this._options.floodPublish && msg.from === this.peerId.toB58String()) {\n                    // flood-publish behavior\n                    // send to direct peers and _all_ peers meeting the publishThreshold\n                    peersInTopic.forEach(id => {\n                        if (this.direct.has(id) || this.score.score(id) >= this._options.scoreThresholds.publishThreshold) {\n                            tosend.add(id);\n                        }\n                    });\n                }\n                else {\n                    // non-flood-publish behavior\n                    // send to direct peers, subscribed floodsub peers\n                    // and some mesh peers above publishThreshold\n                    // direct peers\n                    this.direct.forEach(id => {\n                        tosend.add(id);\n                    });\n                    // floodsub peers\n                    peersInTopic.forEach((id) => {\n                        const score = this.score.score(id);\n                        const peerStreams = this.peers.get(id);\n                        if (!peerStreams) {\n                            return;\n                        }\n                        if (peerStreams.protocol === constants.FloodsubID && score >= this._options.scoreThresholds.publishThreshold) {\n                            tosend.add(id);\n                        }\n                    });\n                    // Gossipsub peers handling\n                    let meshPeers = this.mesh.get(topic);\n                    if (!meshPeers || !meshPeers.size) {\n                        // We are not in the mesh for topic, use fanout peers\n                        meshPeers = this.fanout.get(topic);\n                        if (!meshPeers) {\n                            // If we are not in the fanout, then pick peers in topic above the publishThreshold\n                            const peers = get_gossip_peers_1.getGossipPeers(this, topic, this._options.D, id => {\n                                return this.score.score(id) >= this._options.scoreThresholds.publishThreshold;\n                            });\n                            if (peers.size > 0) {\n                                meshPeers = peers;\n                                this.fanout.set(topic, peers);\n                            }\n                            else {\n                                meshPeers = new Set();\n                            }\n                        }\n                        // Store the latest publishing time\n                        this.lastpub.set(topic, this._now());\n                    }\n                    meshPeers.forEach((peer) => {\n                        tosend.add(peer);\n                    });\n                }\n            });\n            // Publish messages to peers\n            const rpc = utils_1.createGossipRpc([\n                pubsub_1.utils.normalizeOutRpcMessage(msg)\n            ]);\n            tosend.forEach((id) => {\n                if (id === msg.from) {\n                    return;\n                }\n                this._sendRpc(id, rpc);\n            });\n        });\n    }\n    /**\n     * Sends a GRAFT message to a peer\n     * @param {string} id peer id\n     * @param {string} topic\n     * @returns {void}\n     */\n    _sendGraft(id, topic) {\n        const graft = [{\n                topicID: topic\n            }];\n        const out = utils_1.createGossipRpc([], { graft });\n        this._sendRpc(id, out);\n    }\n    /**\n     * Sends a PRUNE message to a peer\n     * @param {string} id peer id\n     * @param {string} topic\n     * @returns {void}\n     */\n    _sendPrune(id, topic) {\n        const prune = [\n            this._makePrune(id, topic, this._options.doPX)\n        ];\n        const out = utils_1.createGossipRpc([], { prune });\n        this._sendRpc(id, out);\n    }\n    /**\n     * @override\n     */\n    _sendRpc(id, outRpc) {\n        const peerStreams = this.peers.get(id);\n        if (!peerStreams || !peerStreams.isWritable) {\n            return;\n        }\n        // piggyback control message retries\n        const ctrl = this.control.get(id);\n        if (ctrl) {\n            this._piggybackControl(id, outRpc, ctrl);\n            this.control.delete(id);\n        }\n        // piggyback gossip\n        const ihave = this.gossip.get(id);\n        if (ihave) {\n            this._piggybackGossip(id, outRpc, ihave);\n            this.gossip.delete(id);\n        }\n        peerStreams.write(message_1.RPCCodec.encode(outRpc));\n    }\n    _piggybackControl(id, outRpc, ctrl) {\n        const tograft = (ctrl.graft || [])\n            .filter(({ topicID }) => (topicID && this.mesh.get(topicID) || new Set()).has(id));\n        const toprune = (ctrl.prune || [])\n            .filter(({ topicID }) => !(topicID && this.mesh.get(topicID) || new Set()).has(id));\n        if (!tograft.length && !toprune.length) {\n            return;\n        }\n        if (outRpc.control) {\n            outRpc.control.graft = outRpc.control.graft.concat(tograft);\n            outRpc.control.prune = outRpc.control.prune.concat(toprune);\n        }\n        else {\n            outRpc.control = { ihave: [], iwant: [], graft: tograft, prune: toprune };\n        }\n    }\n    _piggybackGossip(id, outRpc, ihave) {\n        if (!outRpc.control) {\n            outRpc.control = { ihave: [], iwant: [], graft: [], prune: [] };\n        }\n        outRpc.control.ihave = ihave;\n    }\n    /**\n     * Send graft and prune messages\n     * @param {Map<string, Array<string>>} tograft peer id => topic[]\n     * @param {Map<string, Array<string>>} toprune peer id => topic[]\n     */\n    _sendGraftPrune(tograft, toprune, noPX) {\n        const doPX = this._options.doPX;\n        for (const [id, topics] of tograft) {\n            const graft = topics.map((topicID) => ({ topicID }));\n            let prune = [];\n            // If a peer also has prunes, process them now\n            const pruning = toprune.get(id);\n            if (pruning) {\n                prune = pruning.map((topicID) => this._makePrune(id, topicID, doPX && !noPX.get(id)));\n                toprune.delete(id);\n            }\n            const outRpc = utils_1.createGossipRpc([], { graft, prune });\n            this._sendRpc(id, outRpc);\n        }\n        for (const [id, topics] of toprune) {\n            const prune = topics.map((topicID) => this._makePrune(id, topicID, doPX && !noPX.get(id)));\n            const outRpc = utils_1.createGossipRpc([], { prune });\n            this._sendRpc(id, outRpc);\n        }\n    }\n    /**\n     * Emits gossip to peers in a particular topic\n     * @param {string} topic\n     * @param {Set<string>} exclude peers to exclude\n     * @returns {void}\n     */\n    _emitGossip(topic, exclude) {\n        const messageIDs = this.messageCache.getGossipIDs(topic);\n        if (!messageIDs.length) {\n            return;\n        }\n        // shuffle to emit in random order\n        utils_1.shuffle(messageIDs);\n        // if we are emitting more than GossipsubMaxIHaveLength ids, truncate the list\n        if (messageIDs.length > constants.GossipsubMaxIHaveLength) {\n            // we do the truncation (with shuffling) per peer below\n            this.log('too many messages for gossip; will truncate IHAVE list (%d messages)', messageIDs.length);\n        }\n        // Send gossip to GossipFactor peers above threshold with a minimum of D_lazy\n        // First we collect the peers above gossipThreshold that are not in the exclude set\n        // and then randomly select from that set\n        // We also exclude direct peers, as there is no reason to emit gossip to them\n        const peersToGossip = [];\n        const topicPeers = this.topics.get(topic);\n        if (!topicPeers) {\n            // no topic peers, no gossip\n            return;\n        }\n        topicPeers.forEach(id => {\n            const peerStreams = this.peers.get(id);\n            if (!peerStreams) {\n                return;\n            }\n            if (!exclude.has(id) &&\n                !this.direct.has(id) &&\n                utils_1.hasGossipProtocol(peerStreams.protocol) &&\n                this.score.score(id) >= this._options.scoreThresholds.gossipThreshold) {\n                peersToGossip.push(id);\n            }\n        });\n        let target = this._options.Dlazy;\n        const factor = constants.GossipsubGossipFactor * peersToGossip.length;\n        if (factor > target) {\n            target = factor;\n        }\n        if (target > peersToGossip.length) {\n            target = peersToGossip.length;\n        }\n        else {\n            utils_1.shuffle(peersToGossip);\n        }\n        // Emit the IHAVE gossip to the selected peers up to the target\n        peersToGossip.slice(0, target).forEach(id => {\n            let peerMessageIDs = messageIDs;\n            if (messageIDs.length > constants.GossipsubMaxIHaveLength) {\n                // shuffle and slice message IDs per peer so that we emit a different set for each peer\n                // we have enough reduncancy in the system that this will significantly increase the message\n                // coverage when we do truncate\n                peerMessageIDs = utils_1.shuffle(peerMessageIDs.slice()).slice(0, constants.GossipsubMaxIHaveLength);\n            }\n            this._pushGossip(id, {\n                topicID: topic,\n                messageIDs: peerMessageIDs\n            });\n        });\n    }\n    /**\n     * Flush gossip and control messages\n     */\n    _flush() {\n        // send gossip first, which will also piggyback control\n        for (const [peer, ihave] of this.gossip.entries()) {\n            this.gossip.delete(peer);\n            const out = utils_1.createGossipRpc([], { ihave });\n            this._sendRpc(peer, out);\n        }\n        // send the remaining control messages\n        for (const [peer, control] of this.control.entries()) {\n            this.control.delete(peer);\n            const out = utils_1.createGossipRpc([], { graft: control.graft, prune: control.prune });\n            this._sendRpc(peer, out);\n        }\n    }\n    /**\n     * Adds new IHAVE messages to pending gossip\n     * @param {PeerStreams} peerStreams\n     * @param {Array<ControlIHave>} controlIHaveMsgs\n     * @returns {void}\n     */\n    _pushGossip(id, controlIHaveMsgs) {\n        this.log('Add gossip to %s', id);\n        const gossip = this.gossip.get(id) || [];\n        this.gossip.set(id, gossip.concat(controlIHaveMsgs));\n    }\n    /**\n     * Returns the current time in milliseconds\n     * @returns {number}\n     */\n    _now() {\n        return Date.now();\n    }\n    /**\n     * Make a PRUNE control message for a peer in a topic\n     * @param {string} id\n     * @param {string} topic\n     * @param {boolean} doPX\n     * @returns {ControlPrune}\n     */\n    _makePrune(id, topic, doPX) {\n        if (this.peers.get(id).protocol === constants.GossipsubIDv10) {\n            // Gossipsub v1.0 -- no backoff, the peer won't be able to parse it anyway\n            return {\n                topicID: topic,\n                peers: []\n            };\n        }\n        // backoff is measured in seconds\n        // GossipsubPruneBackoff is measured in milliseconds\n        const backoff = constants.GossipsubPruneBackoff / 1000;\n        const px = [];\n        if (doPX) {\n            // select peers for Peer eXchange\n            const peers = get_gossip_peers_1.getGossipPeers(this, topic, constants.GossipsubPrunePeers, (xid) => {\n                return xid !== id && this.score.score(xid) >= 0;\n            });\n            peers.forEach(p => {\n                // see if we have a signed record to send back; if we don't, just send\n                // the peer ID and let the pruned peer find them in the DHT -- we can't trust\n                // unsigned address records through PX anyways\n                // Finding signed records in the DHT is not supported at the time of writing in js-libp2p\n                const peerId = PeerId.createFromB58String(p);\n                px.push({\n                    peerID: peerId.toBytes(),\n                    signedPeerRecord: this._libp2p.peerStore.addressBook.getRawEnvelope(peerId)\n                });\n            });\n        }\n        return {\n            topicID: topic,\n            peers: px,\n            backoff: backoff\n        };\n    }\n}\nGossipsub.multicodec = constants.GossipsubIDv11;\nmodule.exports = Gossipsub;\n"]},"metadata":{},"sourceType":"script"}