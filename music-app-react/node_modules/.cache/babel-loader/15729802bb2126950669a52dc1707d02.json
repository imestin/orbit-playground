{"ast":null,"code":"'use strict';\n\nconst pSeries = require('p-series');\n\nconst PeerMonitor = require('ipfs-pubsub-peer-monitor');\n\nconst Logger = require('logplease');\n\nconst logger = Logger.create(\"pubsub\", {\n  color: Logger.Colors.Yellow\n});\nLogger.setLogLevel('ERROR');\nconst maxTopicsOpen = 256;\nlet topicsOpenCount = 0;\n\nclass IPFSPubsub {\n  constructor(ipfs, id) {\n    this._ipfs = ipfs;\n    this._id = id;\n    this._subscriptions = {};\n    if (this._ipfs.pubsub === null) logger.error(\"The provided version of ipfs doesn't have pubsub support. Messages will not be exchanged.\");\n    this._handleMessage = this._handleMessage.bind(this); // Bump up the number of listeners we can have open,\n    // ie. number of databases replicating\n\n    if (this._ipfs.setMaxListeners) this._ipfs.setMaxListeners(maxTopicsOpen);\n  }\n\n  async subscribe(topic, onMessageCallback, onNewPeerCallback, options = {}) {\n    if (!this._subscriptions[topic] && this._ipfs.pubsub) {\n      await this._ipfs.pubsub.subscribe(topic, this._handleMessage, options);\n      const topicMonitor = new PeerMonitor(this._ipfs.pubsub, topic);\n      topicMonitor.on('join', peer => {\n        logger.debug(`Peer joined ${topic}:`);\n        logger.debug(peer);\n\n        if (this._subscriptions[topic]) {\n          onNewPeerCallback(topic, peer);\n        } else {\n          logger.warn('Peer joined a room we don\\'t have a subscription for');\n          logger.warn(topic, peer);\n        }\n      });\n      topicMonitor.on('leave', peer => logger.debug(`Peer ${peer} left ${topic}`));\n      topicMonitor.on('error', e => logger.error(e));\n      this._subscriptions[topic] = {\n        topicMonitor: topicMonitor,\n        onMessage: onMessageCallback,\n        onNewPeer: onNewPeerCallback\n      };\n      topicsOpenCount++;\n      logger.debug(\"Topics open:\", topicsOpenCount);\n    }\n  }\n\n  async unsubscribe(hash) {\n    if (this._subscriptions[hash]) {\n      await this._ipfs.pubsub.unsubscribe(hash, this._handleMessage);\n\n      this._subscriptions[hash].topicMonitor.stop();\n\n      delete this._subscriptions[hash];\n      logger.debug(`Unsubscribed from '${hash}'`);\n      topicsOpenCount--;\n      logger.debug(\"Topics open:\", topicsOpenCount);\n    }\n  }\n\n  publish(topic, message, options = {}) {\n    if (this._subscriptions[topic] && this._ipfs.pubsub) {\n      let payload; //Buffer should be already serialized. Everything else will get serialized as json if not buffer, string.\n\n      if (Buffer.isBuffer(message) | typeof message === \"string\") {\n        payload = message;\n      } else {\n        payload = JSON.stringify(message);\n      }\n\n      this._ipfs.pubsub.publish(topic, Buffer.from(payload), options);\n    }\n  }\n\n  async disconnect() {\n    const topics = Object.keys(this._subscriptions);\n    await pSeries(topics.map(t => this.unsubscribe.bind(this, t)));\n    this._subscriptions = {};\n  }\n\n  async _handleMessage(message) {\n    // Don't process our own messages\n    if (message.from === this._id) return; // Get the message content and a subscription\n\n    let content, subscription, topicId; // Get the topic\n\n    topicId = message.topicIDs[0];\n\n    try {\n      content = JSON.parse(Buffer.from(message.data).toString());\n    } catch {\n      content = message.data; //Leave content alone. Meant for higher level code using custom serialization.\n    }\n\n    subscription = this._subscriptions[topicId];\n\n    if (subscription && subscription.onMessage && content) {\n      await subscription.onMessage(topicId, content, message.from);\n    }\n  }\n\n}\n\nmodule.exports = IPFSPubsub;","map":{"version":3,"sources":["/home/user/orbit-playground/music-app/node_modules/orbit-db-pubsub/src/ipfs-pubsub.js"],"names":["pSeries","require","PeerMonitor","Logger","logger","create","color","Colors","Yellow","setLogLevel","maxTopicsOpen","topicsOpenCount","IPFSPubsub","constructor","ipfs","id","_ipfs","_id","_subscriptions","pubsub","error","_handleMessage","bind","setMaxListeners","subscribe","topic","onMessageCallback","onNewPeerCallback","options","topicMonitor","on","peer","debug","warn","e","onMessage","onNewPeer","unsubscribe","hash","stop","publish","message","payload","Buffer","isBuffer","JSON","stringify","from","disconnect","topics","Object","keys","map","t","content","subscription","topicId","topicIDs","parse","data","toString","module","exports"],"mappings":"AAAA;;AAEA,MAAMA,OAAO,GAAGC,OAAO,CAAC,UAAD,CAAvB;;AACA,MAAMC,WAAW,GAAGD,OAAO,CAAC,0BAAD,CAA3B;;AAEA,MAAME,MAAM,GAAGF,OAAO,CAAC,WAAD,CAAtB;;AACA,MAAMG,MAAM,GAAGD,MAAM,CAACE,MAAP,CAAc,QAAd,EAAwB;AAAEC,EAAAA,KAAK,EAAEH,MAAM,CAACI,MAAP,CAAcC;AAAvB,CAAxB,CAAf;AACAL,MAAM,CAACM,WAAP,CAAmB,OAAnB;AAEA,MAAMC,aAAa,GAAG,GAAtB;AACA,IAAIC,eAAe,GAAG,CAAtB;;AAEA,MAAMC,UAAN,CAAiB;AACfC,EAAAA,WAAW,CAACC,IAAD,EAAOC,EAAP,EAAW;AACpB,SAAKC,KAAL,GAAaF,IAAb;AACA,SAAKG,GAAL,GAAWF,EAAX;AACA,SAAKG,cAAL,GAAsB,EAAtB;AAEA,QAAI,KAAKF,KAAL,CAAWG,MAAX,KAAsB,IAA1B,EACEf,MAAM,CAACgB,KAAP,CAAa,2FAAb;AAEF,SAAKC,cAAL,GAAsB,KAAKA,cAAL,CAAoBC,IAApB,CAAyB,IAAzB,CAAtB,CARoB,CAUpB;AACA;;AACA,QAAI,KAAKN,KAAL,CAAWO,eAAf,EACE,KAAKP,KAAL,CAAWO,eAAX,CAA2Bb,aAA3B;AACH;;AAED,QAAMc,SAAN,CAAgBC,KAAhB,EAAuBC,iBAAvB,EAA0CC,iBAA1C,EAA6DC,OAAO,GAAG,EAAvE,EAA2E;AACzE,QAAG,CAAC,KAAKV,cAAL,CAAoBO,KAApB,CAAD,IAA+B,KAAKT,KAAL,CAAWG,MAA7C,EAAqD;AACnD,YAAM,KAAKH,KAAL,CAAWG,MAAX,CAAkBK,SAAlB,CAA4BC,KAA5B,EAAmC,KAAKJ,cAAxC,EAAwDO,OAAxD,CAAN;AAEA,YAAMC,YAAY,GAAG,IAAI3B,WAAJ,CAAgB,KAAKc,KAAL,CAAWG,MAA3B,EAAmCM,KAAnC,CAArB;AAEAI,MAAAA,YAAY,CAACC,EAAb,CAAgB,MAAhB,EAAyBC,IAAD,IAAU;AAChC3B,QAAAA,MAAM,CAAC4B,KAAP,CAAc,eAAcP,KAAM,GAAlC;AACArB,QAAAA,MAAM,CAAC4B,KAAP,CAAaD,IAAb;;AACA,YAAI,KAAKb,cAAL,CAAoBO,KAApB,CAAJ,EAAgC;AAC9BE,UAAAA,iBAAiB,CAACF,KAAD,EAAQM,IAAR,CAAjB;AACD,SAFD,MAEO;AACL3B,UAAAA,MAAM,CAAC6B,IAAP,CAAY,sDAAZ;AACA7B,UAAAA,MAAM,CAAC6B,IAAP,CAAYR,KAAZ,EAAmBM,IAAnB;AACD;AACF,OATD;AAWAF,MAAAA,YAAY,CAACC,EAAb,CAAgB,OAAhB,EAA0BC,IAAD,IAAU3B,MAAM,CAAC4B,KAAP,CAAc,QAAOD,IAAK,SAAQN,KAAM,EAAxC,CAAnC;AACAI,MAAAA,YAAY,CAACC,EAAb,CAAgB,OAAhB,EAA0BI,CAAD,IAAO9B,MAAM,CAACgB,KAAP,CAAac,CAAb,CAAhC;AAEA,WAAKhB,cAAL,CAAoBO,KAApB,IAA6B;AAC3BI,QAAAA,YAAY,EAAEA,YADa;AAE3BM,QAAAA,SAAS,EAAET,iBAFgB;AAG3BU,QAAAA,SAAS,EAAET;AAHgB,OAA7B;AAMAhB,MAAAA,eAAe;AACfP,MAAAA,MAAM,CAAC4B,KAAP,CAAa,cAAb,EAA6BrB,eAA7B;AACD;AACF;;AAED,QAAM0B,WAAN,CAAkBC,IAAlB,EAAwB;AACtB,QAAG,KAAKpB,cAAL,CAAoBoB,IAApB,CAAH,EAA8B;AAC5B,YAAM,KAAKtB,KAAL,CAAWG,MAAX,CAAkBkB,WAAlB,CAA8BC,IAA9B,EAAoC,KAAKjB,cAAzC,CAAN;;AACA,WAAKH,cAAL,CAAoBoB,IAApB,EAA0BT,YAA1B,CAAuCU,IAAvC;;AACA,aAAO,KAAKrB,cAAL,CAAoBoB,IAApB,CAAP;AACAlC,MAAAA,MAAM,CAAC4B,KAAP,CAAc,sBAAqBM,IAAK,GAAxC;AACA3B,MAAAA,eAAe;AACfP,MAAAA,MAAM,CAAC4B,KAAP,CAAa,cAAb,EAA6BrB,eAA7B;AACD;AACF;;AAED6B,EAAAA,OAAO,CAACf,KAAD,EAAQgB,OAAR,EAAiBb,OAAO,GAAG,EAA3B,EAA+B;AACpC,QAAI,KAAKV,cAAL,CAAoBO,KAApB,KAA8B,KAAKT,KAAL,CAAWG,MAA7C,EAAqD;AACnD,UAAIuB,OAAJ,CADmD,CAEnD;;AACA,UAAGC,MAAM,CAACC,QAAP,CAAgBH,OAAhB,IAA2B,OAAOA,OAAP,KAAmB,QAAjD,EAA2D;AACzDC,QAAAA,OAAO,GAAGD,OAAV;AACD,OAFD,MAEO;AACLC,QAAAA,OAAO,GAAGG,IAAI,CAACC,SAAL,CAAeL,OAAf,CAAV;AACD;;AACD,WAAKzB,KAAL,CAAWG,MAAX,CAAkBqB,OAAlB,CAA0Bf,KAA1B,EAAiCkB,MAAM,CAACI,IAAP,CAAYL,OAAZ,CAAjC,EAAuDd,OAAvD;AACD;AACF;;AAED,QAAMoB,UAAN,GAAmB;AACjB,UAAMC,MAAM,GAAGC,MAAM,CAACC,IAAP,CAAY,KAAKjC,cAAjB,CAAf;AACA,UAAMlB,OAAO,CAACiD,MAAM,CAACG,GAAP,CAAYC,CAAD,IAAO,KAAKhB,WAAL,CAAiBf,IAAjB,CAAsB,IAAtB,EAA4B+B,CAA5B,CAAlB,CAAD,CAAb;AACA,SAAKnC,cAAL,GAAsB,EAAtB;AACD;;AAED,QAAMG,cAAN,CAAqBoB,OAArB,EAA8B;AAC5B;AACA,QAAIA,OAAO,CAACM,IAAR,KAAiB,KAAK9B,GAA1B,EACE,OAH0B,CAK5B;;AACA,QAAIqC,OAAJ,EAAaC,YAAb,EAA2BC,OAA3B,CAN4B,CAQ5B;;AACAA,IAAAA,OAAO,GAAGf,OAAO,CAACgB,QAAR,CAAiB,CAAjB,CAAV;;AACA,QAAI;AACFH,MAAAA,OAAO,GAAGT,IAAI,CAACa,KAAL,CAAWf,MAAM,CAACI,IAAP,CAAYN,OAAO,CAACkB,IAApB,EAA0BC,QAA1B,EAAX,CAAV;AACD,KAFD,CAEE,MAAM;AACNN,MAAAA,OAAO,GAAGb,OAAO,CAACkB,IAAlB,CADM,CACkB;AACzB;;AACDJ,IAAAA,YAAY,GAAG,KAAKrC,cAAL,CAAoBsC,OAApB,CAAf;;AAEA,QAAGD,YAAY,IAAIA,YAAY,CAACpB,SAA7B,IAA0CmB,OAA7C,EAAsD;AACpD,YAAMC,YAAY,CAACpB,SAAb,CAAuBqB,OAAvB,EAAgCF,OAAhC,EAAyCb,OAAO,CAACM,IAAjD,CAAN;AACD;AACF;;AAlGc;;AAqGjBc,MAAM,CAACC,OAAP,GAAiBlD,UAAjB","sourcesContent":["'use strict'\n\nconst pSeries = require('p-series')\nconst PeerMonitor = require('ipfs-pubsub-peer-monitor')\n\nconst Logger = require('logplease')\nconst logger = Logger.create(\"pubsub\", { color: Logger.Colors.Yellow })\nLogger.setLogLevel('ERROR')\n\nconst maxTopicsOpen = 256\nlet topicsOpenCount = 0\n\nclass IPFSPubsub {\n  constructor(ipfs, id) {\n    this._ipfs = ipfs\n    this._id = id\n    this._subscriptions = {}\n\n    if (this._ipfs.pubsub === null)\n      logger.error(\"The provided version of ipfs doesn't have pubsub support. Messages will not be exchanged.\")\n\n    this._handleMessage = this._handleMessage.bind(this)\n\n    // Bump up the number of listeners we can have open,\n    // ie. number of databases replicating\n    if (this._ipfs.setMaxListeners)\n      this._ipfs.setMaxListeners(maxTopicsOpen)\n  }\n\n  async subscribe(topic, onMessageCallback, onNewPeerCallback, options = {}) {\n    if(!this._subscriptions[topic] && this._ipfs.pubsub) {\n      await this._ipfs.pubsub.subscribe(topic, this._handleMessage, options)\n\n      const topicMonitor = new PeerMonitor(this._ipfs.pubsub, topic)\n\n      topicMonitor.on('join', (peer) => {\n        logger.debug(`Peer joined ${topic}:`)\n        logger.debug(peer)\n        if (this._subscriptions[topic]) {\n          onNewPeerCallback(topic, peer)\n        } else {\n          logger.warn('Peer joined a room we don\\'t have a subscription for')\n          logger.warn(topic, peer)\n        }\n      })\n\n      topicMonitor.on('leave', (peer) => logger.debug(`Peer ${peer} left ${topic}`))\n      topicMonitor.on('error', (e) => logger.error(e))\n\n      this._subscriptions[topic] = {\n        topicMonitor: topicMonitor,\n        onMessage: onMessageCallback,\n        onNewPeer: onNewPeerCallback\n      }\n\n      topicsOpenCount ++\n      logger.debug(\"Topics open:\", topicsOpenCount)\n    }\n  }\n\n  async unsubscribe(hash) {\n    if(this._subscriptions[hash]) {\n      await this._ipfs.pubsub.unsubscribe(hash, this._handleMessage)\n      this._subscriptions[hash].topicMonitor.stop()\n      delete this._subscriptions[hash]\n      logger.debug(`Unsubscribed from '${hash}'`)\n      topicsOpenCount --\n      logger.debug(\"Topics open:\", topicsOpenCount)\n    }\n  }\n\n  publish(topic, message, options = {}) {\n    if (this._subscriptions[topic] && this._ipfs.pubsub) {\n      let payload;\n      //Buffer should be already serialized. Everything else will get serialized as json if not buffer, string.\n      if(Buffer.isBuffer(message) | typeof message === \"string\") {\n        payload = message;\n      } else {\n        payload = JSON.stringify(message);\n      }\n      this._ipfs.pubsub.publish(topic, Buffer.from(payload), options)\n    }\n  }\n\n  async disconnect() {\n    const topics = Object.keys(this._subscriptions)\n    await pSeries(topics.map((t) => this.unsubscribe.bind(this, t)))\n    this._subscriptions = {}\n  }\n\n  async _handleMessage(message) {\n    // Don't process our own messages\n    if (message.from === this._id)\n      return\n\n    // Get the message content and a subscription\n    let content, subscription, topicId\n\n    // Get the topic\n    topicId = message.topicIDs[0]\n    try {\n      content = JSON.parse(Buffer.from(message.data).toString())\n    } catch {\n      content = message.data; //Leave content alone. Meant for higher level code using custom serialization.\n    }\n    subscription = this._subscriptions[topicId]\n\n    if(subscription && subscription.onMessage && content) {\n      await subscription.onMessage(topicId, content, message.from)\n    }\n  }\n}\n\nmodule.exports = IPFSPubsub\n"]},"metadata":{},"sourceType":"script"}