{"ast":null,"code":"'use strict';\n\nconst errcode = require('err-code');\n\nconst debug = require('debug');\n\nconst log = debug('libp2p:peer-store:address-book');\nlog.error = debug('libp2p:peer-store:address-book:error');\n\nconst multiaddr = require('multiaddr');\n\nconst PeerId = require('peer-id');\n\nconst Book = require('./book');\n\nconst PeerRecord = require('../record/peer-record');\n\nconst {\n  codes: {\n    ERR_INVALID_PARAMETERS\n  }\n} = require('../errors');\n\nconst Envelope = require('../record/envelope');\n/**\n * The AddressBook is responsible for keeping the known multiaddrs\n * of a peer.\n */\n\n\nclass AddressBook extends Book {\n  /**\n   * Address object\n   * @typedef {Object} Address\n   * @property {Multiaddr} multiaddr peer multiaddr.\n   * @property {boolean} isCertified obtained from a signed peer record.\n   */\n\n  /**\n  * CertifiedRecord object\n  * @typedef {Object} CertifiedRecord\n  * @property {Uint8Array} raw raw envelope.\n  * @property {number} seqNumber seq counter.\n  */\n\n  /**\n  * Entry object for the addressBook\n  * @typedef {Object} Entry\n  * @property {Array<Address>} addresses peer Addresses.\n  * @property {CertifiedRecord} record certified peer record.\n  */\n\n  /**\n  * @constructor\n  * @param {PeerStore} peerStore\n  */\n  constructor(peerStore) {\n    /**\n     * PeerStore Event emitter, used by the AddressBook to emit:\n     * \"peer\" - emitted when a peer is discovered by the node.\n     * \"change:multiaddrs\" - emitted when the known multiaddrs of a peer change.\n     */\n    super({\n      peerStore,\n      eventName: 'change:multiaddrs',\n      eventProperty: 'multiaddrs',\n      eventTransformer: data => {\n        if (!data.addresses) {\n          return [];\n        }\n\n        return data.addresses.map(address => address.multiaddr);\n      }\n    });\n    /**\n     * Map known peers to their known Address Entries.\n     * @type {Map<string, Array<Entry>>}\n     */\n\n    this.data = new Map();\n  }\n  /**\n   * ConsumePeerRecord adds addresses from a signed peer record contained in a record envelope.\n   * This will return a boolean that indicates if the record was successfully processed and added\n   * into the AddressBook.\n   * @param {Envelope} envelope\n   * @return {boolean}\n   */\n\n\n  consumePeerRecord(envelope) {\n    let peerRecord;\n\n    try {\n      peerRecord = PeerRecord.createFromProtobuf(envelope.payload);\n    } catch (err) {\n      log.error('invalid peer record received');\n      return false;\n    } // Verify peerId\n\n\n    if (!peerRecord.peerId.equals(envelope.peerId)) {\n      log('signing key does not match PeerId in the PeerRecord');\n      return false;\n    } // ensure the record has multiaddrs\n\n\n    if (!peerRecord.multiaddrs || !peerRecord.multiaddrs.length) {\n      return false;\n    }\n\n    const peerId = peerRecord.peerId;\n    const id = peerId.toB58String();\n    const entry = this.data.get(id) || {};\n    const storedRecord = entry.record; // ensure seq is greater than, or equal to, the last received\n\n    if (storedRecord && storedRecord.seqNumber >= peerRecord.seqNumber) {\n      return false;\n    }\n\n    const addresses = this._toAddresses(peerRecord.multiaddrs, true); // Replace unsigned addresses by the new ones from the record\n    // TODO: Once we have ttls for the addresses, we should merge these in.\n\n\n    this._setData(peerId, {\n      addresses,\n      record: {\n        raw: envelope.marshal(),\n        seqNumber: peerRecord.seqNumber\n      }\n    });\n\n    log(`stored provided peer record for ${id}`);\n    return true;\n  }\n  /**\n   * Get the raw Envelope for a peer. Returns\n   * undefined if no Envelope is found.\n   * @param {PeerId} peerId\n   * @return {Uint8Array|undefined}\n   */\n\n\n  getRawEnvelope(peerId) {\n    const entry = this.data.get(peerId.toB58String());\n\n    if (!entry || !entry.record || !entry.record.raw) {\n      return undefined;\n    }\n\n    return entry.record.raw;\n  }\n  /**\n   * Get an Envelope containing a PeerRecord for the given peer.\n   * Returns undefined if no record exists.\n   * @param {PeerId} peerId\n   * @return {Promise<Envelope|void>}\n   */\n\n\n  getPeerRecord(peerId) {\n    const raw = this.getRawEnvelope(peerId);\n\n    if (!raw) {\n      return undefined;\n    }\n\n    return Envelope.createFromProtobuf(raw);\n  }\n  /**\n   * Set known multiaddrs of a provided peer.\n   * This will replace previously stored multiaddrs, if available.\n   * Replacing stored multiaddrs might result in losing obtained certified addresses.\n   * If you are not sure, it's recommended to use `add` instead.\n   * @override\n   * @param {PeerId} peerId\n   * @param {Array<Multiaddr>} multiaddrs\n   * @returns {AddressBook}\n   */\n\n\n  set(peerId, multiaddrs) {\n    if (!PeerId.isPeerId(peerId)) {\n      log.error('peerId must be an instance of peer-id to store data');\n      throw errcode(new Error('peerId must be an instance of peer-id'), ERR_INVALID_PARAMETERS);\n    }\n\n    const addresses = this._toAddresses(multiaddrs);\n\n    const id = peerId.toB58String();\n    const entry = this.data.get(id) || {};\n    const rec = entry.addresses; // Not replace multiaddrs\n\n    if (!addresses.length) {\n      return this;\n    } // Already knows the peer\n\n\n    if (rec && rec.length === addresses.length) {\n      const intersection = rec.filter(addr => addresses.some(newAddr => addr.multiaddr.equals(newAddr.multiaddr))); // Are new addresses equal to the old ones?\n      // If yes, no changes needed!\n\n      if (intersection.length === rec.length) {\n        log(`the addresses provided to store are equal to the already stored for ${id}`);\n        return this;\n      }\n    }\n\n    this._setData(peerId, {\n      addresses,\n      record: entry.record\n    });\n\n    log(`stored provided multiaddrs for ${id}`); // Notify the existance of a new peer\n\n    if (!rec) {\n      this._ps.emit('peer', peerId);\n    }\n\n    return this;\n  }\n  /**\n   * Add known addresses of a provided peer.\n   * If the peer is not known, it is set with the given addresses.\n   * @param {PeerId} peerId\n   * @param {Array<Multiaddr>} multiaddrs\n   * @returns {AddressBook}\n   */\n\n\n  add(peerId, multiaddrs) {\n    if (!PeerId.isPeerId(peerId)) {\n      log.error('peerId must be an instance of peer-id to store data');\n      throw errcode(new Error('peerId must be an instance of peer-id'), ERR_INVALID_PARAMETERS);\n    }\n\n    const addresses = this._toAddresses(multiaddrs);\n\n    const id = peerId.toB58String();\n    const entry = this.data.get(id) || {};\n    const rec = entry.addresses || []; // Add recorded uniquely to the new array (Union)\n\n    rec.forEach(addr => {\n      if (!addresses.find(r => r.multiaddr.equals(addr.multiaddr))) {\n        addresses.push(addr);\n      }\n    }); // If the recorded length is equal to the new after the unique union\n    // The content is the same, no need to update.\n\n    if (rec && rec.length === addresses.length) {\n      log(`the addresses provided to store are already stored for ${id}`);\n      return this;\n    }\n\n    this._setData(peerId, {\n      addresses,\n      record: entry.record\n    });\n\n    log(`added provided multiaddrs for ${id}`); // Notify the existance of a new peer\n\n    if (!entry.addresses) {\n      this._ps.emit('peer', peerId);\n    }\n\n    return this;\n  }\n  /**\n   * Get the known data of a provided peer.\n   * @override\n   * @param {PeerId} peerId\n   * @returns {Array<data>}\n   */\n\n\n  get(peerId) {\n    if (!PeerId.isPeerId(peerId)) {\n      throw errcode(new Error('peerId must be an instance of peer-id'), ERR_INVALID_PARAMETERS);\n    }\n\n    const entry = this.data.get(peerId.toB58String());\n    return entry && entry.addresses ? [...entry.addresses] : undefined;\n  }\n  /**\n   * Transforms received multiaddrs into Address.\n   * @private\n   * @param {Array<Multiaddr>} multiaddrs\n   * @param {boolean} [isCertified]\n   * @returns {Array<Address>}\n   */\n\n\n  _toAddresses(multiaddrs, isCertified = false) {\n    if (!multiaddrs) {\n      log.error('multiaddrs must be provided to store data');\n      throw errcode(new Error('multiaddrs must be provided'), ERR_INVALID_PARAMETERS);\n    } // create Address for each address\n\n\n    const addresses = [];\n    multiaddrs.forEach(addr => {\n      if (!multiaddr.isMultiaddr(addr)) {\n        log.error(`multiaddr ${addr} must be an instance of multiaddr`);\n        throw errcode(new Error(`multiaddr ${addr} must be an instance of multiaddr`), ERR_INVALID_PARAMETERS);\n      }\n\n      addresses.push({\n        multiaddr: addr,\n        isCertified\n      });\n    });\n    return addresses;\n  }\n  /**\n   * Get the known multiaddrs for a given peer. All returned multiaddrs\n   * will include the encapsulated `PeerId` of the peer.\n   * Returns `undefined` if there are no known multiaddrs for the given peer.\n   * @param {PeerId} peerId\n   * @returns {Array<Multiaddr>|undefined}\n   */\n\n\n  getMultiaddrsForPeer(peerId) {\n    if (!PeerId.isPeerId(peerId)) {\n      throw errcode(new Error('peerId must be an instance of peer-id'), ERR_INVALID_PARAMETERS);\n    }\n\n    const entry = this.data.get(peerId.toB58String());\n\n    if (!entry || !entry.addresses) {\n      return undefined;\n    }\n\n    return entry.addresses.map(address => {\n      const multiaddr = address.multiaddr;\n      const idString = multiaddr.getPeerId();\n      if (idString && idString === peerId.toB58String()) return multiaddr;\n      return multiaddr.encapsulate(`/p2p/${peerId.toB58String()}`);\n    });\n  }\n\n}\n\nmodule.exports = AddressBook;","map":{"version":3,"sources":["/home/user/orbit-playground/music-app/node_modules/libp2p/src/peer-store/address-book.js"],"names":["errcode","require","debug","log","error","multiaddr","PeerId","Book","PeerRecord","codes","ERR_INVALID_PARAMETERS","Envelope","AddressBook","constructor","peerStore","eventName","eventProperty","eventTransformer","data","addresses","map","address","Map","consumePeerRecord","envelope","peerRecord","createFromProtobuf","payload","err","peerId","equals","multiaddrs","length","id","toB58String","entry","get","storedRecord","record","seqNumber","_toAddresses","_setData","raw","marshal","getRawEnvelope","undefined","getPeerRecord","set","isPeerId","Error","rec","intersection","filter","addr","some","newAddr","_ps","emit","add","forEach","find","r","push","isCertified","isMultiaddr","getMultiaddrsForPeer","idString","getPeerId","encapsulate","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst errcode = require('err-code')\nconst debug = require('debug')\nconst log = debug('libp2p:peer-store:address-book')\nlog.error = debug('libp2p:peer-store:address-book:error')\n\nconst multiaddr = require('multiaddr')\nconst PeerId = require('peer-id')\n\nconst Book = require('./book')\nconst PeerRecord = require('../record/peer-record')\n\nconst {\n  codes: { ERR_INVALID_PARAMETERS }\n} = require('../errors')\nconst Envelope = require('../record/envelope')\n\n/**\n * The AddressBook is responsible for keeping the known multiaddrs\n * of a peer.\n */\nclass AddressBook extends Book {\n  /**\n   * Address object\n   * @typedef {Object} Address\n   * @property {Multiaddr} multiaddr peer multiaddr.\n   * @property {boolean} isCertified obtained from a signed peer record.\n   */\n\n  /**\n  * CertifiedRecord object\n  * @typedef {Object} CertifiedRecord\n  * @property {Uint8Array} raw raw envelope.\n  * @property {number} seqNumber seq counter.\n  */\n\n  /**\n  * Entry object for the addressBook\n  * @typedef {Object} Entry\n  * @property {Array<Address>} addresses peer Addresses.\n  * @property {CertifiedRecord} record certified peer record.\n  */\n\n  /**\n  * @constructor\n  * @param {PeerStore} peerStore\n  */\n  constructor (peerStore) {\n    /**\n     * PeerStore Event emitter, used by the AddressBook to emit:\n     * \"peer\" - emitted when a peer is discovered by the node.\n     * \"change:multiaddrs\" - emitted when the known multiaddrs of a peer change.\n     */\n    super({\n      peerStore,\n      eventName: 'change:multiaddrs',\n      eventProperty: 'multiaddrs',\n      eventTransformer: (data) => {\n        if (!data.addresses) {\n          return []\n        }\n        return data.addresses.map((address) => address.multiaddr)\n      }\n    })\n\n    /**\n     * Map known peers to their known Address Entries.\n     * @type {Map<string, Array<Entry>>}\n     */\n    this.data = new Map()\n  }\n\n  /**\n   * ConsumePeerRecord adds addresses from a signed peer record contained in a record envelope.\n   * This will return a boolean that indicates if the record was successfully processed and added\n   * into the AddressBook.\n   * @param {Envelope} envelope\n   * @return {boolean}\n   */\n  consumePeerRecord (envelope) {\n    let peerRecord\n    try {\n      peerRecord = PeerRecord.createFromProtobuf(envelope.payload)\n    } catch (err) {\n      log.error('invalid peer record received')\n      return false\n    }\n\n    // Verify peerId\n    if (!peerRecord.peerId.equals(envelope.peerId)) {\n      log('signing key does not match PeerId in the PeerRecord')\n      return false\n    }\n\n    // ensure the record has multiaddrs\n    if (!peerRecord.multiaddrs || !peerRecord.multiaddrs.length) {\n      return false\n    }\n\n    const peerId = peerRecord.peerId\n    const id = peerId.toB58String()\n    const entry = this.data.get(id) || {}\n    const storedRecord = entry.record\n\n    // ensure seq is greater than, or equal to, the last received\n    if (storedRecord && storedRecord.seqNumber >= peerRecord.seqNumber) {\n      return false\n    }\n\n    const addresses = this._toAddresses(peerRecord.multiaddrs, true)\n\n    // Replace unsigned addresses by the new ones from the record\n    // TODO: Once we have ttls for the addresses, we should merge these in.\n    this._setData(peerId, {\n      addresses,\n      record: {\n        raw: envelope.marshal(),\n        seqNumber: peerRecord.seqNumber\n      }\n    })\n    log(`stored provided peer record for ${id}`)\n\n    return true\n  }\n\n  /**\n   * Get the raw Envelope for a peer. Returns\n   * undefined if no Envelope is found.\n   * @param {PeerId} peerId\n   * @return {Uint8Array|undefined}\n   */\n  getRawEnvelope (peerId) {\n    const entry = this.data.get(peerId.toB58String())\n\n    if (!entry || !entry.record || !entry.record.raw) {\n      return undefined\n    }\n\n    return entry.record.raw\n  }\n\n  /**\n   * Get an Envelope containing a PeerRecord for the given peer.\n   * Returns undefined if no record exists.\n   * @param {PeerId} peerId\n   * @return {Promise<Envelope|void>}\n   */\n  getPeerRecord (peerId) {\n    const raw = this.getRawEnvelope(peerId)\n\n    if (!raw) {\n      return undefined\n    }\n\n    return Envelope.createFromProtobuf(raw)\n  }\n\n  /**\n   * Set known multiaddrs of a provided peer.\n   * This will replace previously stored multiaddrs, if available.\n   * Replacing stored multiaddrs might result in losing obtained certified addresses.\n   * If you are not sure, it's recommended to use `add` instead.\n   * @override\n   * @param {PeerId} peerId\n   * @param {Array<Multiaddr>} multiaddrs\n   * @returns {AddressBook}\n   */\n  set (peerId, multiaddrs) {\n    if (!PeerId.isPeerId(peerId)) {\n      log.error('peerId must be an instance of peer-id to store data')\n      throw errcode(new Error('peerId must be an instance of peer-id'), ERR_INVALID_PARAMETERS)\n    }\n\n    const addresses = this._toAddresses(multiaddrs)\n    const id = peerId.toB58String()\n    const entry = this.data.get(id) || {}\n    const rec = entry.addresses\n\n    // Not replace multiaddrs\n    if (!addresses.length) {\n      return this\n    }\n\n    // Already knows the peer\n    if (rec && rec.length === addresses.length) {\n      const intersection = rec.filter((addr) => addresses.some((newAddr) => addr.multiaddr.equals(newAddr.multiaddr)))\n\n      // Are new addresses equal to the old ones?\n      // If yes, no changes needed!\n      if (intersection.length === rec.length) {\n        log(`the addresses provided to store are equal to the already stored for ${id}`)\n        return this\n      }\n    }\n\n    this._setData(peerId, {\n      addresses,\n      record: entry.record\n    })\n    log(`stored provided multiaddrs for ${id}`)\n\n    // Notify the existance of a new peer\n    if (!rec) {\n      this._ps.emit('peer', peerId)\n    }\n\n    return this\n  }\n\n  /**\n   * Add known addresses of a provided peer.\n   * If the peer is not known, it is set with the given addresses.\n   * @param {PeerId} peerId\n   * @param {Array<Multiaddr>} multiaddrs\n   * @returns {AddressBook}\n   */\n  add (peerId, multiaddrs) {\n    if (!PeerId.isPeerId(peerId)) {\n      log.error('peerId must be an instance of peer-id to store data')\n      throw errcode(new Error('peerId must be an instance of peer-id'), ERR_INVALID_PARAMETERS)\n    }\n\n    const addresses = this._toAddresses(multiaddrs)\n    const id = peerId.toB58String()\n\n    const entry = this.data.get(id) || {}\n    const rec = entry.addresses || []\n\n    // Add recorded uniquely to the new array (Union)\n    rec.forEach((addr) => {\n      if (!addresses.find(r => r.multiaddr.equals(addr.multiaddr))) {\n        addresses.push(addr)\n      }\n    })\n\n    // If the recorded length is equal to the new after the unique union\n    // The content is the same, no need to update.\n    if (rec && rec.length === addresses.length) {\n      log(`the addresses provided to store are already stored for ${id}`)\n      return this\n    }\n\n    this._setData(peerId, {\n      addresses,\n      record: entry.record\n    })\n\n    log(`added provided multiaddrs for ${id}`)\n\n    // Notify the existance of a new peer\n    if (!entry.addresses) {\n      this._ps.emit('peer', peerId)\n    }\n\n    return this\n  }\n\n  /**\n   * Get the known data of a provided peer.\n   * @override\n   * @param {PeerId} peerId\n   * @returns {Array<data>}\n   */\n  get (peerId) {\n    if (!PeerId.isPeerId(peerId)) {\n      throw errcode(new Error('peerId must be an instance of peer-id'), ERR_INVALID_PARAMETERS)\n    }\n\n    const entry = this.data.get(peerId.toB58String())\n\n    return entry && entry.addresses ? [...entry.addresses] : undefined\n  }\n\n  /**\n   * Transforms received multiaddrs into Address.\n   * @private\n   * @param {Array<Multiaddr>} multiaddrs\n   * @param {boolean} [isCertified]\n   * @returns {Array<Address>}\n   */\n  _toAddresses (multiaddrs, isCertified = false) {\n    if (!multiaddrs) {\n      log.error('multiaddrs must be provided to store data')\n      throw errcode(new Error('multiaddrs must be provided'), ERR_INVALID_PARAMETERS)\n    }\n\n    // create Address for each address\n    const addresses = []\n    multiaddrs.forEach((addr) => {\n      if (!multiaddr.isMultiaddr(addr)) {\n        log.error(`multiaddr ${addr} must be an instance of multiaddr`)\n        throw errcode(new Error(`multiaddr ${addr} must be an instance of multiaddr`), ERR_INVALID_PARAMETERS)\n      }\n\n      addresses.push({\n        multiaddr: addr,\n        isCertified\n      })\n    })\n\n    return addresses\n  }\n\n  /**\n   * Get the known multiaddrs for a given peer. All returned multiaddrs\n   * will include the encapsulated `PeerId` of the peer.\n   * Returns `undefined` if there are no known multiaddrs for the given peer.\n   * @param {PeerId} peerId\n   * @returns {Array<Multiaddr>|undefined}\n   */\n  getMultiaddrsForPeer (peerId) {\n    if (!PeerId.isPeerId(peerId)) {\n      throw errcode(new Error('peerId must be an instance of peer-id'), ERR_INVALID_PARAMETERS)\n    }\n\n    const entry = this.data.get(peerId.toB58String())\n\n    if (!entry || !entry.addresses) {\n      return undefined\n    }\n\n    return entry.addresses.map((address) => {\n      const multiaddr = address.multiaddr\n\n      const idString = multiaddr.getPeerId()\n      if (idString && idString === peerId.toB58String()) return multiaddr\n\n      return multiaddr.encapsulate(`/p2p/${peerId.toB58String()}`)\n    })\n  }\n}\n\nmodule.exports = AddressBook\n"]},"metadata":{},"sourceType":"script"}