{"ast":null,"code":"'use strict';\n\nconst multiaddr = require('multiaddr');\n\nconst PeerId = require('peer-id');\n\nconst Record = require('libp2p-interfaces/src/record');\n\nconst arrayEquals = require('libp2p-utils/src/array-equals');\n\nconst Protobuf = require('./peer-record.proto');\n\nconst {\n  ENVELOPE_DOMAIN_PEER_RECORD,\n  ENVELOPE_PAYLOAD_TYPE_PEER_RECORD\n} = require('./consts');\n/**\n * The PeerRecord is used for distributing peer routing records across the network.\n * It contains the peer's reachable listen addresses.\n */\n\n\nclass PeerRecord extends Record {\n  /**\n   * @constructor\n   * @param {object} params\n   * @param {PeerId} params.peerId\n   * @param {Array<multiaddr>} params.multiaddrs addresses of the associated peer.\n   * @param {number} [params.seqNumber] monotonically-increasing sequence counter that's used to order PeerRecords in time.\n   */\n  constructor({\n    peerId,\n    multiaddrs = [],\n    seqNumber = Date.now()\n  }) {\n    super(ENVELOPE_DOMAIN_PEER_RECORD, ENVELOPE_PAYLOAD_TYPE_PEER_RECORD);\n    this.peerId = peerId;\n    this.multiaddrs = multiaddrs;\n    this.seqNumber = seqNumber; // Cache\n\n    this._marshal = undefined;\n  }\n  /**\n   * Marshal a record to be used in an envelope.\n   * @return {Uint8Array}\n   */\n\n\n  marshal() {\n    if (this._marshal) {\n      return this._marshal;\n    }\n\n    this._marshal = Protobuf.encode({\n      peer_id: this.peerId.toBytes(),\n      seq: this.seqNumber,\n      addresses: this.multiaddrs.map(m => ({\n        multiaddr: m.bytes\n      }))\n    });\n    return this._marshal;\n  }\n  /**\n   * Returns true if `this` record equals the `other`.\n   * @param {Record} other\n   * @return {boolean}\n   */\n\n\n  equals(other) {\n    // Validate PeerId\n    if (!this.peerId.equals(other.peerId)) {\n      return false;\n    } // Validate seqNumber\n\n\n    if (this.seqNumber !== other.seqNumber) {\n      return false;\n    } // Validate multiaddrs\n\n\n    if (!arrayEquals(this.multiaddrs, other.multiaddrs)) {\n      return false;\n    }\n\n    return true;\n  }\n\n}\n/**\n * Unmarshal Peer Record Protobuf.\n * @param {Uint8Array} buf marshaled peer record.\n * @return {PeerRecord}\n */\n\n\nPeerRecord.createFromProtobuf = buf => {\n  // Decode\n  const peerRecord = Protobuf.decode(buf);\n  const peerId = PeerId.createFromBytes(peerRecord.peer_id);\n  const multiaddrs = (peerRecord.addresses || []).map(a => multiaddr(a.multiaddr));\n  const seqNumber = peerRecord.seq;\n  return new PeerRecord({\n    peerId,\n    multiaddrs,\n    seqNumber\n  });\n};\n\nPeerRecord.DOMAIN = ENVELOPE_DOMAIN_PEER_RECORD;\nmodule.exports = PeerRecord;","map":{"version":3,"sources":["/home/user/orbit-playground/music-app/node_modules/libp2p/src/record/peer-record/index.js"],"names":["multiaddr","require","PeerId","Record","arrayEquals","Protobuf","ENVELOPE_DOMAIN_PEER_RECORD","ENVELOPE_PAYLOAD_TYPE_PEER_RECORD","PeerRecord","constructor","peerId","multiaddrs","seqNumber","Date","now","_marshal","undefined","marshal","encode","peer_id","toBytes","seq","addresses","map","m","bytes","equals","other","createFromProtobuf","buf","peerRecord","decode","createFromBytes","a","DOMAIN","module","exports"],"mappings":"AAAA;;AAEA,MAAMA,SAAS,GAAGC,OAAO,CAAC,WAAD,CAAzB;;AACA,MAAMC,MAAM,GAAGD,OAAO,CAAC,SAAD,CAAtB;;AACA,MAAME,MAAM,GAAGF,OAAO,CAAC,8BAAD,CAAtB;;AACA,MAAMG,WAAW,GAAGH,OAAO,CAAC,+BAAD,CAA3B;;AAEA,MAAMI,QAAQ,GAAGJ,OAAO,CAAC,qBAAD,CAAxB;;AACA,MAAM;AACJK,EAAAA,2BADI;AAEJC,EAAAA;AAFI,IAGFN,OAAO,CAAC,UAAD,CAHX;AAKA;;;;;;AAIA,MAAMO,UAAN,SAAyBL,MAAzB,CAAgC;AAC9B;;;;;;;AAOAM,EAAAA,WAAW,CAAE;AAAEC,IAAAA,MAAF;AAAUC,IAAAA,UAAU,GAAG,EAAvB;AAA2BC,IAAAA,SAAS,GAAGC,IAAI,CAACC,GAAL;AAAvC,GAAF,EAAuD;AAChE,UAAMR,2BAAN,EAAmCC,iCAAnC;AAEA,SAAKG,MAAL,GAAcA,MAAd;AACA,SAAKC,UAAL,GAAkBA,UAAlB;AACA,SAAKC,SAAL,GAAiBA,SAAjB,CALgE,CAOhE;;AACA,SAAKG,QAAL,GAAgBC,SAAhB;AACD;AAED;;;;;;AAIAC,EAAAA,OAAO,GAAI;AACT,QAAI,KAAKF,QAAT,EAAmB;AACjB,aAAO,KAAKA,QAAZ;AACD;;AAED,SAAKA,QAAL,GAAgBV,QAAQ,CAACa,MAAT,CAAgB;AAC9BC,MAAAA,OAAO,EAAE,KAAKT,MAAL,CAAYU,OAAZ,EADqB;AAE9BC,MAAAA,GAAG,EAAE,KAAKT,SAFoB;AAG9BU,MAAAA,SAAS,EAAE,KAAKX,UAAL,CAAgBY,GAAhB,CAAqBC,CAAD,KAAQ;AACrCxB,QAAAA,SAAS,EAAEwB,CAAC,CAACC;AADwB,OAAR,CAApB;AAHmB,KAAhB,CAAhB;AAQA,WAAO,KAAKV,QAAZ;AACD;AAED;;;;;;;AAKAW,EAAAA,MAAM,CAAEC,KAAF,EAAS;AACb;AACA,QAAI,CAAC,KAAKjB,MAAL,CAAYgB,MAAZ,CAAmBC,KAAK,CAACjB,MAAzB,CAAL,EAAuC;AACrC,aAAO,KAAP;AACD,KAJY,CAMb;;;AACA,QAAI,KAAKE,SAAL,KAAmBe,KAAK,CAACf,SAA7B,EAAwC;AACtC,aAAO,KAAP;AACD,KATY,CAWb;;;AACA,QAAI,CAACR,WAAW,CAAC,KAAKO,UAAN,EAAkBgB,KAAK,CAAChB,UAAxB,CAAhB,EAAqD;AACnD,aAAO,KAAP;AACD;;AAED,WAAO,IAAP;AACD;;AA7D6B;AAgEhC;;;;;;;AAKAH,UAAU,CAACoB,kBAAX,GAAiCC,GAAD,IAAS;AACvC;AACA,QAAMC,UAAU,GAAGzB,QAAQ,CAAC0B,MAAT,CAAgBF,GAAhB,CAAnB;AAEA,QAAMnB,MAAM,GAAGR,MAAM,CAAC8B,eAAP,CAAuBF,UAAU,CAACX,OAAlC,CAAf;AACA,QAAMR,UAAU,GAAG,CAACmB,UAAU,CAACR,SAAX,IAAwB,EAAzB,EAA6BC,GAA7B,CAAkCU,CAAD,IAAOjC,SAAS,CAACiC,CAAC,CAACjC,SAAH,CAAjD,CAAnB;AACA,QAAMY,SAAS,GAAGkB,UAAU,CAACT,GAA7B;AAEA,SAAO,IAAIb,UAAJ,CAAe;AAAEE,IAAAA,MAAF;AAAUC,IAAAA,UAAV;AAAsBC,IAAAA;AAAtB,GAAf,CAAP;AACD,CATD;;AAWAJ,UAAU,CAAC0B,MAAX,GAAoB5B,2BAApB;AAEA6B,MAAM,CAACC,OAAP,GAAiB5B,UAAjB","sourcesContent":["'use strict'\n\nconst multiaddr = require('multiaddr')\nconst PeerId = require('peer-id')\nconst Record = require('libp2p-interfaces/src/record')\nconst arrayEquals = require('libp2p-utils/src/array-equals')\n\nconst Protobuf = require('./peer-record.proto')\nconst {\n  ENVELOPE_DOMAIN_PEER_RECORD,\n  ENVELOPE_PAYLOAD_TYPE_PEER_RECORD\n} = require('./consts')\n\n/**\n * The PeerRecord is used for distributing peer routing records across the network.\n * It contains the peer's reachable listen addresses.\n */\nclass PeerRecord extends Record {\n  /**\n   * @constructor\n   * @param {object} params\n   * @param {PeerId} params.peerId\n   * @param {Array<multiaddr>} params.multiaddrs addresses of the associated peer.\n   * @param {number} [params.seqNumber] monotonically-increasing sequence counter that's used to order PeerRecords in time.\n   */\n  constructor ({ peerId, multiaddrs = [], seqNumber = Date.now() }) {\n    super(ENVELOPE_DOMAIN_PEER_RECORD, ENVELOPE_PAYLOAD_TYPE_PEER_RECORD)\n\n    this.peerId = peerId\n    this.multiaddrs = multiaddrs\n    this.seqNumber = seqNumber\n\n    // Cache\n    this._marshal = undefined\n  }\n\n  /**\n   * Marshal a record to be used in an envelope.\n   * @return {Uint8Array}\n   */\n  marshal () {\n    if (this._marshal) {\n      return this._marshal\n    }\n\n    this._marshal = Protobuf.encode({\n      peer_id: this.peerId.toBytes(),\n      seq: this.seqNumber,\n      addresses: this.multiaddrs.map((m) => ({\n        multiaddr: m.bytes\n      }))\n    })\n\n    return this._marshal\n  }\n\n  /**\n   * Returns true if `this` record equals the `other`.\n   * @param {Record} other\n   * @return {boolean}\n   */\n  equals (other) {\n    // Validate PeerId\n    if (!this.peerId.equals(other.peerId)) {\n      return false\n    }\n\n    // Validate seqNumber\n    if (this.seqNumber !== other.seqNumber) {\n      return false\n    }\n\n    // Validate multiaddrs\n    if (!arrayEquals(this.multiaddrs, other.multiaddrs)) {\n      return false\n    }\n\n    return true\n  }\n}\n\n/**\n * Unmarshal Peer Record Protobuf.\n * @param {Uint8Array} buf marshaled peer record.\n * @return {PeerRecord}\n */\nPeerRecord.createFromProtobuf = (buf) => {\n  // Decode\n  const peerRecord = Protobuf.decode(buf)\n\n  const peerId = PeerId.createFromBytes(peerRecord.peer_id)\n  const multiaddrs = (peerRecord.addresses || []).map((a) => multiaddr(a.multiaddr))\n  const seqNumber = peerRecord.seq\n\n  return new PeerRecord({ peerId, multiaddrs, seqNumber })\n}\n\nPeerRecord.DOMAIN = ENVELOPE_DOMAIN_PEER_RECORD\n\nmodule.exports = PeerRecord\n"]},"metadata":{},"sourceType":"script"}