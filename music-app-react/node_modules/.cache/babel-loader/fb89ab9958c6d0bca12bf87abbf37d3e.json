{"ast":null,"code":"'use strict';\n\nconst Store = require('orbit-db-store');\n\nconst EventIndex = require('./EventIndex'); // TODO: generalize the Iterator functions and spin to its own module\n\n\nclass EventStore extends Store {\n  constructor(ipfs, id, dbname, options = {}) {\n    if (options.Index === undefined) Object.assign(options, {\n      Index: EventIndex\n    });\n    super(ipfs, id, dbname, options);\n    this._type = 'eventlog';\n    this.events.on(\"log.op.ADD\", (address, hash, payload) => {\n      this.events.emit(\"db.append\", payload.value);\n    });\n  }\n\n  add(data, options = {}) {\n    return this._addOperation({\n      op: 'ADD',\n      key: null,\n      value: data\n    }, options);\n  }\n\n  get(hash) {\n    return this.iterator({\n      gte: hash,\n      limit: 1\n    }).collect()[0];\n  }\n\n  iterator(options) {\n    const messages = this._query(options);\n\n    let currentIndex = 0;\n    let iterator = {\n      [Symbol.iterator]() {\n        return this;\n      },\n\n      next() {\n        let item = {\n          value: null,\n          done: true\n        };\n\n        if (currentIndex < messages.length) {\n          item = {\n            value: messages[currentIndex],\n            done: false\n          };\n          currentIndex++;\n        }\n\n        return item;\n      },\n\n      collect: () => messages\n    };\n    return iterator;\n  }\n\n  _query(opts) {\n    if (!opts) opts = {};\n    const amount = opts.limit ? opts.limit > -1 ? opts.limit : this._index.get().length : 1; // Return 1 if no limit is provided\n\n    const events = this._index.get().slice();\n\n    let result = [];\n\n    if (opts.gt || opts.gte) {\n      // Greater than case\n      result = this._read(events, opts.gt ? opts.gt : opts.gte, amount, !!opts.gte);\n    } else {\n      // Lower than and lastN case, search latest first by reversing the sequence\n      result = this._read(events.reverse(), opts.lt ? opts.lt : opts.lte, amount, opts.lte || !opts.lt).reverse();\n    }\n\n    if (opts.reverse) {\n      result.reverse();\n    }\n\n    return result;\n  }\n\n  _read(ops, hash, amount, inclusive) {\n    // Find the index of the gt/lt hash, or start from the beginning of the array if not found\n    const index = ops.map(e => e.hash).indexOf(hash);\n    let startIndex = Math.max(index, 0); // If gte/lte is set, we include the given hash, if not, start from the next element\n\n    startIndex += inclusive ? 0 : 1; // Slice the array to its requested size\n\n    const res = ops.slice(startIndex).slice(0, amount);\n    return res;\n  }\n\n}\n\nmodule.exports = EventStore;","map":{"version":3,"sources":["/home/user/orbit-playground/music-app-react/node_modules/orbit-db-eventstore/src/EventStore.js"],"names":["Store","require","EventIndex","EventStore","constructor","ipfs","id","dbname","options","Index","undefined","Object","assign","_type","events","on","address","hash","payload","emit","value","add","data","_addOperation","op","key","get","iterator","gte","limit","collect","messages","_query","currentIndex","Symbol","next","item","done","length","opts","amount","_index","slice","result","gt","_read","reverse","lt","lte","ops","inclusive","index","map","e","indexOf","startIndex","Math","max","res","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst Store = require('orbit-db-store')\nconst EventIndex = require('./EventIndex')\n\n// TODO: generalize the Iterator functions and spin to its own module\n\nclass EventStore extends Store {\n  constructor (ipfs, id, dbname, options = {}) {\n    if (options.Index === undefined) Object.assign(options, { Index: EventIndex })\n    super(ipfs, id, dbname, options)\n    this._type = 'eventlog';\n    this.events.on(\"log.op.ADD\", (address, hash, payload) => {\n      this.events.emit(\"db.append\", payload.value)\n    })\n  }\n\n  add (data, options = {}) {\n    return this._addOperation({\n      op: 'ADD',\n      key: null,\n      value: data\n    }, options)\n  }\n\n  get (hash) {\n    return this.iterator({ gte: hash, limit: 1 }).collect()[0]\n  }\n  iterator (options) {\n    const messages = this._query(options)\n    let currentIndex = 0\n    let iterator = {\n      [Symbol.iterator] () {\n        return this\n      },\n      next () {\n        let item = { value: null, done: true }\n        if (currentIndex < messages.length) {\n          item = { value: messages[currentIndex], done: false }\n          currentIndex++\n        }\n        return item\n      },\n      collect: () => messages\n    }\n\n    return iterator\n  }\n\n  _query (opts) {\n    if (!opts) opts = {}\n\n    const amount = opts.limit ? (opts.limit > -1 ? opts.limit : this._index.get().length) : 1 // Return 1 if no limit is provided\n    const events = this._index.get().slice()\n    let result = []\n\n    if (opts.gt || opts.gte) {\n      // Greater than case\n      result = this._read(events, opts.gt ? opts.gt : opts.gte, amount, !!opts.gte)\n    } else {\n      // Lower than and lastN case, search latest first by reversing the sequence\n      result = this._read(events.reverse(), opts.lt ? opts.lt : opts.lte, amount, opts.lte || !opts.lt).reverse()\n    }\n    \n    if (opts.reverse) {\n      result.reverse()\n    }\n\n    return result\n  }\n\n  _read (ops, hash, amount, inclusive) {\n    // Find the index of the gt/lt hash, or start from the beginning of the array if not found\n    const index = ops.map((e) => e.hash).indexOf(hash)\n    let startIndex = Math.max(index, 0)\n    // If gte/lte is set, we include the given hash, if not, start from the next element\n    startIndex += inclusive ? 0 : 1\n    // Slice the array to its requested size\n    const res = ops.slice(startIndex).slice(0, amount)\n    return res\n  }\n}\n\nmodule.exports = EventStore\n"]},"metadata":{},"sourceType":"script"}