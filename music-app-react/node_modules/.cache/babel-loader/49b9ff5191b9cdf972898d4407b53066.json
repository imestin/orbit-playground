{"ast":null,"code":"const EventEmitter = require('events').EventEmitter;\n\nconst pMap = require('p-map');\n\nconst Log = require('ipfs-log');\n\nconst Logger = require('logplease');\n\nconst logger = Logger.create('replicator', {\n  color: Logger.Colors.Cyan\n});\nLogger.setLogLevel('ERROR');\n\nconst getNext = e => e.next;\n\nconst flatMap = (res, val) => res.concat(val);\n\nconst notNull = entry => entry !== null && entry !== undefined;\n\nconst uniqueValues = (res, val) => {\n  res[val] = val;\n  return res;\n};\n\nconst batchSize = 1;\n\nclass Replicator extends EventEmitter {\n  constructor(store, concurrency) {\n    super();\n    this._store = store;\n    this._fetching = {};\n    this._stats = {\n      tasksRequested: 0,\n      tasksStarted: 0,\n      tasksProcessed: 0\n    };\n    this._buffer = [];\n    this._concurrency = concurrency || 128;\n    this._queue = {};\n    this._q = new Set(); // Flush the queue as an emergency switch\n\n    this._flushTimer = setInterval(() => {\n      if (this.tasksRunning === 0 && Object.keys(this._queue).length > 0) {\n        logger.warn('Had to flush the queue!', Object.keys(this._queue).length, 'items in the queue, ', this.tasksRequested, this.tasksFinished, ' tasks requested/finished');\n        setTimeout(() => this._processQueue(), 0);\n      }\n    }, 3000);\n  }\n  /**\n   * Returns the number of tasks started during the life time\n   * @return {[Integer]} [Number of tasks started]\n   */\n\n\n  get tasksRequested() {\n    return this._stats.tasksRequested;\n  }\n  /**\n   * Returns the number of tasks started during the life time\n   * @return {[Integer]} [Number of tasks running]\n   */\n\n\n  get tasksStarted() {\n    return this._stats.tasksStarted;\n  }\n  /**\n   * Returns the number of tasks running currently\n   * @return {[Integer]} [Number of tasks running]\n   */\n\n\n  get tasksRunning() {\n    return this._stats.tasksStarted - this._stats.tasksProcessed;\n  }\n  /**\n   * Returns the number of tasks currently queued\n   * @return {[Integer]} [Number of tasks queued]\n   */\n\n\n  get tasksQueued() {\n    return Math.max(Object.keys(this._queue).length - this.tasksRunning, 0);\n  }\n  /**\n   * Returns the number of tasks finished during the life time\n   * @return {[Integer]} [Number of tasks finished]\n   */\n\n\n  get tasksFinished() {\n    return this._stats.tasksProcessed;\n  }\n  /**\n   * Returns the hashes currently queued\n   * @return {[Array<String>]} [Queued hashes]\n   */\n\n\n  getQueue() {\n    return Object.values(this._queue);\n  }\n  /*\n    Process new heads.\n   */\n\n\n  load(entries) {\n    const notKnown = entry => {\n      const hash = entry.hash || entry;\n      return !this._store._oplog.has(hash) && !this._fetching[hash] && !this._queue[hash];\n    };\n\n    try {\n      entries.filter(notNull).filter(notKnown).forEach(this._addToQueue.bind(this));\n      setTimeout(() => this._processQueue(), 0);\n    } catch (e) {\n      console.error(e);\n    }\n  }\n\n  stop() {\n    // Clears the queue flusher\n    clearInterval(this._flushTimer); // Remove event listeners\n\n    this.removeAllListeners('load.added');\n    this.removeAllListeners('load.end');\n    this.removeAllListeners('load.progress');\n  }\n\n  _addToQueue(entry) {\n    const hash = entry.hash || entry;\n    this._stats.tasksRequested += 1;\n    this._queue[hash] = entry;\n  }\n\n  async _processQueue() {\n    if (this.tasksRunning < this._concurrency) {\n      const capacity = this._concurrency - this.tasksRunning;\n      const items = Object.values(this._queue).slice(0, capacity).filter(notNull);\n      items.forEach(entry => delete this._queue[entry.hash || entry]);\n\n      const flattenAndGetUniques = nexts => nexts.reduce(flatMap, []).reduce(uniqueValues, {});\n\n      const processValues = nexts => {\n        const values = Object.values(nexts).filter(notNull);\n\n        if (items.length > 0 && this._buffer.length > 0 || this.tasksRunning === 0 && this._buffer.length > 0) {\n          const logs = this._buffer.slice();\n\n          this._buffer = [];\n          this.emit('load.end', logs);\n        }\n\n        if (values.length > 0) {\n          this.load(values);\n        }\n      };\n\n      return pMap(items, e => this._processOne(e)).then(flattenAndGetUniques).then(processValues);\n    }\n  }\n\n  async _processOne(entry) {\n    const hash = entry.hash || entry;\n\n    if (this._store._oplog.has(hash) || this._fetching[hash]) {\n      return;\n    }\n\n    this._fetching[hash] = hash;\n    this.emit('load.added', entry);\n    this._stats.tasksStarted += 1;\n    const exclude = []; // console.log('>', hash)\n\n    const log = await Log.fromEntryHash(this._store._ipfs, this._store.identity, hash, {\n      logId: this._store._oplog.id,\n      access: this._store.access,\n      length: batchSize,\n      exclude\n    });\n\n    this._buffer.push(log);\n\n    const latest = log.values[0];\n    delete this._queue[hash]; // console.log('>>', latest.payload)\n    // Mark this task as processed\n\n    this._stats.tasksProcessed += 1; // Notify subscribers that we made progress\n\n    this.emit('load.progress', this._id, hash, latest, null, this._buffer.length); // Return all next pointers\n\n    return log.values.map(getNext).reduce(flatMap, []);\n  }\n\n}\n\nmodule.exports = Replicator;","map":{"version":3,"sources":["/home/user/orbit-playground/music-app/node_modules/orbit-db-store/src/Replicator.js"],"names":["EventEmitter","require","pMap","Log","Logger","logger","create","color","Colors","Cyan","setLogLevel","getNext","e","next","flatMap","res","val","concat","notNull","entry","undefined","uniqueValues","batchSize","Replicator","constructor","store","concurrency","_store","_fetching","_stats","tasksRequested","tasksStarted","tasksProcessed","_buffer","_concurrency","_queue","_q","Set","_flushTimer","setInterval","tasksRunning","Object","keys","length","warn","tasksFinished","setTimeout","_processQueue","tasksQueued","Math","max","getQueue","values","load","entries","notKnown","hash","_oplog","has","filter","forEach","_addToQueue","bind","console","error","stop","clearInterval","removeAllListeners","capacity","items","slice","flattenAndGetUniques","nexts","reduce","processValues","logs","emit","_processOne","then","exclude","log","fromEntryHash","_ipfs","identity","logId","id","access","push","latest","_id","map","module","exports"],"mappings":"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","sourcesContent":["const EventEmitter = require('events').EventEmitter\nconst pMap = require('p-map')\nconst Log = require('ipfs-log')\n\nconst Logger = require('logplease')\nconst logger = Logger.create('replicator', { color: Logger.Colors.Cyan })\nLogger.setLogLevel('ERROR')\n\nconst getNext = e => e.next\nconst flatMap = (res, val) => res.concat(val)\nconst notNull = entry => entry !== null && entry !== undefined\nconst uniqueValues = (res, val) => {\n  res[val] = val\n  return res\n}\n\nconst batchSize = 1\n\nclass Replicator extends EventEmitter {\n  constructor (store, concurrency) {\n    super()\n    this._store = store\n    this._fetching = {}\n    this._stats = {\n      tasksRequested: 0,\n      tasksStarted: 0,\n      tasksProcessed: 0\n    }\n    this._buffer = []\n\n    this._concurrency = concurrency || 128\n    this._queue = {}\n    this._q = new Set()\n\n    // Flush the queue as an emergency switch\n    this._flushTimer = setInterval(() => {\n      if (this.tasksRunning === 0 && Object.keys(this._queue).length > 0) {\n        logger.warn('Had to flush the queue!', Object.keys(this._queue).length, 'items in the queue, ', this.tasksRequested, this.tasksFinished, ' tasks requested/finished')\n        setTimeout(() => this._processQueue(), 0)\n      }\n    }, 3000)\n  }\n\n  /**\n   * Returns the number of tasks started during the life time\n   * @return {[Integer]} [Number of tasks started]\n   */\n  get tasksRequested () {\n    return this._stats.tasksRequested\n  }\n\n  /**\n   * Returns the number of tasks started during the life time\n   * @return {[Integer]} [Number of tasks running]\n   */\n  get tasksStarted () {\n    return this._stats.tasksStarted\n  }\n\n  /**\n   * Returns the number of tasks running currently\n   * @return {[Integer]} [Number of tasks running]\n   */\n  get tasksRunning () {\n    return this._stats.tasksStarted - this._stats.tasksProcessed\n  }\n\n  /**\n   * Returns the number of tasks currently queued\n   * @return {[Integer]} [Number of tasks queued]\n   */\n  get tasksQueued () {\n    return Math.max(Object.keys(this._queue).length - this.tasksRunning, 0)\n  }\n\n  /**\n   * Returns the number of tasks finished during the life time\n   * @return {[Integer]} [Number of tasks finished]\n   */\n  get tasksFinished () {\n    return this._stats.tasksProcessed\n  }\n\n  /**\n   * Returns the hashes currently queued\n   * @return {[Array<String>]} [Queued hashes]\n   */\n  getQueue () {\n    return Object.values(this._queue)\n  }\n\n  /*\n    Process new heads.\n   */\n  load (entries) {\n    const notKnown = entry => {\n      const hash = entry.hash || entry\n      return !this._store._oplog.has(hash) && !this._fetching[hash] && !this._queue[hash]\n    }\n\n    try {\n      entries\n        .filter(notNull)\n        .filter(notKnown)\n        .forEach(this._addToQueue.bind(this))\n\n      setTimeout(() => this._processQueue(), 0)\n    } catch (e) {\n      console.error(e)\n    }\n  }\n\n  stop () {\n    // Clears the queue flusher\n    clearInterval(this._flushTimer)\n    // Remove event listeners\n    this.removeAllListeners('load.added')\n    this.removeAllListeners('load.end')\n    this.removeAllListeners('load.progress')\n  }\n\n  _addToQueue (entry) {\n    const hash = entry.hash || entry\n    this._stats.tasksRequested += 1\n    this._queue[hash] = entry\n  }\n\n  async _processQueue () {\n    if (this.tasksRunning < this._concurrency) {\n      const capacity = this._concurrency - this.tasksRunning\n      const items = Object.values(this._queue).slice(0, capacity).filter(notNull)\n      items.forEach(entry => delete this._queue[entry.hash || entry])\n\n      const flattenAndGetUniques = (nexts) => nexts.reduce(flatMap, []).reduce(uniqueValues, {})\n      const processValues = (nexts) => {\n        const values = Object.values(nexts).filter(notNull)\n\n        if ((items.length > 0 && this._buffer.length > 0) ||\n        (this.tasksRunning === 0 && this._buffer.length > 0)) {\n          const logs = this._buffer.slice()\n          this._buffer = []\n          this.emit('load.end', logs)\n        }\n\n        if (values.length > 0) {\n          this.load(values)\n        }\n      }\n\n      return pMap(items, e => this._processOne(e))\n        .then(flattenAndGetUniques)\n        .then(processValues)\n    }\n  }\n\n  async _processOne (entry) {\n    const hash = entry.hash || entry\n\n    if (this._store._oplog.has(hash) || this._fetching[hash]) {\n      return\n    }\n\n    this._fetching[hash] = hash\n    this.emit('load.added', entry)\n    this._stats.tasksStarted += 1\n\n    const exclude = []\n    // console.log('>', hash)\n    const log = await Log.fromEntryHash(this._store._ipfs, this._store.identity, hash, { logId: this._store._oplog.id, access: this._store.access, length: batchSize, exclude })\n    this._buffer.push(log)\n\n    const latest = log.values[0]\n    delete this._queue[hash]\n    // console.log('>>', latest.payload)\n\n    // Mark this task as processed\n    this._stats.tasksProcessed += 1\n\n    // Notify subscribers that we made progress\n    this.emit('load.progress', this._id, hash, latest, null, this._buffer.length)\n\n    // Return all next pointers\n    return log.values.map(getNext).reduce(flatMap, [])\n  }\n}\n\nmodule.exports = Replicator\n"]},"metadata":{},"sourceType":"script"}