{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MessageDeliveries = exports.DeliveryRecordStatus = void 0;\n\nconst constants_1 = require(\"../constants\");\n\nconst denque_1 = __importDefault(require(\"denque\"));\n\nvar DeliveryRecordStatus;\n\n(function (DeliveryRecordStatus) {\n  /**\n   * we don't know (yet) if the message is valid\n   */\n  DeliveryRecordStatus[DeliveryRecordStatus[\"unknown\"] = 0] = \"unknown\";\n  /**\n   * we know the message is valid\n   */\n\n  DeliveryRecordStatus[DeliveryRecordStatus[\"valid\"] = 1] = \"valid\";\n  /**\n   * we know the message is invalid\n   */\n\n  DeliveryRecordStatus[DeliveryRecordStatus[\"invalid\"] = 2] = \"invalid\";\n  /**\n   * we were instructed by the validator to ignore the message\n   */\n\n  DeliveryRecordStatus[DeliveryRecordStatus[\"ignored\"] = 3] = \"ignored\";\n})(DeliveryRecordStatus = exports.DeliveryRecordStatus || (exports.DeliveryRecordStatus = {}));\n/**\n * Map of message ID to DeliveryRecord\n *\n * Maintains an internal queue for efficient gc of old messages\n */\n\n\nclass MessageDeliveries {\n  constructor() {\n    this.records = new Map();\n    this.queue = new denque_1.default();\n  }\n\n  ensureRecord(msgId) {\n    let drec = this.records.get(msgId);\n\n    if (drec) {\n      return drec;\n    } // record doesn't exist yet\n    // create record\n\n\n    drec = {\n      status: DeliveryRecordStatus.unknown,\n      firstSeen: Date.now(),\n      validated: 0,\n      peers: new Set()\n    };\n    this.records.set(msgId, drec); // and add msgId to the queue\n\n    const entry = {\n      msgId,\n      expire: Date.now() + constants_1.TimeCacheDuration\n    };\n    this.queue.push(entry);\n    return drec;\n  }\n\n  gc() {\n    const now = Date.now(); // queue is sorted by expiry time\n    // remove expired messages, remove from queue until first un-expired message found\n\n    let head = this.queue.peekFront();\n\n    while (head && head.expire < now) {\n      this.records.delete(head.msgId);\n      this.queue.shift();\n      head = this.queue.peekFront();\n    }\n  }\n\n  clear() {\n    this.records.clear();\n    this.queue.clear();\n  }\n\n}\n\nexports.MessageDeliveries = MessageDeliveries;","map":{"version":3,"sources":["/home/user/orbit-playground/music-app/node_modules/libp2p-gossipsub/src/score/message-deliveries.js"],"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","MessageDeliveries","DeliveryRecordStatus","constants_1","require","denque_1","constructor","records","Map","queue","default","ensureRecord","msgId","drec","get","status","unknown","firstSeen","Date","now","validated","peers","Set","set","entry","expire","TimeCacheDuration","push","gc","head","peekFront","delete","shift","clear"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MessageDeliveries = exports.DeliveryRecordStatus = void 0;\nconst constants_1 = require(\"../constants\");\nconst denque_1 = __importDefault(require(\"denque\"));\nvar DeliveryRecordStatus;\n(function (DeliveryRecordStatus) {\n    /**\n     * we don't know (yet) if the message is valid\n     */\n    DeliveryRecordStatus[DeliveryRecordStatus[\"unknown\"] = 0] = \"unknown\";\n    /**\n     * we know the message is valid\n     */\n    DeliveryRecordStatus[DeliveryRecordStatus[\"valid\"] = 1] = \"valid\";\n    /**\n     * we know the message is invalid\n     */\n    DeliveryRecordStatus[DeliveryRecordStatus[\"invalid\"] = 2] = \"invalid\";\n    /**\n     * we were instructed by the validator to ignore the message\n     */\n    DeliveryRecordStatus[DeliveryRecordStatus[\"ignored\"] = 3] = \"ignored\";\n})(DeliveryRecordStatus = exports.DeliveryRecordStatus || (exports.DeliveryRecordStatus = {}));\n/**\n * Map of message ID to DeliveryRecord\n *\n * Maintains an internal queue for efficient gc of old messages\n */\nclass MessageDeliveries {\n    constructor() {\n        this.records = new Map();\n        this.queue = new denque_1.default();\n    }\n    ensureRecord(msgId) {\n        let drec = this.records.get(msgId);\n        if (drec) {\n            return drec;\n        }\n        // record doesn't exist yet\n        // create record\n        drec = {\n            status: DeliveryRecordStatus.unknown,\n            firstSeen: Date.now(),\n            validated: 0,\n            peers: new Set()\n        };\n        this.records.set(msgId, drec);\n        // and add msgId to the queue\n        const entry = {\n            msgId,\n            expire: Date.now() + constants_1.TimeCacheDuration\n        };\n        this.queue.push(entry);\n        return drec;\n    }\n    gc() {\n        const now = Date.now();\n        // queue is sorted by expiry time\n        // remove expired messages, remove from queue until first un-expired message found\n        let head = this.queue.peekFront();\n        while (head && head.expire < now) {\n            this.records.delete(head.msgId);\n            this.queue.shift();\n            head = this.queue.peekFront();\n        }\n    }\n    clear() {\n        this.records.clear();\n        this.queue.clear();\n    }\n}\nexports.MessageDeliveries = MessageDeliveries;\n"]},"metadata":{},"sourceType":"script"}