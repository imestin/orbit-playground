{"ast":null,"code":"'use strict';\n\nconst path = require('path');\n\nconst EventEmitter = require('events').EventEmitter;\n\nconst mapSeries = require('p-each-series');\n\nconst {\n  default: PQueue\n} = require('p-queue');\n\nconst Log = require('ipfs-log');\n\nconst Entry = Log.Entry;\n\nconst Index = require('./Index');\n\nconst Replicator = require('./Replicator');\n\nconst ReplicationInfo = require('./replication-info');\n\nconst Logger = require('logplease');\n\nconst logger = Logger.create('orbit-db.store', {\n  color: Logger.Colors.Blue\n});\nLogger.setLogLevel('ERROR');\n\nconst io = require('orbit-db-io');\n\nconst DefaultOptions = {\n  Index: Index,\n  maxHistory: -1,\n  fetchEntryTimeout: null,\n  referenceCount: 32,\n  replicationConcurrency: 128,\n  syncLocal: false,\n  sortFn: undefined\n};\n\nclass Store {\n  constructor(ipfs, identity, address, options) {\n    if (!identity) {\n      throw new Error('Identity required');\n    } // Set the options\n\n\n    const opts = Object.assign({}, DefaultOptions);\n    Object.assign(opts, options);\n    this.options = opts; // Default type\n\n    this._type = 'store'; // Create IDs, names and paths\n\n    this.id = address.toString();\n    this.identity = identity;\n    this.address = address;\n    this.dbname = address.path || '';\n    this.events = new EventEmitter();\n    this.remoteHeadsPath = path.join(this.id, '_remoteHeads');\n    this.localHeadsPath = path.join(this.id, '_localHeads');\n    this.snapshotPath = path.join(this.id, 'snapshot');\n    this.queuePath = path.join(this.id, 'queue');\n    this.manifestPath = path.join(this.id, '_manifest'); // External dependencies\n\n    this._ipfs = ipfs;\n    this._cache = options.cache; // Access mapping\n\n    const defaultAccess = {\n      canAppend: entry => entry.identity.publicKey === identity.publicKey\n    };\n    this.access = options.accessController || defaultAccess; // Create the operations log\n\n    this._oplog = new Log(this._ipfs, this.identity, {\n      logId: this.id,\n      access: this.access,\n      sortFn: this.options.sortFn\n    }); // _addOperation queue\n\n    this._opqueue = new PQueue({\n      concurrency: 1\n    }); // Create the index\n\n    this._index = new this.options.Index(this.address.root); // Replication progress info\n\n    this._replicationStatus = new ReplicationInfo(); // Statistics\n\n    this._stats = {\n      snapshot: {\n        bytesLoaded: -1\n      },\n      syncRequestsReceieved: 0\n    };\n\n    try {\n      this._replicator = new Replicator(this, this.options.replicationConcurrency); // For internal backwards compatibility,\n      // to be removed in future releases\n\n      this._loader = this._replicator;\n\n      this._replicator.on('load.added', entry => {\n        // Update the latest entry state (latest is the entry with largest clock time)\n        this._replicationStatus.queued++;\n\n        this._recalculateReplicationMax(entry.clock ? entry.clock.time : 0); // logger.debug(`<replicate>`)\n\n\n        this.events.emit('replicate', this.address.toString(), entry);\n      });\n\n      this._replicator.on('load.progress', (id, hash, entry, have, bufferedLength) => {\n        if (this._replicationStatus.buffered > bufferedLength) {\n          this._recalculateReplicationProgress(this.replicationStatus.progress + bufferedLength);\n        } else {\n          this._recalculateReplicationProgress(this._oplog.length + bufferedLength);\n        }\n\n        this._replicationStatus.buffered = bufferedLength;\n\n        this._recalculateReplicationMax(this.replicationStatus.progress); // logger.debug(`<replicate.progress>`)\n\n\n        this.events.emit('replicate.progress', this.address.toString(), hash, entry, this.replicationStatus.progress, this.replicationStatus.max);\n      });\n\n      const onLoadCompleted = async (logs, have) => {\n        try {\n          for (const log of logs) {\n            await this._oplog.join(log);\n          }\n\n          this._replicationStatus.queued -= logs.length;\n          this._replicationStatus.buffered = this._replicator._buffer.length;\n          await this._updateIndex(); // only store heads that has been verified and merges\n\n          const heads = this._oplog.heads;\n          await this._cache.set(this.remoteHeadsPath, heads);\n          logger.debug(`Saved heads ${heads.length} [${heads.map(e => e.hash).join(', ')}]`); // logger.debug(`<replicated>`)\n\n          this.events.emit('replicated', this.address.toString(), logs.length);\n        } catch (e) {\n          console.error(e);\n        }\n      };\n\n      this._replicator.on('load.end', onLoadCompleted);\n    } catch (e) {\n      console.error('Store Error:', e);\n    }\n\n    this.events.on('replicated.progress', (address, hash, entry, progress, have) => {\n      this._procEntry(entry);\n    });\n    this.events.on('write', (address, entry, heads) => {\n      this._procEntry(entry);\n    });\n  }\n\n  get all() {\n    return Array.isArray(this._index._index) ? this._index._index : Object.keys(this._index._index).map(e => this._index._index[e]);\n  }\n\n  get index() {\n    return this._index._index;\n  }\n\n  get type() {\n    return this._type;\n  }\n\n  get key() {\n    return this._key;\n  }\n  /**\n   * Returns the database's current replication status information\n   * @return {[Object]} [description]\n   */\n\n\n  get replicationStatus() {\n    return this._replicationStatus;\n  }\n\n  setIdentity(identity) {\n    this.identity = identity;\n\n    this._oplog.setIdentity(identity);\n  }\n\n  async close() {\n    if (this.options.onClose) {\n      await this.options.onClose(this);\n    }\n\n    await this._opqueue.onIdle(); // Replicator teardown logic\n\n    this._replicator.stop(); // Reset replication statistics\n\n\n    this._replicationStatus.reset(); // Reset database statistics\n\n\n    this._stats = {\n      snapshot: {\n        bytesLoaded: -1\n      },\n      syncRequestsReceieved: 0\n    }; // Remove all event listeners\n\n    for (var event in this.events._events) {\n      this.events.removeAllListeners(event);\n    } // Database is now closed\n    // TODO: afaik we don't use 'closed' event anymore,\n    // to be removed in future releases\n\n\n    this.events.emit('closed', this.address.toString());\n    return Promise.resolve();\n  }\n  /**\n   * Drops a database and removes local data\n   * @return {[None]}\n   */\n\n\n  async drop() {\n    if (this.options.onDrop) {\n      await this.options.onDrop(this);\n    }\n\n    await this._cache.del(this.localHeadsPath);\n    await this._cache.del(this.remoteHeadsPath);\n    await this._cache.del(this.snapshotPath);\n    await this._cache.del(this.queuePath);\n    await this._cache.del(this.manifestPath);\n    await this.close(); // Reset\n\n    this._index = new this.options.Index(this.address.root);\n    this._oplog = new Log(this._ipfs, this.identity, {\n      logId: this.id,\n      access: this.access,\n      sortFn: this.options.sortFn\n    });\n    this._cache = this.options.cache;\n  }\n\n  async load(amount, opts = {}) {\n    if (typeof amount === 'object') {\n      opts = amount;\n      amount = undefined;\n    }\n\n    amount = amount || this.options.maxHistory;\n    const fetchEntryTimeout = opts.fetchEntryTimeout || this.options.fetchEntryTimeout;\n\n    if (this.options.onLoad) {\n      await this.options.onLoad(this);\n    }\n\n    const localHeads = (await this._cache.get(this.localHeadsPath)) || [];\n    const remoteHeads = (await this._cache.get(this.remoteHeadsPath)) || [];\n    const heads = localHeads.concat(remoteHeads);\n\n    if (heads.length > 0) {\n      this.events.emit('load', this.address.toString(), heads);\n    } // Update the replication status from the heads\n\n\n    heads.forEach(h => this._recalculateReplicationMax(h.clock.time)); // Load the log\n\n    const log = await Log.fromEntryHash(this._ipfs, this.identity, heads.map(e => e.hash), {\n      logId: this._oplog.id,\n      access: this.access,\n      sortFn: this.options.sortFn,\n      length: amount,\n      exclude: this._oplog.values,\n      onProgressCallback: this._onLoadProgress.bind(this),\n      timeout: fetchEntryTimeout\n    }); // Join the log with the existing log\n\n    await this._oplog.join(log, amount); // Update the index\n\n    if (heads.length > 0) {\n      await this._updateIndex();\n    }\n\n    this.events.emit('ready', this.address.toString(), this._oplog.heads);\n  }\n\n  async sync(heads) {\n    this._stats.syncRequestsReceieved += 1;\n    logger.debug(`Sync request #${this._stats.syncRequestsReceieved} ${heads.length}`);\n\n    if (heads.length === 0) {\n      return;\n    } // To simulate network latency, uncomment this line\n    // and comment out the rest of the function\n    // That way the object (received as head message from pubsub)\n    // doesn't get written to IPFS and so when the Replicator is fetching\n    // the log, it'll fetch it from the network instead from the disk.\n    // return this._replicator.load(heads)\n\n\n    const saveToIpfs = async head => {\n      if (!head) {\n        console.warn(\"Warning: Given input entry was 'null'.\");\n        return Promise.resolve(null);\n      }\n\n      const identityProvider = this.identity.provider;\n      if (!identityProvider) throw new Error('Identity-provider is required, cannot verify entry');\n      const canAppend = await this.access.canAppend(head, identityProvider);\n\n      if (!canAppend) {\n        console.warn('Warning: Given input entry is not allowed in this log and was discarded (no write access).');\n        return Promise.resolve(null);\n      }\n\n      const logEntry = Entry.toEntry(head);\n      const hash = await io.write(this._ipfs, Entry.getWriteFormat(logEntry), logEntry, {\n        links: Entry.IPLD_LINKS,\n        onlyHash: true\n      });\n\n      if (hash !== head.hash) {\n        console.warn('\"WARNING! Head hash didn\\'t match the contents');\n      }\n\n      return head;\n    };\n\n    const saved = await mapSeries(heads, saveToIpfs);\n    await this._replicator.load(saved.filter(e => e !== null));\n\n    if (this._replicator._buffer.length || Object.values(this._replicator._queue).length) {\n      return new Promise(resolve => {\n        const progressHandler = (address, hash, entry, progress, have) => {\n          if (progress === have) {\n            this.events.off('replicate.progress', progressHandler);\n            this.events.once('replicated', resolve);\n          }\n        };\n\n        this.events.on('replicate.progress', progressHandler);\n      });\n    }\n  }\n\n  loadMoreFrom(amount, entries) {\n    this._replicator.load(entries);\n  }\n\n  async saveSnapshot() {\n    const unfinished = this._replicator.getQueue();\n\n    const snapshotData = this._oplog.toSnapshot();\n\n    const buf = Buffer.from(JSON.stringify({\n      id: snapshotData.id,\n      heads: snapshotData.heads,\n      size: snapshotData.values.length,\n      values: snapshotData.values,\n      type: this.type\n    }));\n    const snapshot = await this._ipfs.add(buf);\n    snapshot.hash = snapshot.cid.toString(); // js-ipfs >= 0.41, ipfs.add results contain a cid property (a CID instance) instead of a string hash property\n\n    await this._cache.set(this.snapshotPath, snapshot);\n    await this._cache.set(this.queuePath, unfinished);\n    logger.debug(`Saved snapshot: ${snapshot.hash}, queue length: ${unfinished.length}`);\n    return [snapshot];\n  }\n\n  async loadFromSnapshot(onProgressCallback) {\n    if (this.options.onLoad) {\n      await this.options.onLoad(this);\n    }\n\n    this.events.emit('load', this.address.toString()); // TODO emits inconsistent params, missing heads param\n\n    const maxClock = (res, val) => Math.max(res, val.clock.time);\n\n    const queue = await this._cache.get(this.queuePath);\n    this.sync(queue || []);\n    const snapshot = await this._cache.get(this.snapshotPath);\n\n    if (snapshot) {\n      const chunks = [];\n\n      for await (const chunk of this._ipfs.cat(snapshot.hash)) {\n        chunks.push(chunk);\n      }\n\n      const buffer = Buffer.concat(chunks);\n      const snapshotData = JSON.parse(buffer.toString());\n\n      const onProgress = (hash, entry, count, total) => {\n        this._recalculateReplicationStatus(count, entry.clock.time);\n\n        this._onLoadProgress(hash, entry);\n      }; // Fetch the entries\n      // Timeout 1 sec to only load entries that are already fetched (in order to not get stuck at loading)\n\n\n      this._recalculateReplicationMax(snapshotData.values.reduce(maxClock, 0));\n\n      if (snapshotData) {\n        const log = await Log.fromJSON(this._ipfs, this.identity, snapshotData, {\n          access: this.access,\n          sortFn: this.options.sortFn,\n          length: -1,\n          timeout: 1000,\n          onProgressCallback: onProgress\n        });\n        await this._oplog.join(log);\n        await this._updateIndex();\n        this.events.emit('replicated', this.address.toString()); // TODO: inconsistent params, count param not emited\n      }\n\n      this.events.emit('ready', this.address.toString(), this._oplog.heads);\n    } else {\n      throw new Error(`Snapshot for ${this.address} not found!`);\n    }\n\n    return this;\n  }\n\n  async _updateIndex() {\n    this._recalculateReplicationMax();\n\n    await this._index.updateIndex(this._oplog);\n\n    this._recalculateReplicationProgress();\n  }\n\n  async syncLocal() {\n    const localHeads = (await this._cache.get(this.localHeadsPath)) || [];\n    const remoteHeads = (await this._cache.get(this.remoteHeadsPath)) || [];\n    const heads = localHeads.concat(remoteHeads);\n\n    for (let i = 0; i < heads.length; i++) {\n      const head = heads[i];\n\n      if (!this._oplog.heads.includes(head)) {\n        await this.load();\n        break;\n      }\n    }\n  }\n\n  async _addOperation(data, {\n    onProgressCallback,\n    pin = false\n  } = {}) {\n    async function addOperation() {\n      if (this._oplog) {\n        // check local cache?\n        if (this.options.syncLocal) {\n          await this.syncLocal();\n        }\n\n        const entry = await this._oplog.append(data, this.options.referenceCount, pin);\n\n        this._recalculateReplicationStatus(this.replicationStatus.progress + 1, entry.clock.time);\n\n        await this._cache.set(this.localHeadsPath, [entry]);\n        await this._updateIndex();\n        this.events.emit('write', this.address.toString(), entry, this._oplog.heads);\n        if (onProgressCallback) onProgressCallback(entry);\n        return entry.hash;\n      }\n    }\n\n    return this._opqueue.add(addOperation.bind(this));\n  }\n\n  _addOperationBatch(data, batchOperation, lastOperation, onProgressCallback) {\n    throw new Error('Not implemented!');\n  }\n\n  _procEntry(entry) {\n    var {\n      payload,\n      hash\n    } = entry;\n    var {\n      op\n    } = payload;\n\n    if (op) {\n      this.events.emit(`log.op.${op}`, this.address.toString(), hash, payload);\n    } else {\n      this.events.emit('log.op.none', this.address.toString(), hash, payload);\n    }\n\n    this.events.emit('log.op', op, this.address.toString(), hash, payload);\n  }\n\n  _onLoadProgress(hash, entry, progress, total) {\n    this._recalculateReplicationStatus(progress, total);\n\n    this.events.emit('load.progress', this.address.toString(), hash, entry, this.replicationStatus.progress, this.replicationStatus.max);\n  }\n  /* Replication Status state updates */\n\n\n  _recalculateReplicationProgress(max) {\n    this._replicationStatus.progress = Math.max.apply(null, [this._replicationStatus.progress, this._oplog.length, max || 0]);\n\n    this._recalculateReplicationMax(this.replicationStatus.progress);\n  }\n\n  _recalculateReplicationMax(max) {\n    this._replicationStatus.max = Math.max.apply(null, [this._replicationStatus.max, this._oplog.length, max || 0]);\n  }\n\n  _recalculateReplicationStatus(maxProgress, maxTotal) {\n    this._recalculateReplicationProgress(maxProgress);\n\n    this._recalculateReplicationMax(maxTotal);\n  }\n\n}\n\nmodule.exports = Store;\nmodule.exports.DefaultOptions = DefaultOptions;","map":{"version":3,"sources":["/home/user/orbit-playground/music-app/node_modules/orbit-db-store/src/Store.js"],"names":["path","require","EventEmitter","mapSeries","default","PQueue","Log","Entry","Index","Replicator","ReplicationInfo","Logger","logger","create","color","Colors","Blue","setLogLevel","io","DefaultOptions","maxHistory","fetchEntryTimeout","referenceCount","replicationConcurrency","syncLocal","sortFn","undefined","Store","constructor","ipfs","identity","address","options","Error","opts","Object","assign","_type","id","toString","dbname","events","remoteHeadsPath","join","localHeadsPath","snapshotPath","queuePath","manifestPath","_ipfs","_cache","cache","defaultAccess","canAppend","entry","publicKey","access","accessController","_oplog","logId","_opqueue","concurrency","_index","root","_replicationStatus","_stats","snapshot","bytesLoaded","syncRequestsReceieved","_replicator","_loader","on","queued","_recalculateReplicationMax","clock","time","emit","hash","have","bufferedLength","buffered","_recalculateReplicationProgress","replicationStatus","progress","length","max","onLoadCompleted","logs","log","_buffer","_updateIndex","heads","set","debug","map","e","console","error","_procEntry","all","Array","isArray","keys","index","type","key","_key","setIdentity","close","onClose","onIdle","stop","reset","event","_events","removeAllListeners","Promise","resolve","drop","onDrop","del","load","amount","onLoad","localHeads","get","remoteHeads","concat","forEach","h","fromEntryHash","exclude","values","onProgressCallback","_onLoadProgress","bind","timeout","sync","saveToIpfs","head","warn","identityProvider","provider","logEntry","toEntry","write","getWriteFormat","links","IPLD_LINKS","onlyHash","saved","filter","_queue","progressHandler","off","once","loadMoreFrom","entries","saveSnapshot","unfinished","getQueue","snapshotData","toSnapshot","buf","Buffer","from","JSON","stringify","size","add","cid","loadFromSnapshot","maxClock","res","val","Math","queue","chunks","chunk","cat","push","buffer","parse","onProgress","count","total","_recalculateReplicationStatus","reduce","fromJSON","updateIndex","i","includes","_addOperation","data","pin","addOperation","append","_addOperationBatch","batchOperation","lastOperation","payload","op","apply","maxProgress","maxTotal","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst path = require('path')\nconst EventEmitter = require('events').EventEmitter\nconst mapSeries = require('p-each-series')\nconst { default: PQueue } = require('p-queue')\nconst Log = require('ipfs-log')\nconst Entry = Log.Entry\nconst Index = require('./Index')\nconst Replicator = require('./Replicator')\nconst ReplicationInfo = require('./replication-info')\n\nconst Logger = require('logplease')\nconst logger = Logger.create('orbit-db.store', { color: Logger.Colors.Blue })\nLogger.setLogLevel('ERROR')\nconst io = require('orbit-db-io')\n\nconst DefaultOptions = {\n  Index: Index,\n  maxHistory: -1,\n  fetchEntryTimeout: null,\n  referenceCount: 32,\n  replicationConcurrency: 128,\n  syncLocal: false,\n  sortFn: undefined\n}\n\nclass Store {\n  constructor (ipfs, identity, address, options) {\n    if (!identity) {\n      throw new Error('Identity required')\n    }\n\n    // Set the options\n    const opts = Object.assign({}, DefaultOptions)\n    Object.assign(opts, options)\n    this.options = opts\n\n    // Default type\n    this._type = 'store'\n\n    // Create IDs, names and paths\n    this.id = address.toString()\n    this.identity = identity\n    this.address = address\n    this.dbname = address.path || ''\n    this.events = new EventEmitter()\n\n    this.remoteHeadsPath = path.join(this.id, '_remoteHeads')\n    this.localHeadsPath = path.join(this.id, '_localHeads')\n    this.snapshotPath = path.join(this.id, 'snapshot')\n    this.queuePath = path.join(this.id, 'queue')\n    this.manifestPath = path.join(this.id, '_manifest')\n\n    // External dependencies\n    this._ipfs = ipfs\n    this._cache = options.cache\n\n    // Access mapping\n    const defaultAccess = {\n      canAppend: (entry) => (entry.identity.publicKey === identity.publicKey)\n    }\n    this.access = options.accessController || defaultAccess\n\n    // Create the operations log\n    this._oplog = new Log(this._ipfs, this.identity, { logId: this.id, access: this.access, sortFn: this.options.sortFn })\n\n    // _addOperation queue\n    this._opqueue = new PQueue({ concurrency: 1 })\n\n    // Create the index\n    this._index = new this.options.Index(this.address.root)\n\n    // Replication progress info\n    this._replicationStatus = new ReplicationInfo()\n\n    // Statistics\n    this._stats = {\n      snapshot: {\n        bytesLoaded: -1\n      },\n      syncRequestsReceieved: 0\n    }\n\n    try {\n      this._replicator = new Replicator(this, this.options.replicationConcurrency)\n      // For internal backwards compatibility,\n      // to be removed in future releases\n      this._loader = this._replicator\n      this._replicator.on('load.added', (entry) => {\n        // Update the latest entry state (latest is the entry with largest clock time)\n        this._replicationStatus.queued++\n        this._recalculateReplicationMax(entry.clock ? entry.clock.time : 0)\n        // logger.debug(`<replicate>`)\n        this.events.emit('replicate', this.address.toString(), entry)\n      })\n      this._replicator.on('load.progress', (id, hash, entry, have, bufferedLength) => {\n        if (this._replicationStatus.buffered > bufferedLength) {\n          this._recalculateReplicationProgress(this.replicationStatus.progress + bufferedLength)\n        } else {\n          this._recalculateReplicationProgress(this._oplog.length + bufferedLength)\n        }\n        this._replicationStatus.buffered = bufferedLength\n        this._recalculateReplicationMax(this.replicationStatus.progress)\n        // logger.debug(`<replicate.progress>`)\n        this.events.emit('replicate.progress', this.address.toString(), hash, entry, this.replicationStatus.progress, this.replicationStatus.max)\n      })\n\n      const onLoadCompleted = async (logs, have) => {\n        try {\n          for (const log of logs) {\n            await this._oplog.join(log)\n          }\n          this._replicationStatus.queued -= logs.length\n          this._replicationStatus.buffered = this._replicator._buffer.length\n          await this._updateIndex()\n\n          // only store heads that has been verified and merges\n          const heads = this._oplog.heads\n          await this._cache.set(this.remoteHeadsPath, heads)\n          logger.debug(`Saved heads ${heads.length} [${heads.map(e => e.hash).join(', ')}]`)\n\n          // logger.debug(`<replicated>`)\n          this.events.emit('replicated', this.address.toString(), logs.length)\n        } catch (e) {\n          console.error(e)\n        }\n      }\n      this._replicator.on('load.end', onLoadCompleted)\n    } catch (e) {\n      console.error('Store Error:', e)\n    }\n    this.events.on('replicated.progress', (address, hash, entry, progress, have) => {\n      this._procEntry(entry)\n    })\n    this.events.on('write', (address, entry, heads) => {\n      this._procEntry(entry)\n    })\n  }\n\n  get all () {\n    return Array.isArray(this._index._index)\n      ? this._index._index\n      : Object.keys(this._index._index).map(e => this._index._index[e])\n  }\n\n  get index () {\n    return this._index._index\n  }\n\n  get type () {\n    return this._type\n  }\n\n  get key () {\n    return this._key\n  }\n\n  /**\n   * Returns the database's current replication status information\n   * @return {[Object]} [description]\n   */\n  get replicationStatus () {\n    return this._replicationStatus\n  }\n\n  setIdentity (identity) {\n    this.identity = identity\n    this._oplog.setIdentity(identity)\n  }\n\n  async close () {\n    if (this.options.onClose) {\n      await this.options.onClose(this)\n    }\n\n    await this._opqueue.onIdle()\n\n    // Replicator teardown logic\n    this._replicator.stop()\n\n    // Reset replication statistics\n    this._replicationStatus.reset()\n\n    // Reset database statistics\n    this._stats = {\n      snapshot: {\n        bytesLoaded: -1\n      },\n      syncRequestsReceieved: 0\n    }\n\n    // Remove all event listeners\n    for (var event in this.events._events) {\n      this.events.removeAllListeners(event)\n    }\n\n    // Database is now closed\n    // TODO: afaik we don't use 'closed' event anymore,\n    // to be removed in future releases\n    this.events.emit('closed', this.address.toString())\n    return Promise.resolve()\n  }\n\n  /**\n   * Drops a database and removes local data\n   * @return {[None]}\n   */\n  async drop () {\n    if (this.options.onDrop) {\n      await this.options.onDrop(this)\n    }\n\n    await this._cache.del(this.localHeadsPath)\n    await this._cache.del(this.remoteHeadsPath)\n    await this._cache.del(this.snapshotPath)\n    await this._cache.del(this.queuePath)\n    await this._cache.del(this.manifestPath)\n\n    await this.close()\n\n    // Reset\n    this._index = new this.options.Index(this.address.root)\n    this._oplog = new Log(this._ipfs, this.identity, { logId: this.id, access: this.access, sortFn: this.options.sortFn })\n    this._cache = this.options.cache\n  }\n\n  async load (amount, opts = {}) {\n    if (typeof amount === 'object') {\n      opts = amount\n      amount = undefined\n    }\n    amount = amount || this.options.maxHistory\n    const fetchEntryTimeout = opts.fetchEntryTimeout || this.options.fetchEntryTimeout\n\n    if (this.options.onLoad) {\n      await this.options.onLoad(this)\n    }\n    const localHeads = await this._cache.get(this.localHeadsPath) || []\n    const remoteHeads = await this._cache.get(this.remoteHeadsPath) || []\n    const heads = localHeads.concat(remoteHeads)\n\n    if (heads.length > 0) {\n      this.events.emit('load', this.address.toString(), heads)\n    }\n\n    // Update the replication status from the heads\n    heads.forEach(h => this._recalculateReplicationMax(h.clock.time))\n\n    // Load the log\n    const log = await Log.fromEntryHash(this._ipfs, this.identity, heads.map(e => e.hash), {\n      logId: this._oplog.id,\n      access: this.access,\n      sortFn: this.options.sortFn,\n      length: amount,\n      exclude: this._oplog.values,\n      onProgressCallback: this._onLoadProgress.bind(this),\n      timeout: fetchEntryTimeout\n    })\n\n    // Join the log with the existing log\n    await this._oplog.join(log, amount)\n\n    // Update the index\n    if (heads.length > 0) {\n      await this._updateIndex()\n    }\n\n    this.events.emit('ready', this.address.toString(), this._oplog.heads)\n  }\n\n  async sync (heads) {\n    this._stats.syncRequestsReceieved += 1\n    logger.debug(`Sync request #${this._stats.syncRequestsReceieved} ${heads.length}`)\n    if (heads.length === 0) {\n      return\n    }\n\n    // To simulate network latency, uncomment this line\n    // and comment out the rest of the function\n    // That way the object (received as head message from pubsub)\n    // doesn't get written to IPFS and so when the Replicator is fetching\n    // the log, it'll fetch it from the network instead from the disk.\n    // return this._replicator.load(heads)\n\n    const saveToIpfs = async (head) => {\n      if (!head) {\n        console.warn(\"Warning: Given input entry was 'null'.\")\n        return Promise.resolve(null)\n      }\n\n      const identityProvider = this.identity.provider\n      if (!identityProvider) throw new Error('Identity-provider is required, cannot verify entry')\n\n      const canAppend = await this.access.canAppend(head, identityProvider)\n      if (!canAppend) {\n        console.warn('Warning: Given input entry is not allowed in this log and was discarded (no write access).')\n        return Promise.resolve(null)\n      }\n\n      const logEntry = Entry.toEntry(head)\n      const hash = await io.write(this._ipfs, Entry.getWriteFormat(logEntry), logEntry, { links: Entry.IPLD_LINKS, onlyHash: true })\n\n      if (hash !== head.hash) {\n        console.warn('\"WARNING! Head hash didn\\'t match the contents')\n      }\n\n      return head\n    }\n\n    const saved = await mapSeries(heads, saveToIpfs)\n    await this._replicator.load(saved.filter(e => e !== null))\n\n    if (this._replicator._buffer.length || Object.values(this._replicator._queue).length) {\n      return new Promise(resolve => {\n        const progressHandler = (address, hash, entry, progress, have) => {\n          if (progress === have) {\n            this.events.off('replicate.progress', progressHandler)\n            this.events.once('replicated', resolve)\n          }\n        }\n        this.events.on('replicate.progress', progressHandler)\n      })\n    }\n  }\n\n  loadMoreFrom (amount, entries) {\n    this._replicator.load(entries)\n  }\n\n  async saveSnapshot () {\n    const unfinished = this._replicator.getQueue()\n\n    const snapshotData = this._oplog.toSnapshot()\n    const buf = Buffer.from(JSON.stringify({\n      id: snapshotData.id,\n      heads: snapshotData.heads,\n      size: snapshotData.values.length,\n      values: snapshotData.values,\n      type: this.type\n    }))\n\n    const snapshot = await this._ipfs.add(buf)\n\n    snapshot.hash = snapshot.cid.toString() // js-ipfs >= 0.41, ipfs.add results contain a cid property (a CID instance) instead of a string hash property\n    await this._cache.set(this.snapshotPath, snapshot)\n    await this._cache.set(this.queuePath, unfinished)\n\n    logger.debug(`Saved snapshot: ${snapshot.hash}, queue length: ${unfinished.length}`)\n\n    return [snapshot]\n  }\n\n  async loadFromSnapshot (onProgressCallback) {\n    if (this.options.onLoad) {\n      await this.options.onLoad(this)\n    }\n\n    this.events.emit('load', this.address.toString()) // TODO emits inconsistent params, missing heads param\n\n    const maxClock = (res, val) => Math.max(res, val.clock.time)\n\n    const queue = await this._cache.get(this.queuePath)\n    this.sync(queue || [])\n\n    const snapshot = await this._cache.get(this.snapshotPath)\n\n    if (snapshot) {\n      const chunks = []\n      for await (const chunk of this._ipfs.cat(snapshot.hash)) {\n        chunks.push(chunk)\n      }\n      const buffer = Buffer.concat(chunks)\n      const snapshotData = JSON.parse(buffer.toString())\n\n      const onProgress = (hash, entry, count, total) => {\n        this._recalculateReplicationStatus(count, entry.clock.time)\n        this._onLoadProgress(hash, entry)\n      }\n\n      // Fetch the entries\n      // Timeout 1 sec to only load entries that are already fetched (in order to not get stuck at loading)\n      this._recalculateReplicationMax(snapshotData.values.reduce(maxClock, 0))\n      if (snapshotData) {\n        const log = await Log.fromJSON(this._ipfs, this.identity, snapshotData, { access: this.access, sortFn: this.options.sortFn, length: -1, timeout: 1000, onProgressCallback: onProgress })\n        await this._oplog.join(log)\n        await this._updateIndex()\n        this.events.emit('replicated', this.address.toString()) // TODO: inconsistent params, count param not emited\n      }\n      this.events.emit('ready', this.address.toString(), this._oplog.heads)\n    } else {\n      throw new Error(`Snapshot for ${this.address} not found!`)\n    }\n\n    return this\n  }\n\n  async _updateIndex () {\n    this._recalculateReplicationMax()\n    await this._index.updateIndex(this._oplog)\n    this._recalculateReplicationProgress()\n  }\n\n  async syncLocal () {\n    const localHeads = await this._cache.get(this.localHeadsPath) || []\n    const remoteHeads = await this._cache.get(this.remoteHeadsPath) || []\n    const heads = localHeads.concat(remoteHeads)\n    for (let i = 0; i < heads.length; i++) {\n      const head = heads[i]\n      if (!this._oplog.heads.includes(head)) {\n        await this.load()\n        break\n      }\n    }\n  }\n\n  async _addOperation (data, { onProgressCallback, pin = false } = {}) {\n    async function addOperation () {\n      if (this._oplog) {\n        // check local cache?\n        if (this.options.syncLocal) {\n          await this.syncLocal()\n        }\n\n        const entry = await this._oplog.append(data, this.options.referenceCount, pin)\n        this._recalculateReplicationStatus(this.replicationStatus.progress + 1, entry.clock.time)\n        await this._cache.set(this.localHeadsPath, [entry])\n        await this._updateIndex()\n        this.events.emit('write', this.address.toString(), entry, this._oplog.heads)\n        if (onProgressCallback) onProgressCallback(entry)\n        return entry.hash\n      }\n    }\n    return this._opqueue.add(addOperation.bind(this))\n  }\n\n  _addOperationBatch (data, batchOperation, lastOperation, onProgressCallback) {\n    throw new Error('Not implemented!')\n  }\n\n  _procEntry (entry) {\n    var { payload, hash } = entry\n    var { op } = payload\n    if (op) {\n      this.events.emit(`log.op.${op}`, this.address.toString(), hash, payload)\n    } else {\n      this.events.emit('log.op.none', this.address.toString(), hash, payload)\n    }\n    this.events.emit('log.op', op, this.address.toString(), hash, payload)\n  }\n\n  _onLoadProgress (hash, entry, progress, total) {\n    this._recalculateReplicationStatus(progress, total)\n    this.events.emit('load.progress', this.address.toString(), hash, entry, this.replicationStatus.progress, this.replicationStatus.max)\n  }\n\n  /* Replication Status state updates */\n\n  _recalculateReplicationProgress (max) {\n    this._replicationStatus.progress = Math.max.apply(null, [\n      this._replicationStatus.progress,\n      this._oplog.length,\n      max || 0\n    ])\n    this._recalculateReplicationMax(this.replicationStatus.progress)\n  }\n\n  _recalculateReplicationMax (max) {\n    this._replicationStatus.max = Math.max.apply(null, [\n      this._replicationStatus.max,\n      this._oplog.length,\n      max || 0\n    ])\n  }\n\n  _recalculateReplicationStatus (maxProgress, maxTotal) {\n    this._recalculateReplicationProgress(maxProgress)\n    this._recalculateReplicationMax(maxTotal)\n  }\n}\n\nmodule.exports = Store\nmodule.exports.DefaultOptions = DefaultOptions\n"]},"metadata":{},"sourceType":"script"}