{"ast":null,"code":"'use strict';\n\nconst stream = require('stream');\n\nconst url = require('url');\n\nconst bignumber = require('bignumber.js').BigNumber;\n\nconst NoFilter = require('nofilter');\n\nconst Tagged = require('./tagged');\n\nconst Simple = require('./simple');\n\nconst utils = require('./utils');\n\nconst constants = require('./constants');\n\nconst MT = constants.MT;\nconst NUMBYTES = constants.NUMBYTES;\nconst SHIFT32 = constants.SHIFT32;\nconst SYMS = constants.SYMS;\nconst TAG = constants.TAG;\nconst HALF = constants.MT.SIMPLE_FLOAT << 5 | constants.NUMBYTES.TWO;\nconst FLOAT = constants.MT.SIMPLE_FLOAT << 5 | constants.NUMBYTES.FOUR;\nconst DOUBLE = constants.MT.SIMPLE_FLOAT << 5 | constants.NUMBYTES.EIGHT;\nconst TRUE = constants.MT.SIMPLE_FLOAT << 5 | constants.SIMPLE.TRUE;\nconst FALSE = constants.MT.SIMPLE_FLOAT << 5 | constants.SIMPLE.FALSE;\nconst UNDEFINED = constants.MT.SIMPLE_FLOAT << 5 | constants.SIMPLE.UNDEFINED;\nconst NULL = constants.MT.SIMPLE_FLOAT << 5 | constants.SIMPLE.NULL;\nconst BI = utils.bigIntize(constants.BI);\nconst BN = constants.BN;\nconst BUF_NAN = Buffer.from('f97e00', 'hex');\nconst BUF_INF_NEG = Buffer.from('f9fc00', 'hex');\nconst BUF_INF_POS = Buffer.from('f97c00', 'hex');\nconst BUF_NEG_ZERO = Buffer.from('f98000', 'hex');\nconst LOOP_DETECT = Symbol('CBOR_LOOP_DETECT');\n/**\n * Transform JavaScript values into CBOR bytes.  The `Writable` side of\n * the stream is in object mode.\n *\n * @extends {stream.Transform}\n */\n\nclass Encoder extends stream.Transform {\n  /**\n   * Creates an instance of Encoder.\n   *\n   * @param {Object} [options={}] - options for the encoder\n   * @param {any[]} [options.genTypes=[]] - array of pairs of `type`,\n   *   `function(Encoder)` for semantic types to be encoded.  Not needed\n   *   for Array, Date, Buffer, Map, RegExp, Set, Url, or bignumber.\n   * @param {boolean} [options.canonical=false] - should the output be\n   *   canonicalized\n   * @param {boolean|Symbol} [options.detectLoops=false] - should object loops\n   *   be detected?  This will currently modify the encoded object graph\n   *   by adding a Symbol property to each object.  If this bothers you,\n   *   call `removeLoopDetectors` on the encoded object when done.  Do not\n   *   encode the same object twice on the same encoder, without calling\n   *   `removeLoopDetectors` in between.\n   * @param {(\"number\"|\"float\"|\"int\"|\"string\")} [options.dateType=\"number\"] -\n   *   how should dates be encoded?  \"number\" means float or int, if no\n   *   fractional seconds.\n   * @param {any} [options.encodeUndefined=undefined] - How should an \n   *   \"undefined\" in the input be encoded.  By default, just encode a CBOR\n   *   undefined.  If this is a buffer, use those bytes without re-encoding\n   *   them.  If this is a function, the function will be called (which is\n   *   a good time to throw an exception, if that's what you want), and the\n   *   return value will be used according to these rules.  Anything\n   *   else will be encoded as CBOR.\n   * @param {boolean} [options.disallowUndefinedKeys=false] - Should \"undefined\"\n   *   be disallowed as a key in a Map that is serialized?  If this is true,\n   *   encode(new Map([[undefined, 1]])) will throw an exception.  Note that\n   *   it is impossible to get a key of undefined in a normal JS object.\n   * @param {boolean} [options.collapseBigIntegers=false] - Should integers\n   *   that come in as BigNumber integers and ECMAscript bigint's be encoded\n   *   as normal CBOR integers if they fit, discarding type information?\n   */\n  constructor(options) {\n    const opts = Object.assign({}, options, {\n      readableObjectMode: false,\n      writableObjectMode: true\n    });\n    super(opts);\n    this.canonical = opts.canonical;\n    this.encodeUndefined = opts.encodeUndefined;\n    this.disallowUndefinedKeys = !!opts.disallowUndefinedKeys;\n    this.dateType = opts.dateType != null ? opts.dateType.toLowerCase() : 'number';\n    this.collapseBigIntegers = !!opts.collapseBigIntegers; // new Symbol for each instance.  Note: means we can't re-use the same\n    // encoder and encoded object\n\n    if (typeof opts.detectLoops === 'symbol') {\n      this.detectLoops = opts.detectLoops;\n    } else {\n      this.detectLoops = !!opts.detectLoops ? Symbol('CBOR_DETECT') : null;\n    }\n\n    this.semanticTypes = [Array, this._pushArray, Date, this._pushDate, Buffer, this._pushBuffer, Map, this._pushMap, NoFilter, this._pushNoFilter, RegExp, this._pushRegexp, Set, this._pushSet, bignumber, this._pushBigNumber, ArrayBuffer, this._pushUint8Array, Uint8ClampedArray, this._pushUint8Array, Uint8Array, this._pushUint8Array, Uint16Array, this._pushArray, Uint32Array, this._pushArray, Int8Array, this._pushArray, Int16Array, this._pushArray, Int32Array, this._pushArray, Float32Array, this._pushFloat32Array, Float64Array, this._pushFloat64Array]; // tsc doesn't know about old Url\n\n    if (url['Url']) {\n      this.semanticTypes.push(url['Url'], this._pushUrl);\n    }\n\n    if (url['URL']) {\n      this.semanticTypes.push(url['URL'], this._pushURL);\n    }\n\n    const addTypes = opts.genTypes || [];\n\n    for (let i = 0, len = addTypes.length; i < len; i += 2) {\n      this.addSemanticType(addTypes[i], addTypes[i + 1]);\n    }\n  }\n\n  _transform(fresh, encoding, cb) {\n    const ret = this.pushAny(fresh); // Old transformers might not return bool.  undefined !== false\n\n    return cb(ret === false ? new Error('Push Error') : undefined);\n  }\n\n  _flush(cb) {\n    return cb();\n  }\n  /**\n   * @callback encodeFunction\n   * @param {Encoder} encoder - the encoder to serialize into.  Call \"write\"\n   *   on the encoder as needed.\n   * @return {bool} - true on success, else false\n   */\n\n  /**\n   * Add an encoding function to the list of supported semantic types.  This is\n   * useful for objects for which you can't add an encodeCBOR method\n   *\n   * @param {any} type\n   * @param {any} fun\n   * @returns {encodeFunction}\n   */\n\n\n  addSemanticType(type, fun) {\n    for (let i = 0, len = this.semanticTypes.length; i < len; i += 2) {\n      const typ = this.semanticTypes[i];\n\n      if (typ === type) {\n        const old = this.semanticTypes[i + 1];\n        this.semanticTypes[i + 1] = fun;\n        return old;\n      }\n    }\n\n    this.semanticTypes.push(type, fun);\n    return null;\n  }\n\n  _pushUInt8(val) {\n    const b = Buffer.allocUnsafe(1);\n    b.writeUInt8(val, 0);\n    return this.push(b);\n  }\n\n  _pushUInt16BE(val) {\n    const b = Buffer.allocUnsafe(2);\n    b.writeUInt16BE(val, 0);\n    return this.push(b);\n  }\n\n  _pushUInt32BE(val) {\n    const b = Buffer.allocUnsafe(4);\n    b.writeUInt32BE(val, 0);\n    return this.push(b);\n  }\n\n  _pushFloatBE(val) {\n    const b = Buffer.allocUnsafe(4);\n    b.writeFloatBE(val, 0);\n    return this.push(b);\n  }\n\n  _pushDoubleBE(val) {\n    const b = Buffer.allocUnsafe(8);\n    b.writeDoubleBE(val, 0);\n    return this.push(b);\n  }\n\n  _pushNaN() {\n    return this.push(BUF_NAN);\n  }\n\n  _pushInfinity(obj) {\n    const half = obj < 0 ? BUF_INF_NEG : BUF_INF_POS;\n    return this.push(half);\n  }\n\n  _pushFloat(obj) {\n    if (this.canonical) {\n      // TODO: is this enough slower to hide behind canonical?\n      // It's certainly enough of a hack (see utils.parseHalf)\n      // From section 3.9:\n      // If a protocol allows for IEEE floats, then additional canonicalization\n      // rules might need to be added.  One example rule might be to have all\n      // floats start as a 64-bit float, then do a test conversion to a 32-bit\n      // float; if the result is the same numeric value, use the shorter value\n      // and repeat the process with a test conversion to a 16-bit float.  (This\n      // rule selects 16-bit float for positive and negative Infinity as well.)\n      // which seems pretty much backwards to me.\n      const b2 = Buffer.allocUnsafe(2);\n\n      if (utils.writeHalf(b2, obj)) {\n        if (utils.parseHalf(b2) === obj) {\n          return this._pushUInt8(HALF) && this.push(b2);\n        }\n      }\n    }\n\n    if (Math.fround(obj) === obj) {\n      return this._pushUInt8(FLOAT) && this._pushFloatBE(obj);\n    }\n\n    return this._pushUInt8(DOUBLE) && this._pushDoubleBE(obj);\n  }\n\n  _pushInt(obj, mt, orig) {\n    const m = mt << 5;\n\n    switch (false) {\n      case !(obj < 24):\n        return this._pushUInt8(m | obj);\n\n      case !(obj <= 0xff):\n        return this._pushUInt8(m | NUMBYTES.ONE) && this._pushUInt8(obj);\n\n      case !(obj <= 0xffff):\n        return this._pushUInt8(m | NUMBYTES.TWO) && this._pushUInt16BE(obj);\n\n      case !(obj <= 0xffffffff):\n        return this._pushUInt8(m | NUMBYTES.FOUR) && this._pushUInt32BE(obj);\n\n      case !(obj <= Number.MAX_SAFE_INTEGER):\n        return this._pushUInt8(m | NUMBYTES.EIGHT) && this._pushUInt32BE(Math.floor(obj / SHIFT32)) && this._pushUInt32BE(obj % SHIFT32);\n\n      default:\n        if (mt === MT.NEG_INT) {\n          return this._pushFloat(orig);\n        } else {\n          return this._pushFloat(obj);\n        }\n\n    }\n  }\n\n  _pushIntNum(obj) {\n    if (Object.is(obj, -0)) {\n      return this.push(BUF_NEG_ZERO);\n    }\n\n    if (obj < 0) {\n      return this._pushInt(-obj - 1, MT.NEG_INT, obj);\n    } else {\n      return this._pushInt(obj, MT.POS_INT);\n    }\n  }\n\n  _pushNumber(obj) {\n    switch (false) {\n      case !isNaN(obj):\n        return this._pushNaN();\n\n      case isFinite(obj):\n        return this._pushInfinity(obj);\n\n      case Math.round(obj) !== obj:\n        return this._pushIntNum(obj);\n\n      default:\n        return this._pushFloat(obj);\n    }\n  }\n\n  _pushString(obj) {\n    const len = Buffer.byteLength(obj, 'utf8');\n    return this._pushInt(len, MT.UTF8_STRING) && this.push(obj, 'utf8');\n  }\n\n  _pushBoolean(obj) {\n    return this._pushUInt8(obj ? TRUE : FALSE);\n  }\n\n  _pushUndefined(obj) {\n    switch (typeof this.encodeUndefined) {\n      case 'undefined':\n        return this._pushUInt8(UNDEFINED);\n\n      case 'function':\n        return this.pushAny(this.encodeUndefined.call(this, obj));\n\n      case 'object':\n        if (Buffer.isBuffer(this.encodeUndefined)) {\n          return this.push(this.encodeUndefined);\n        }\n\n    }\n\n    return this.pushAny(this.encodeUndefined);\n  }\n\n  _pushNull(obj) {\n    return this._pushUInt8(NULL);\n  }\n\n  _pushArray(gen, obj) {\n    const len = obj.length;\n\n    if (!gen._pushInt(len, MT.ARRAY)) {\n      return false;\n    }\n\n    for (let j = 0; j < len; j++) {\n      if (!gen.pushAny(obj[j])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  _pushTag(tag) {\n    return this._pushInt(tag, MT.TAG);\n  }\n\n  _pushDate(gen, obj) {\n    switch (gen.dateType) {\n      case 'string':\n        return gen._pushTag(TAG.DATE_STRING) && gen._pushString(obj.toISOString());\n\n      case 'int':\n      case 'integer':\n        return gen._pushTag(TAG.DATE_EPOCH) && gen._pushIntNum(Math.round(obj / 1000));\n\n      case 'float':\n        // force float\n        return gen._pushTag(TAG.DATE_EPOCH) && gen._pushFloat(obj / 1000);\n\n      case 'number':\n      default:\n        // if we happen to have an integral number of seconds,\n        // use integer.  Otherwise, use float.\n        return gen._pushTag(TAG.DATE_EPOCH) && gen.pushAny(obj / 1000);\n    }\n  }\n\n  _pushBuffer(gen, obj) {\n    return gen._pushInt(obj.length, MT.BYTE_STRING) && gen.push(obj);\n  }\n\n  _pushNoFilter(gen, obj) {\n    return gen._pushBuffer(gen, obj.slice());\n  }\n\n  _pushRegexp(gen, obj) {\n    return gen._pushTag(TAG.REGEXP) && gen.pushAny(obj.source);\n  }\n\n  _pushSet(gen, obj) {\n    if (!gen._pushInt(obj.size, MT.ARRAY)) {\n      return false;\n    }\n\n    for (const x of obj) {\n      if (!gen.pushAny(x)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  _pushUrl(gen, obj) {\n    return gen._pushTag(TAG.URI) && gen.pushAny(obj.format());\n  }\n\n  _pushURL(gen, obj) {\n    return gen._pushTag(TAG.URI) && gen.pushAny(obj.toString());\n  }\n  /**\n   * @param {bignumber} obj\n   * @private\n   */\n\n\n  _pushBigint(obj) {\n    let m = MT.POS_INT;\n    let tag = TAG.POS_BIGINT;\n\n    if (obj.isNegative()) {\n      obj = obj.negated().minus(1);\n      m = MT.NEG_INT;\n      tag = TAG.NEG_BIGINT;\n    }\n\n    if (this.collapseBigIntegers && obj.lte(BN.MAXINT64)) {\n      //  special handiling for 64bits\n      if (obj.lte(BN.MAXINT32)) {\n        return this._pushInt(obj.toNumber(), m);\n      }\n\n      return this._pushUInt8(m << 5 | NUMBYTES.EIGHT) && this._pushUInt32BE(obj.dividedToIntegerBy(BN.SHIFT32).toNumber()) && this._pushUInt32BE(obj.mod(BN.SHIFT32).toNumber());\n    }\n\n    let str = obj.toString(16);\n\n    if (str.length % 2) {\n      str = '0' + str;\n    }\n\n    const buf = Buffer.from(str, 'hex');\n    return this._pushTag(tag) && this._pushBuffer(this, buf);\n  }\n  /**\n   * @param {bigint} obj\n   * @private\n   */\n\n\n  _pushJSBigint(obj) {\n    let m = MT.POS_INT;\n    let tag = TAG.POS_BIGINT; // BigInt doesn't have -0\n\n    if (obj < 0) {\n      obj = -obj + BI.MINUS_ONE;\n      m = MT.NEG_INT;\n      tag = TAG.NEG_BIGINT;\n    }\n\n    if (this.collapseBigIntegers && obj <= BI.MAXINT64) {\n      //  special handiling for 64bits\n      if (obj <= 0xffffffff) {\n        return this._pushInt(Number(obj), m);\n      }\n\n      return this._pushUInt8(m << 5 | NUMBYTES.EIGHT) && this._pushUInt32BE(Number(obj / BI.SHIFT32)) && this._pushUInt32BE(Number(obj % BI.SHIFT32));\n    }\n\n    let str = obj.toString(16);\n\n    if (str.length % 2) {\n      str = '0' + str;\n    }\n\n    const buf = Buffer.from(str, 'hex');\n    return this._pushTag(tag) && this._pushBuffer(this, buf);\n  }\n\n  _pushBigNumber(gen, obj) {\n    if (obj.isNaN()) {\n      return gen._pushNaN();\n    }\n\n    if (!obj.isFinite()) {\n      return gen._pushInfinity(obj.isNegative() ? -Infinity : Infinity);\n    }\n\n    if (obj.isInteger()) {\n      return gen._pushBigint(obj);\n    }\n\n    if (!(gen._pushTag(TAG.DECIMAL_FRAC) && gen._pushInt(2, MT.ARRAY))) {\n      return false;\n    }\n\n    const dec = obj.decimalPlaces();\n    const slide = obj.times(new bignumber(10).pow(dec));\n\n    if (!gen._pushIntNum(-dec)) {\n      return false;\n    }\n\n    if (slide.abs().isLessThan(BN.MAXINT)) {\n      return gen._pushIntNum(slide.toNumber());\n    } else {\n      return gen._pushBigint(slide);\n    }\n  }\n\n  _pushMap(gen, obj) {\n    if (!gen._pushInt(obj.size, MT.MAP)) {\n      return false;\n    } // memoizing the cbor only helps in certain cases, and hurts in most\n    // others.  Just avoid it.\n\n\n    if (gen.canonical) {\n      // keep the key/value pairs together, so we don't have to do odd\n      // gets with object keys later\n      const entries = [...obj.entries()];\n      const enc = new Encoder(this); // TODO: fix genTypes\n\n      const bs = new NoFilter({\n        highWaterMark: this.readableHighWaterMark\n      });\n      enc.pipe(bs);\n      entries.sort(([a], [b]) => {\n        // a, b are the keys\n        enc.pushAny(a);\n        const a_cbor = bs.read();\n        enc.pushAny(b);\n        const b_cbor = bs.read();\n        return a_cbor.compare(b_cbor);\n      });\n\n      for (const [k, v] of entries) {\n        if (gen.disallowUndefinedKeys && typeof k === 'undefined') {\n          throw new Error('Invalid Map key: undefined');\n        }\n\n        if (!(gen.pushAny(k) && gen.pushAny(v))) {\n          return false;\n        }\n      }\n    } else {\n      for (const [k, v] of obj) {\n        if (gen.disallowUndefinedKeys && typeof k === 'undefined') {\n          throw new Error('Invalid Map key: undefined');\n        }\n\n        if (!(gen.pushAny(k) && gen.pushAny(v))) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n\n  _pushUint8Array(gen, obj) {\n    return gen._pushBuffer(gen, Buffer.from(obj));\n  }\n\n  _pushFloat32Array(gen, obj) {\n    const len = obj.length;\n\n    if (!gen._pushInt(len, MT.ARRAY)) {\n      return false;\n    }\n\n    for (let j = 0; j < len; j++) {\n      if (!gen._pushUInt8(FLOAT) || !gen._pushFloatBE(obj[j])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  _pushFloat64Array(gen, obj) {\n    const len = obj.length;\n\n    if (!gen._pushInt(len, MT.ARRAY)) {\n      return false;\n    }\n\n    for (let j = 0; j < len; j++) {\n      if (!gen._pushUInt8(DOUBLE) || !gen._pushDoubleBE(obj[j])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  removeLoopDetectors(obj) {\n    if (!this.detectLoops || typeof obj !== 'object' || !obj) {\n      return false;\n    }\n\n    const dl = obj[LOOP_DETECT];\n\n    if (!dl || dl !== this.detectLoops) {\n      // ironically, use loop marking to detect loops on removal as well\n      return false;\n    }\n\n    delete obj[LOOP_DETECT];\n\n    if (Array.isArray(obj)) {\n      for (const i of obj) {\n        this.removeLoopDetectors(i);\n      }\n    } else {\n      for (const k in obj) {\n        this.removeLoopDetectors(obj[k]);\n      }\n    }\n\n    return true;\n  }\n\n  _pushObject(obj) {\n    if (!obj) {\n      return this._pushNull(obj);\n    }\n\n    if (this.detectLoops) {\n      if (obj[LOOP_DETECT] === this.detectLoops) {\n        throw new Error('Loop detected while CBOR encoding');\n      } else {\n        obj[LOOP_DETECT] = this.detectLoops;\n      }\n    }\n\n    const f = obj.encodeCBOR;\n\n    if (typeof f === 'function') {\n      return f.call(obj, this);\n    }\n\n    for (let i = 0, len1 = this.semanticTypes.length; i < len1; i += 2) {\n      const typ = this.semanticTypes[i];\n\n      if (obj instanceof typ) {\n        return this.semanticTypes[i + 1].call(obj, this, obj);\n      }\n    }\n\n    const keys = Object.keys(obj);\n    const cbor_keys = {};\n\n    if (this.canonical) {\n      // note: this can't be a normal sort, because 'b' needs to sort before\n      // 'aa'\n      keys.sort((a, b) => {\n        // Always strings, so don't bother to pass options.\n        // hold on to the cbor versions, since there's no need\n        // to encode more than once\n        const a_cbor = cbor_keys[a] || (cbor_keys[a] = Encoder.encode(a));\n        const b_cbor = cbor_keys[b] || (cbor_keys[b] = Encoder.encode(b));\n        return a_cbor.compare(b_cbor);\n      });\n    }\n\n    if (!this._pushInt(keys.length, MT.MAP)) {\n      return false;\n    }\n\n    let ck;\n\n    for (let j = 0, len2 = keys.length; j < len2; j++) {\n      const k = keys[j];\n\n      if (this.canonical && (ck = cbor_keys[k])) {\n        if (!this.push(ck)) {\n          // already a Buffer\n          return false;\n        }\n      } else {\n        if (!this._pushString(k)) {\n          return false;\n        }\n      }\n\n      if (!this.pushAny(obj[k])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n  /**\n   * Push any supported type onto the encoded stream\n   *\n   * @param {any} obj\n   * @returns {boolean} true on success\n   */\n\n\n  pushAny(obj) {\n    switch (typeof obj) {\n      case 'number':\n        return this._pushNumber(obj);\n\n      case 'bigint':\n        return this._pushJSBigint(obj);\n\n      case 'string':\n        return this._pushString(obj);\n\n      case 'boolean':\n        return this._pushBoolean(obj);\n\n      case 'undefined':\n        return this._pushUndefined(obj);\n\n      case 'object':\n        return this._pushObject(obj);\n\n      case 'symbol':\n        switch (obj) {\n          case SYMS.NULL:\n            return this._pushNull(null);\n\n          case SYMS.UNDEFINED:\n            return this._pushUndefined(void 0);\n          // TODO: Add pluggable support for other symbols\n\n          default:\n            throw new Error('Unknown symbol: ' + obj.toString());\n        }\n\n      default:\n        throw new Error('Unknown type: ' + typeof obj + ', ' + (!!obj ? obj.toString() : ''));\n    }\n  }\n  /* backwards-compat wrapper */\n\n\n  _pushAny(obj) {\n    // TODO: write deprecation warning\n    return this.pushAny(obj);\n  }\n\n  _encodeAll(objs) {\n    const bs = new NoFilter({\n      highWaterMark: this.readableHighWaterMark\n    });\n    this.pipe(bs);\n\n    for (const o of objs) {\n      this.pushAny(o);\n    }\n\n    this.end();\n    return bs.read();\n  }\n  /**\n   * Encode one or more JavaScript objects, and return a Buffer containing the\n   * CBOR bytes.\n   *\n   * @param {...any} objs - the objects to encode\n   * @returns {Buffer} - the encoded objects\n   */\n\n\n  static encode(...objs) {\n    return new Encoder()._encodeAll(objs);\n  }\n  /**\n   * Encode one or more JavaScript objects canonically (slower!), and return\n   * a Buffer containing the CBOR bytes.\n   *\n   * @param {...any} objs - the objects to encode\n   * @returns {Buffer} - the encoded objects\n   */\n\n\n  static encodeCanonical(...objs) {\n    return new Encoder({\n      canonical: true\n    })._encodeAll(objs);\n  }\n  /**\n   * Encode one JavaScript object using the given options.\n   *\n   * @static\n   * @param {any} obj - the object to encode\n   * @param {Object?} options - passed to the Encoder constructor\n   * @returns {Buffer} - the encoded objects\n   */\n\n\n  static encodeOne(obj, options) {\n    return new Encoder(options)._encodeAll([obj]);\n  }\n  /**\n   * Encode one JavaScript object using the given options in a way that\n   * is more resilient to objects being larger than the highWaterMark\n   * number of bytes.  As with the other static encode functions, this \n   * will still use a large amount of memory.  Use a stream-based approach\n   * directly if you need to process large and complicated inputs.\n   *\n   * @param {any} obj - the object to encode\n   * @param {Object?} options - passed to the Encoder constructor\n   */\n\n\n  static encodeAsync(obj, options) {\n    return new Promise((resolve, reject) => {\n      const bufs = [];\n      const enc = new Encoder(options);\n      enc.on('data', buf => bufs.push(buf));\n      enc.on('error', reject);\n      enc.on('finish', () => resolve(Buffer.concat(bufs)));\n      enc.pushAny(obj);\n      enc.end();\n    });\n  }\n\n}\n\nmodule.exports = Encoder;","map":{"version":3,"sources":["/home/user/orbit-playground/music-app/node_modules/cbor/lib/encoder.js"],"names":["stream","require","url","bignumber","BigNumber","NoFilter","Tagged","Simple","utils","constants","MT","NUMBYTES","SHIFT32","SYMS","TAG","HALF","SIMPLE_FLOAT","TWO","FLOAT","FOUR","DOUBLE","EIGHT","TRUE","SIMPLE","FALSE","UNDEFINED","NULL","BI","bigIntize","BN","BUF_NAN","Buffer","from","BUF_INF_NEG","BUF_INF_POS","BUF_NEG_ZERO","LOOP_DETECT","Symbol","Encoder","Transform","constructor","options","opts","Object","assign","readableObjectMode","writableObjectMode","canonical","encodeUndefined","disallowUndefinedKeys","dateType","toLowerCase","collapseBigIntegers","detectLoops","semanticTypes","Array","_pushArray","Date","_pushDate","_pushBuffer","Map","_pushMap","_pushNoFilter","RegExp","_pushRegexp","Set","_pushSet","_pushBigNumber","ArrayBuffer","_pushUint8Array","Uint8ClampedArray","Uint8Array","Uint16Array","Uint32Array","Int8Array","Int16Array","Int32Array","Float32Array","_pushFloat32Array","Float64Array","_pushFloat64Array","push","_pushUrl","_pushURL","addTypes","genTypes","i","len","length","addSemanticType","_transform","fresh","encoding","cb","ret","pushAny","Error","undefined","_flush","type","fun","typ","old","_pushUInt8","val","b","allocUnsafe","writeUInt8","_pushUInt16BE","writeUInt16BE","_pushUInt32BE","writeUInt32BE","_pushFloatBE","writeFloatBE","_pushDoubleBE","writeDoubleBE","_pushNaN","_pushInfinity","obj","half","_pushFloat","b2","writeHalf","parseHalf","Math","fround","_pushInt","mt","orig","m","ONE","Number","MAX_SAFE_INTEGER","floor","NEG_INT","_pushIntNum","is","POS_INT","_pushNumber","isNaN","isFinite","round","_pushString","byteLength","UTF8_STRING","_pushBoolean","_pushUndefined","call","isBuffer","_pushNull","gen","ARRAY","j","_pushTag","tag","DATE_STRING","toISOString","DATE_EPOCH","BYTE_STRING","slice","REGEXP","source","size","x","URI","format","toString","_pushBigint","POS_BIGINT","isNegative","negated","minus","NEG_BIGINT","lte","MAXINT64","MAXINT32","toNumber","dividedToIntegerBy","mod","str","buf","_pushJSBigint","MINUS_ONE","Infinity","isInteger","DECIMAL_FRAC","dec","decimalPlaces","slide","times","pow","abs","isLessThan","MAXINT","MAP","entries","enc","bs","highWaterMark","readableHighWaterMark","pipe","sort","a","a_cbor","read","b_cbor","compare","k","v","removeLoopDetectors","dl","isArray","_pushObject","f","encodeCBOR","len1","keys","cbor_keys","encode","ck","len2","_pushAny","_encodeAll","objs","o","end","encodeCanonical","encodeOne","encodeAsync","Promise","resolve","reject","bufs","on","concat","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst stream = require('stream')\nconst url = require('url')\nconst bignumber = require('bignumber.js').BigNumber\nconst NoFilter = require('nofilter')\nconst Tagged = require('./tagged')\nconst Simple = require('./simple')\nconst utils = require('./utils')\n\nconst constants = require('./constants')\nconst MT = constants.MT\nconst NUMBYTES = constants.NUMBYTES\nconst SHIFT32 = constants.SHIFT32\nconst SYMS = constants.SYMS\nconst TAG = constants.TAG\nconst HALF = (constants.MT.SIMPLE_FLOAT << 5) | constants.NUMBYTES.TWO\nconst FLOAT = (constants.MT.SIMPLE_FLOAT << 5) | constants.NUMBYTES.FOUR\nconst DOUBLE = (constants.MT.SIMPLE_FLOAT << 5) | constants.NUMBYTES.EIGHT\nconst TRUE = (constants.MT.SIMPLE_FLOAT << 5) | constants.SIMPLE.TRUE\nconst FALSE = (constants.MT.SIMPLE_FLOAT << 5) | constants.SIMPLE.FALSE\nconst UNDEFINED = (constants.MT.SIMPLE_FLOAT << 5) | constants.SIMPLE.UNDEFINED\nconst NULL = (constants.MT.SIMPLE_FLOAT << 5) | constants.SIMPLE.NULL\n\nconst BI = utils.bigIntize(constants.BI)\nconst BN = constants.BN\nconst BUF_NAN = Buffer.from('f97e00', 'hex')\nconst BUF_INF_NEG = Buffer.from('f9fc00', 'hex')\nconst BUF_INF_POS = Buffer.from('f97c00', 'hex')\nconst BUF_NEG_ZERO = Buffer.from('f98000', 'hex')\nconst LOOP_DETECT = Symbol('CBOR_LOOP_DETECT')\n\n/**\n * Transform JavaScript values into CBOR bytes.  The `Writable` side of\n * the stream is in object mode.\n *\n * @extends {stream.Transform}\n */\nclass Encoder extends stream.Transform {\n\n  /**\n   * Creates an instance of Encoder.\n   *\n   * @param {Object} [options={}] - options for the encoder\n   * @param {any[]} [options.genTypes=[]] - array of pairs of `type`,\n   *   `function(Encoder)` for semantic types to be encoded.  Not needed\n   *   for Array, Date, Buffer, Map, RegExp, Set, Url, or bignumber.\n   * @param {boolean} [options.canonical=false] - should the output be\n   *   canonicalized\n   * @param {boolean|Symbol} [options.detectLoops=false] - should object loops\n   *   be detected?  This will currently modify the encoded object graph\n   *   by adding a Symbol property to each object.  If this bothers you,\n   *   call `removeLoopDetectors` on the encoded object when done.  Do not\n   *   encode the same object twice on the same encoder, without calling\n   *   `removeLoopDetectors` in between.\n   * @param {(\"number\"|\"float\"|\"int\"|\"string\")} [options.dateType=\"number\"] -\n   *   how should dates be encoded?  \"number\" means float or int, if no\n   *   fractional seconds.\n   * @param {any} [options.encodeUndefined=undefined] - How should an \n   *   \"undefined\" in the input be encoded.  By default, just encode a CBOR\n   *   undefined.  If this is a buffer, use those bytes without re-encoding\n   *   them.  If this is a function, the function will be called (which is\n   *   a good time to throw an exception, if that's what you want), and the\n   *   return value will be used according to these rules.  Anything\n   *   else will be encoded as CBOR.\n   * @param {boolean} [options.disallowUndefinedKeys=false] - Should \"undefined\"\n   *   be disallowed as a key in a Map that is serialized?  If this is true,\n   *   encode(new Map([[undefined, 1]])) will throw an exception.  Note that\n   *   it is impossible to get a key of undefined in a normal JS object.\n   * @param {boolean} [options.collapseBigIntegers=false] - Should integers\n   *   that come in as BigNumber integers and ECMAscript bigint's be encoded\n   *   as normal CBOR integers if they fit, discarding type information?\n   */\n  constructor(options) {\n    const opts = Object.assign({}, options, {\n      readableObjectMode: false,\n      writableObjectMode: true\n    })\n    super(opts)\n\n    this.canonical = opts.canonical\n    this.encodeUndefined = opts.encodeUndefined\n    this.disallowUndefinedKeys = !!opts.disallowUndefinedKeys\n    this.dateType = (opts.dateType != null) ?\n      opts.dateType.toLowerCase() : 'number'\n    this.collapseBigIntegers = !!opts.collapseBigIntegers\n\n    // new Symbol for each instance.  Note: means we can't re-use the same\n    // encoder and encoded object\n    if (typeof(opts.detectLoops) === 'symbol') {\n      this.detectLoops = opts.detectLoops\n    } else {\n      this.detectLoops = !!opts.detectLoops ? Symbol('CBOR_DETECT') : null\n    }\n\n    this.semanticTypes = [\n      Array, this._pushArray,\n      Date, this._pushDate,\n      Buffer, this._pushBuffer,\n      Map, this._pushMap,\n      NoFilter, this._pushNoFilter,\n      RegExp, this._pushRegexp,\n      Set, this._pushSet,\n      bignumber, this._pushBigNumber,\n      ArrayBuffer, this._pushUint8Array,\n      Uint8ClampedArray, this._pushUint8Array,\n      Uint8Array, this._pushUint8Array,\n      Uint16Array, this._pushArray,\n      Uint32Array, this._pushArray,\n      Int8Array, this._pushArray,\n      Int16Array, this._pushArray,\n      Int32Array, this._pushArray,\n      Float32Array, this._pushFloat32Array,\n      Float64Array, this._pushFloat64Array\n    ]\n\n    // tsc doesn't know about old Url\n    if (url['Url']) {\n      this.semanticTypes.push(url['Url'], this._pushUrl)\n    }\n    if (url['URL']) {\n      this.semanticTypes.push(url['URL'], this._pushURL)\n    }\n\n    const addTypes = opts.genTypes || []\n    for (let i = 0, len = addTypes.length; i < len; i += 2) {\n      this.addSemanticType(addTypes[i], addTypes[i + 1])\n    }\n  }\n\n  _transform(fresh, encoding, cb) {\n    const ret = this.pushAny(fresh)\n    // Old transformers might not return bool.  undefined !== false\n    return cb((ret === false) ? new Error('Push Error') : undefined)\n  }\n\n  _flush(cb) {\n    return cb()\n  }\n\n  /**\n   * @callback encodeFunction\n   * @param {Encoder} encoder - the encoder to serialize into.  Call \"write\"\n   *   on the encoder as needed.\n   * @return {bool} - true on success, else false\n   */\n\n  /**\n   * Add an encoding function to the list of supported semantic types.  This is\n   * useful for objects for which you can't add an encodeCBOR method\n   *\n   * @param {any} type\n   * @param {any} fun\n   * @returns {encodeFunction}\n   */\n  addSemanticType(type, fun) {\n    for (let i = 0, len = this.semanticTypes.length; i < len; i += 2) {\n      const typ = this.semanticTypes[i]\n      if (typ === type) {\n        const old = this.semanticTypes[i + 1]\n        this.semanticTypes[i + 1] = fun\n        return old\n      }\n    }\n    this.semanticTypes.push(type, fun)\n    return null\n  }\n\n  _pushUInt8(val) {\n    const b = Buffer.allocUnsafe(1)\n    b.writeUInt8(val, 0)\n    return this.push(b)\n  }\n\n  _pushUInt16BE(val) {\n    const b = Buffer.allocUnsafe(2)\n    b.writeUInt16BE(val, 0)\n    return this.push(b)\n  }\n\n  _pushUInt32BE(val) {\n    const b = Buffer.allocUnsafe(4)\n    b.writeUInt32BE(val, 0)\n    return this.push(b)\n  }\n\n  _pushFloatBE(val) {\n    const b = Buffer.allocUnsafe(4)\n    b.writeFloatBE(val, 0)\n    return this.push(b)\n  }\n\n  _pushDoubleBE(val) {\n    const b = Buffer.allocUnsafe(8)\n    b.writeDoubleBE(val, 0)\n    return this.push(b)\n  }\n\n  _pushNaN() {\n    return this.push(BUF_NAN)\n  }\n\n  _pushInfinity(obj) {\n    const half = (obj < 0) ? BUF_INF_NEG : BUF_INF_POS\n    return this.push(half)\n  }\n\n  _pushFloat(obj) {\n    if (this.canonical) {\n      // TODO: is this enough slower to hide behind canonical?\n      // It's certainly enough of a hack (see utils.parseHalf)\n\n      // From section 3.9:\n      // If a protocol allows for IEEE floats, then additional canonicalization\n      // rules might need to be added.  One example rule might be to have all\n      // floats start as a 64-bit float, then do a test conversion to a 32-bit\n      // float; if the result is the same numeric value, use the shorter value\n      // and repeat the process with a test conversion to a 16-bit float.  (This\n      // rule selects 16-bit float for positive and negative Infinity as well.)\n\n      // which seems pretty much backwards to me.\n      const b2 = Buffer.allocUnsafe(2)\n      if (utils.writeHalf(b2, obj)) {\n        if (utils.parseHalf(b2) === obj) {\n          return this._pushUInt8(HALF) && this.push(b2)\n        }\n      }\n    }\n    if (Math.fround(obj) === obj) {\n      return this._pushUInt8(FLOAT) && this._pushFloatBE(obj)\n    }\n\n    return this._pushUInt8(DOUBLE) && this._pushDoubleBE(obj)\n  }\n\n  _pushInt(obj, mt, orig) {\n    const m = mt << 5\n    switch (false) {\n      case !(obj < 24):\n        return this._pushUInt8(m | obj)\n      case !(obj <= 0xff):\n        return this._pushUInt8(m | NUMBYTES.ONE) && this._pushUInt8(obj)\n      case !(obj <= 0xffff):\n        return this._pushUInt8(m | NUMBYTES.TWO) && this._pushUInt16BE(obj)\n      case !(obj <= 0xffffffff):\n        return this._pushUInt8(m | NUMBYTES.FOUR) && this._pushUInt32BE(obj)\n      case !(obj <= Number.MAX_SAFE_INTEGER):\n        return this._pushUInt8(m | NUMBYTES.EIGHT) &&\n          this._pushUInt32BE(Math.floor(obj / SHIFT32)) &&\n          this._pushUInt32BE(obj % SHIFT32)\n      default:\n        if (mt === MT.NEG_INT) {\n          return this._pushFloat(orig)\n        } else {\n          return this._pushFloat(obj)\n        }\n    }\n  }\n\n  _pushIntNum(obj) {\n    if (Object.is(obj, -0)) {\n      return this.push(BUF_NEG_ZERO)\n    }\n\n    if (obj < 0) {\n      return this._pushInt(-obj - 1, MT.NEG_INT, obj)\n    } else {\n      return this._pushInt(obj, MT.POS_INT)\n    }\n  }\n\n  _pushNumber(obj) {\n    switch (false) {\n      case !isNaN(obj):\n        return this._pushNaN()\n      case isFinite(obj):\n        return this._pushInfinity(obj)\n      case Math.round(obj) !== obj:\n        return this._pushIntNum(obj)\n      default:\n        return this._pushFloat(obj)\n    }\n  }\n\n  _pushString(obj) {\n    const len = Buffer.byteLength(obj, 'utf8')\n    return this._pushInt(len, MT.UTF8_STRING) && this.push(obj, 'utf8')\n  }\n\n  _pushBoolean(obj) {\n    return this._pushUInt8(obj ? TRUE : FALSE)\n  }\n\n  _pushUndefined(obj) {\n    switch (typeof this.encodeUndefined) {\n      case 'undefined':\n        return this._pushUInt8(UNDEFINED)\n      case 'function':\n        return this.pushAny(this.encodeUndefined.call(this, obj))\n      case 'object':\n        if (Buffer.isBuffer(this.encodeUndefined)) {\n          return this.push(this.encodeUndefined)\n        }\n    }\n    return this.pushAny(this.encodeUndefined)\n  }\n\n  _pushNull(obj) {\n    return this._pushUInt8(NULL)\n  }\n\n  _pushArray(gen, obj) {\n    const len = obj.length\n    if (!gen._pushInt(len, MT.ARRAY)) {\n      return false\n    }\n    for (let j = 0; j < len; j++) {\n      if (!gen.pushAny(obj[j])) {\n        return false\n      }\n    }\n    return true\n  }\n\n  _pushTag(tag) {\n    return this._pushInt(tag, MT.TAG)\n  }\n\n  _pushDate(gen, obj) {\n    switch (gen.dateType) {\n      case 'string':\n        return gen._pushTag(TAG.DATE_STRING) &&\n          gen._pushString(obj.toISOString())\n      case 'int':\n      case 'integer':\n        return gen._pushTag(TAG.DATE_EPOCH) &&\n          gen._pushIntNum(Math.round(obj / 1000))\n      case 'float':\n        // force float\n        return gen._pushTag(TAG.DATE_EPOCH) &&\n          gen._pushFloat(obj / 1000)\n      case 'number':\n      default:\n        // if we happen to have an integral number of seconds,\n        // use integer.  Otherwise, use float.\n        return gen._pushTag(TAG.DATE_EPOCH) &&\n          gen.pushAny(obj / 1000)\n    }\n  }\n\n  _pushBuffer(gen, obj) {\n    return gen._pushInt(obj.length, MT.BYTE_STRING) && gen.push(obj)\n  }\n\n  _pushNoFilter(gen, obj) {\n    return gen._pushBuffer(gen, obj.slice())\n  }\n\n  _pushRegexp(gen, obj) {\n    return gen._pushTag(TAG.REGEXP) && gen.pushAny(obj.source)\n  }\n\n  _pushSet(gen, obj) {\n    if (!gen._pushInt(obj.size, MT.ARRAY)) {\n      return false\n    }\n    for (const x of obj) {\n      if (!gen.pushAny(x)) {\n        return false\n      }\n    }\n    return true\n  }\n\n  _pushUrl(gen, obj) {\n    return gen._pushTag(TAG.URI) && gen.pushAny(obj.format())\n  }\n\n  _pushURL(gen, obj) {\n    return gen._pushTag(TAG.URI) && gen.pushAny(obj.toString())\n  }\n\n  /**\n   * @param {bignumber} obj\n   * @private\n   */\n  _pushBigint(obj) {\n    let m = MT.POS_INT\n    let tag = TAG.POS_BIGINT\n\n    if (obj.isNegative()) {\n      obj = obj.negated().minus(1)\n      m = MT.NEG_INT\n      tag = TAG.NEG_BIGINT\n    }\n\n    if (this.collapseBigIntegers &&\n        obj.lte(BN.MAXINT64)) {\n      //  special handiling for 64bits\n      if (obj.lte(BN.MAXINT32)) {\n        return this._pushInt(obj.toNumber(), m)\n      }\n      return this._pushUInt8((m << 5) | NUMBYTES.EIGHT) &&\n        this._pushUInt32BE(obj.dividedToIntegerBy(BN.SHIFT32).toNumber()) &&\n        this._pushUInt32BE(obj.mod(BN.SHIFT32).toNumber())\n    }\n    let str = obj.toString(16)\n    if (str.length % 2) {\n      str = '0' + str\n    }\n    const buf = Buffer.from(str, 'hex')\n    return this._pushTag(tag) && this._pushBuffer(this, buf)\n  }\n\n  /**\n   * @param {bigint} obj\n   * @private\n   */\n  _pushJSBigint(obj) {\n    let m = MT.POS_INT\n    let tag = TAG.POS_BIGINT\n    // BigInt doesn't have -0\n    if (obj < 0) {\n      obj = -obj + BI.MINUS_ONE\n      m = MT.NEG_INT\n      tag = TAG.NEG_BIGINT\n    }\n\n    if (this.collapseBigIntegers &&\n        (obj <= BI.MAXINT64)) {\n      //  special handiling for 64bits\n      if (obj <= 0xffffffff) {\n        return this._pushInt(Number(obj), m)\n      }\n      return this._pushUInt8((m << 5) | NUMBYTES.EIGHT) &&\n        this._pushUInt32BE(Number(obj / BI.SHIFT32)) &&\n        this._pushUInt32BE(Number(obj % BI.SHIFT32))\n    }\n\n    let str = obj.toString(16)\n    if (str.length % 2) {\n      str = '0' + str\n    }\n    const buf = Buffer.from(str, 'hex')\n    return this._pushTag(tag) && this._pushBuffer(this, buf)\n  }\n\n  _pushBigNumber(gen, obj) {\n    if (obj.isNaN()) {\n      return gen._pushNaN()\n    }\n    if (!obj.isFinite()) {\n      return gen._pushInfinity(obj.isNegative() ? -Infinity : Infinity)\n    }\n    if (obj.isInteger()) {\n      return gen._pushBigint(obj)\n    }\n    if (!(gen._pushTag(TAG.DECIMAL_FRAC) &&\n      gen._pushInt(2, MT.ARRAY))) {\n      return false\n    }\n\n    const dec = obj.decimalPlaces()\n    const slide = obj.times(new bignumber(10).pow(dec))\n    if (!gen._pushIntNum(-dec)) {\n      return false\n    }\n    if (slide.abs().isLessThan(BN.MAXINT)) {\n      return gen._pushIntNum(slide.toNumber())\n    } else {\n      return gen._pushBigint(slide)\n    }\n  }\n\n  _pushMap(gen, obj) {\n    if (!gen._pushInt(obj.size, MT.MAP)) {\n      return false\n    }\n    // memoizing the cbor only helps in certain cases, and hurts in most\n    // others.  Just avoid it.\n    if (gen.canonical) {\n      // keep the key/value pairs together, so we don't have to do odd\n      // gets with object keys later\n      const entries = [...obj.entries()]\n      const enc = new Encoder(this) // TODO: fix genTypes\n      const bs = new NoFilter({highWaterMark:this.readableHighWaterMark})\n      enc.pipe(bs)\n      entries.sort(([a], [b]) => {\n        // a, b are the keys\n        enc.pushAny(a)\n        const a_cbor = bs.read()\n        enc.pushAny(b)\n        const b_cbor = bs.read()\n        return a_cbor.compare(b_cbor)\n      })\n      for (const [k, v] of entries) {\n        if (gen.disallowUndefinedKeys && (typeof k === 'undefined')) {\n          throw new Error('Invalid Map key: undefined')\n        }\n        if (!(gen.pushAny(k) && gen.pushAny(v))) {\n          return false\n        }\n      }\n    } else {\n      for (const [k, v] of obj) {\n        if (gen.disallowUndefinedKeys && (typeof k === 'undefined')) {\n          throw new Error('Invalid Map key: undefined')\n        }\n        if (!(gen.pushAny(k) && gen.pushAny(v))) {\n          return false\n        }\n      }\n    }\n    return true\n  }\n\n  _pushUint8Array(gen, obj) {\n    return gen._pushBuffer(gen, Buffer.from(obj))\n  }\n\n  _pushFloat32Array(gen, obj) {\n    const len = obj.length\n    if (!gen._pushInt(len, MT.ARRAY)) {\n      return false\n    }\n    for (let j = 0; j < len; j++) {\n      if (!gen._pushUInt8(FLOAT) || !gen._pushFloatBE(obj[j])) {\n        return false\n      }\n    }\n    return true\n  }\n\n  _pushFloat64Array(gen, obj) {\n    const len = obj.length\n    if (!gen._pushInt(len, MT.ARRAY)) {\n      return false\n    }\n    for (let j = 0; j < len; j++) {\n      if (!gen._pushUInt8(DOUBLE) || !gen._pushDoubleBE(obj[j])) {\n        return false\n      }\n    }\n    return true\n  }\n\n  removeLoopDetectors(obj) {\n    if (!this.detectLoops || (typeof(obj) !== 'object') || !obj) {\n      return false\n    }\n    const dl = obj[LOOP_DETECT]\n    if (!dl || (dl !== this.detectLoops)) {\n      // ironically, use loop marking to detect loops on removal as well\n      return false\n    }\n    delete obj[LOOP_DETECT]\n    if (Array.isArray(obj)) {\n      for (const i of obj) {\n        this.removeLoopDetectors(i)\n      }\n    } else {\n      for (const k in obj) {\n        this.removeLoopDetectors(obj[k])\n      }\n    }\n    return true\n  }\n\n  _pushObject(obj) {\n    if (!obj) {\n      return this._pushNull(obj)\n    }\n    if (this.detectLoops) {\n      if (obj[LOOP_DETECT] === this.detectLoops) {\n        throw new Error('Loop detected while CBOR encoding')\n      } else {\n        obj[LOOP_DETECT] = this.detectLoops\n      }\n    }\n    const f = obj.encodeCBOR\n    if (typeof f === 'function') {\n      return f.call(obj, this)\n    }\n    for (let i = 0, len1 = this.semanticTypes.length; i < len1; i += 2) {\n      const typ = this.semanticTypes[i]\n      if (obj instanceof typ) {\n        return this.semanticTypes[i + 1].call(obj, this, obj)\n      }\n    }\n    const keys = Object.keys(obj)\n    const cbor_keys = {}\n    if (this.canonical) {\n      // note: this can't be a normal sort, because 'b' needs to sort before\n      // 'aa'\n      keys.sort((a, b) => {\n        // Always strings, so don't bother to pass options.\n        // hold on to the cbor versions, since there's no need\n        // to encode more than once\n        const a_cbor = cbor_keys[a] || (cbor_keys[a] = Encoder.encode(a))\n        const b_cbor = cbor_keys[b] || (cbor_keys[b] = Encoder.encode(b))\n\n        return a_cbor.compare(b_cbor)\n      })\n    }\n    if (!this._pushInt(keys.length, MT.MAP)) {\n      return false\n    }\n    let ck\n    for (let j = 0, len2 = keys.length; j < len2; j++) {\n      const k = keys[j]\n      if (this.canonical && ((ck = cbor_keys[k]))) {\n        if (!this.push(ck)) { // already a Buffer\n          return false\n        }\n      } else {\n        if (!this._pushString(k)) {\n          return false\n        }\n      }\n      if (!this.pushAny(obj[k])) {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  /**\n   * Push any supported type onto the encoded stream\n   *\n   * @param {any} obj\n   * @returns {boolean} true on success\n   */\n  pushAny(obj) {\n    switch (typeof obj) {\n      case 'number':\n        return this._pushNumber(obj)\n      case 'bigint':\n        return this._pushJSBigint(obj)\n      case 'string':\n        return this._pushString(obj)\n      case 'boolean':\n        return this._pushBoolean(obj)\n      case 'undefined':\n        return this._pushUndefined(obj)\n      case 'object':\n        return this._pushObject(obj)\n      case 'symbol':\n        switch (obj) {\n          case SYMS.NULL:\n            return this._pushNull(null)\n          case SYMS.UNDEFINED:\n            return this._pushUndefined(void 0)\n          // TODO: Add pluggable support for other symbols\n          default:\n            throw new Error('Unknown symbol: ' + obj.toString())\n        }\n      default:\n        throw new Error(\n          'Unknown type: ' + typeof obj + ', ' +\n          (!!obj ? obj.toString() : ''))\n    }\n  }\n\n  /* backwards-compat wrapper */\n  _pushAny(obj) {\n    // TODO: write deprecation warning\n    return this.pushAny(obj)\n  }\n\n  _encodeAll(objs) {\n    const bs = new NoFilter({ highWaterMark:this.readableHighWaterMark })\n    this.pipe(bs)\n    for (const o of objs) {\n      this.pushAny(o)\n    }\n    this.end()\n    return bs.read()\n  }\n\n  /**\n   * Encode one or more JavaScript objects, and return a Buffer containing the\n   * CBOR bytes.\n   *\n   * @param {...any} objs - the objects to encode\n   * @returns {Buffer} - the encoded objects\n   */\n  static encode(...objs) {\n    return new Encoder()._encodeAll(objs)\n  }\n\n  /**\n   * Encode one or more JavaScript objects canonically (slower!), and return\n   * a Buffer containing the CBOR bytes.\n   *\n   * @param {...any} objs - the objects to encode\n   * @returns {Buffer} - the encoded objects\n   */\n  static encodeCanonical(...objs) {\n    return new Encoder({canonical: true})._encodeAll(objs)\n  }\n\n  /**\n   * Encode one JavaScript object using the given options.\n   *\n   * @static\n   * @param {any} obj - the object to encode\n   * @param {Object?} options - passed to the Encoder constructor\n   * @returns {Buffer} - the encoded objects\n   */\n  static encodeOne(obj, options) {\n    return new Encoder(options)._encodeAll([obj])\n  }\n\n  /**\n   * Encode one JavaScript object using the given options in a way that\n   * is more resilient to objects being larger than the highWaterMark\n   * number of bytes.  As with the other static encode functions, this \n   * will still use a large amount of memory.  Use a stream-based approach\n   * directly if you need to process large and complicated inputs.\n   *\n   * @param {any} obj - the object to encode\n   * @param {Object?} options - passed to the Encoder constructor\n   */\n  static encodeAsync(obj, options) {\n    return new Promise((resolve, reject) => {\n      const bufs = []\n      const enc = new Encoder(options)\n      enc.on('data', buf => bufs.push(buf))\n      enc.on('error', reject)\n      enc.on('finish', () => resolve(Buffer.concat(bufs)))\n      enc.pushAny(obj)\n      enc.end()\n    })\n  }\n}\n\nmodule.exports = Encoder\n"]},"metadata":{},"sourceType":"script"}