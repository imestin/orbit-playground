{"ast":null,"code":"'use strict';\n\nconst randomBytes = require('libp2p-crypto/src/random-bytes');\n\nconst uint8ArrayToString = require('uint8arrays/to-string');\n\nconst uint8ArrayFromString = require('uint8arrays/from-string');\n\nexports = module.exports;\n/**\n * Generatea random sequence number.\n *\n * @returns {Uint8Array}\n * @private\n */\n\nexports.randomSeqno = () => {\n  return randomBytes(8);\n};\n/**\n * Generate a message id, based on the `from` and `seqno`.\n *\n * @param {string} from\n * @param {Uint8Array} seqno\n * @returns {string}\n * @private\n */\n\n\nexports.msgId = (from, seqno) => {\n  return from + uint8ArrayToString(seqno, 'base16');\n};\n/**\n * Check if any member of the first set is also a member\n * of the second set.\n *\n * @param {Set|Array} a\n * @param {Set|Array} b\n * @returns {boolean}\n * @private\n */\n\n\nexports.anyMatch = (a, b) => {\n  let bHas;\n\n  if (Array.isArray(b)) {\n    bHas = val => b.indexOf(val) > -1;\n  } else {\n    bHas = val => b.has(val);\n  }\n\n  for (const val of a) {\n    if (bHas(val)) {\n      return true;\n    }\n  }\n\n  return false;\n};\n/**\n * Make everything an array.\n *\n * @param {any} maybeArray\n * @returns {Array}\n * @private\n */\n\n\nexports.ensureArray = maybeArray => {\n  if (!Array.isArray(maybeArray)) {\n    return [maybeArray];\n  }\n\n  return maybeArray;\n};\n/**\n * Ensures `message.from` is base58 encoded\n * @param {object} message\n * @param {String} peerId\n * @return {object}\n */\n\n\nexports.normalizeInRpcMessage = (message, peerId) => {\n  const m = Object.assign({}, message);\n\n  if (message.from instanceof Uint8Array) {\n    m.from = uint8ArrayToString(message.from, 'base58btc');\n  }\n\n  if (peerId) {\n    m.receivedFrom = peerId;\n  }\n\n  return m;\n};\n/**\n * @param {object} message\n * @return {object}\n */\n\n\nexports.normalizeOutRpcMessage = message => {\n  const m = Object.assign({}, message);\n\n  if (typeof message.from === 'string' || message.from instanceof String) {\n    m.from = uint8ArrayFromString(message.from, 'base58btc');\n  }\n\n  if (typeof message.data === 'string' || message.data instanceof String) {\n    m.data = uint8ArrayFromString(message.data);\n  }\n\n  return m;\n};","map":{"version":3,"sources":["/home/user/orbit-playground/music-app/node_modules/libp2p-gossipsub/node_modules/libp2p-interfaces/src/pubsub/utils.js"],"names":["randomBytes","require","uint8ArrayToString","uint8ArrayFromString","exports","module","randomSeqno","msgId","from","seqno","anyMatch","a","b","bHas","Array","isArray","val","indexOf","has","ensureArray","maybeArray","normalizeInRpcMessage","message","peerId","m","Object","assign","Uint8Array","receivedFrom","normalizeOutRpcMessage","String","data"],"mappings":"AAAA;;AAEA,MAAMA,WAAW,GAAGC,OAAO,CAAC,gCAAD,CAA3B;;AACA,MAAMC,kBAAkB,GAAGD,OAAO,CAAC,uBAAD,CAAlC;;AACA,MAAME,oBAAoB,GAAGF,OAAO,CAAC,yBAAD,CAApC;;AACAG,OAAO,GAAGC,MAAM,CAACD,OAAjB;AAEA;;;;;;;AAMAA,OAAO,CAACE,WAAR,GAAsB,MAAM;AAC1B,SAAON,WAAW,CAAC,CAAD,CAAlB;AACD,CAFD;AAIA;;;;;;;;;;AAQAI,OAAO,CAACG,KAAR,GAAgB,CAACC,IAAD,EAAOC,KAAP,KAAiB;AAC/B,SAAOD,IAAI,GAAGN,kBAAkB,CAACO,KAAD,EAAQ,QAAR,CAAhC;AACD,CAFD;AAIA;;;;;;;;;;;AASAL,OAAO,CAACM,QAAR,GAAmB,CAACC,CAAD,EAAIC,CAAJ,KAAU;AAC3B,MAAIC,IAAJ;;AACA,MAAIC,KAAK,CAACC,OAAN,CAAcH,CAAd,CAAJ,EAAsB;AACpBC,IAAAA,IAAI,GAAIG,GAAD,IAASJ,CAAC,CAACK,OAAF,CAAUD,GAAV,IAAiB,CAAC,CAAlC;AACD,GAFD,MAEO;AACLH,IAAAA,IAAI,GAAIG,GAAD,IAASJ,CAAC,CAACM,GAAF,CAAMF,GAAN,CAAhB;AACD;;AAED,OAAK,MAAMA,GAAX,IAAkBL,CAAlB,EAAqB;AACnB,QAAIE,IAAI,CAACG,GAAD,CAAR,EAAe;AACb,aAAO,IAAP;AACD;AACF;;AAED,SAAO,KAAP;AACD,CAfD;AAiBA;;;;;;;;;AAOAZ,OAAO,CAACe,WAAR,GAAuBC,UAAD,IAAgB;AACpC,MAAI,CAACN,KAAK,CAACC,OAAN,CAAcK,UAAd,CAAL,EAAgC;AAC9B,WAAO,CAACA,UAAD,CAAP;AACD;;AAED,SAAOA,UAAP;AACD,CAND;AAQA;;;;;;;;AAMAhB,OAAO,CAACiB,qBAAR,GAAgC,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACnD,QAAMC,CAAC,GAAGC,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBJ,OAAlB,CAAV;;AACA,MAAIA,OAAO,CAACd,IAAR,YAAwBmB,UAA5B,EAAwC;AACtCH,IAAAA,CAAC,CAAChB,IAAF,GAASN,kBAAkB,CAACoB,OAAO,CAACd,IAAT,EAAe,WAAf,CAA3B;AACD;;AACD,MAAIe,MAAJ,EAAY;AACVC,IAAAA,CAAC,CAACI,YAAF,GAAiBL,MAAjB;AACD;;AACD,SAAOC,CAAP;AACD,CATD;AAWA;;;;;;AAIApB,OAAO,CAACyB,sBAAR,GAAkCP,OAAD,IAAa;AAC5C,QAAME,CAAC,GAAGC,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBJ,OAAlB,CAAV;;AACA,MAAI,OAAOA,OAAO,CAACd,IAAf,KAAwB,QAAxB,IAAoCc,OAAO,CAACd,IAAR,YAAwBsB,MAAhE,EAAwE;AACtEN,IAAAA,CAAC,CAAChB,IAAF,GAASL,oBAAoB,CAACmB,OAAO,CAACd,IAAT,EAAe,WAAf,CAA7B;AACD;;AACD,MAAI,OAAOc,OAAO,CAACS,IAAf,KAAwB,QAAxB,IAAoCT,OAAO,CAACS,IAAR,YAAwBD,MAAhE,EAAwE;AACtEN,IAAAA,CAAC,CAACO,IAAF,GAAS5B,oBAAoB,CAACmB,OAAO,CAACS,IAAT,CAA7B;AACD;;AACD,SAAOP,CAAP;AACD,CATD","sourcesContent":["'use strict'\n\nconst randomBytes = require('libp2p-crypto/src/random-bytes')\nconst uint8ArrayToString = require('uint8arrays/to-string')\nconst uint8ArrayFromString = require('uint8arrays/from-string')\nexports = module.exports\n\n/**\n * Generatea random sequence number.\n *\n * @returns {Uint8Array}\n * @private\n */\nexports.randomSeqno = () => {\n  return randomBytes(8)\n}\n\n/**\n * Generate a message id, based on the `from` and `seqno`.\n *\n * @param {string} from\n * @param {Uint8Array} seqno\n * @returns {string}\n * @private\n */\nexports.msgId = (from, seqno) => {\n  return from + uint8ArrayToString(seqno, 'base16')\n}\n\n/**\n * Check if any member of the first set is also a member\n * of the second set.\n *\n * @param {Set|Array} a\n * @param {Set|Array} b\n * @returns {boolean}\n * @private\n */\nexports.anyMatch = (a, b) => {\n  let bHas\n  if (Array.isArray(b)) {\n    bHas = (val) => b.indexOf(val) > -1\n  } else {\n    bHas = (val) => b.has(val)\n  }\n\n  for (const val of a) {\n    if (bHas(val)) {\n      return true\n    }\n  }\n\n  return false\n}\n\n/**\n * Make everything an array.\n *\n * @param {any} maybeArray\n * @returns {Array}\n * @private\n */\nexports.ensureArray = (maybeArray) => {\n  if (!Array.isArray(maybeArray)) {\n    return [maybeArray]\n  }\n\n  return maybeArray\n}\n\n/**\n * Ensures `message.from` is base58 encoded\n * @param {object} message\n * @param {String} peerId\n * @return {object}\n */\nexports.normalizeInRpcMessage = (message, peerId) => {\n  const m = Object.assign({}, message)\n  if (message.from instanceof Uint8Array) {\n    m.from = uint8ArrayToString(message.from, 'base58btc')\n  }\n  if (peerId) {\n    m.receivedFrom = peerId\n  }\n  return m\n}\n\n/**\n * @param {object} message\n * @return {object}\n */\nexports.normalizeOutRpcMessage = (message) => {\n  const m = Object.assign({}, message)\n  if (typeof message.from === 'string' || message.from instanceof String) {\n    m.from = uint8ArrayFromString(message.from, 'base58btc')\n  }\n  if (typeof message.data === 'string' || message.data instanceof String) {\n    m.data = uint8ArrayFromString(message.data)\n  }\n  return m\n}\n"]},"metadata":{},"sourceType":"script"}