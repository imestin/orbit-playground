{"ast":null,"code":"/* eslint max-nested-callbacks: [\"error\", 8] */\n'use strict';\n\nconst PinManager = require('./pin-manager');\n\nconst {\n  PinTypes\n} = PinManager;\n\nconst normaliseInput = require('ipfs-core-utils/src/pins/normalise-input');\n\nconst {\n  resolvePath,\n  withTimeoutOption\n} = require('../../utils');\n\nfunction toPin(type, cid, metadata) {\n  const output = {\n    type,\n    cid\n  };\n\n  if (metadata) {\n    output.metadata = metadata;\n  }\n\n  return output;\n}\n\nmodule.exports = ({\n  pinManager,\n  dag\n}) => {\n  return withTimeoutOption(async function* ls(options = {}) {\n    let type = PinTypes.all;\n\n    if (options.type) {\n      type = options.type;\n\n      if (typeof options.type === 'string') {\n        type = options.type.toLowerCase();\n      }\n\n      PinManager.checkPinType(type);\n    } else {\n      options.type = PinTypes.all;\n    }\n\n    if (options.paths) {\n      // check the pinned state of specific hashes\n      let matched = false;\n\n      for await (const {\n        path\n      } of normaliseInput(options.paths)) {\n        const cid = await resolvePath(dag, path);\n        const {\n          reason,\n          pinned,\n          parent,\n          metadata\n        } = await pinManager.isPinnedWithType(cid, type);\n\n        if (!pinned) {\n          throw new Error(`path '${path}' is not pinned`);\n        }\n\n        switch (reason) {\n          case PinTypes.direct:\n          case PinTypes.recursive:\n            matched = true;\n            yield toPin(reason, cid, metadata);\n            break;\n\n          default:\n            matched = true;\n            yield toPin(`${PinTypes.indirect} through ${parent}`, cid, metadata);\n        }\n      }\n\n      if (!matched) {\n        throw new Error('No match found');\n      }\n\n      return;\n    }\n\n    if (type === PinTypes.recursive || type === PinTypes.all) {\n      for await (const {\n        cid,\n        metadata\n      } of pinManager.recursiveKeys()) {\n        yield toPin(PinTypes.recursive, cid, metadata);\n      }\n    }\n\n    if (type === PinTypes.indirect || type === PinTypes.all) {\n      for await (const cid of pinManager.indirectKeys(options)) {\n        yield toPin(PinTypes.indirect, cid);\n      }\n    }\n\n    if (type === PinTypes.direct || type === PinTypes.all) {\n      for await (const {\n        cid,\n        metadata\n      } of pinManager.directKeys()) {\n        yield toPin(PinTypes.direct, cid, metadata);\n      }\n    }\n  });\n};","map":{"version":3,"sources":["/home/user/orbit-playground/music-app/node_modules/ipfs/src/core/components/pin/ls.js"],"names":["PinManager","require","PinTypes","normaliseInput","resolvePath","withTimeoutOption","toPin","type","cid","metadata","output","module","exports","pinManager","dag","ls","options","all","toLowerCase","checkPinType","paths","matched","path","reason","pinned","parent","isPinnedWithType","Error","direct","recursive","indirect","recursiveKeys","indirectKeys","directKeys"],"mappings":"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","sourcesContent":["/* eslint max-nested-callbacks: [\"error\", 8] */\n'use strict'\n\nconst PinManager = require('./pin-manager')\nconst { PinTypes } = PinManager\nconst normaliseInput = require('ipfs-core-utils/src/pins/normalise-input')\nconst { resolvePath, withTimeoutOption } = require('../../utils')\n\nfunction toPin (type, cid, metadata) {\n  const output = {\n    type,\n    cid\n  }\n\n  if (metadata) {\n    output.metadata = metadata\n  }\n\n  return output\n}\n\nmodule.exports = ({ pinManager, dag }) => {\n  return withTimeoutOption(async function * ls (options = {}) {\n    let type = PinTypes.all\n\n    if (options.type) {\n      type = options.type\n      if (typeof options.type === 'string') {\n        type = options.type.toLowerCase()\n      }\n\n      PinManager.checkPinType(type)\n    } else {\n      options.type = PinTypes.all\n    }\n\n    if (options.paths) {\n      // check the pinned state of specific hashes\n      let matched = false\n\n      for await (const { path } of normaliseInput(options.paths)) {\n        const cid = await resolvePath(dag, path)\n        const { reason, pinned, parent, metadata } = await pinManager.isPinnedWithType(cid, type)\n\n        if (!pinned) {\n          throw new Error(`path '${path}' is not pinned`)\n        }\n\n        switch (reason) {\n          case PinTypes.direct:\n          case PinTypes.recursive:\n            matched = true\n            yield toPin(reason, cid, metadata)\n            break\n          default:\n            matched = true\n            yield toPin(`${PinTypes.indirect} through ${parent}`, cid, metadata)\n        }\n      }\n\n      if (!matched) {\n        throw new Error('No match found')\n      }\n\n      return\n    }\n\n    if (type === PinTypes.recursive || type === PinTypes.all) {\n      for await (const { cid, metadata } of pinManager.recursiveKeys()) {\n        yield toPin(PinTypes.recursive, cid, metadata)\n      }\n    }\n\n    if (type === PinTypes.indirect || type === PinTypes.all) {\n      for await (const cid of pinManager.indirectKeys(options)) {\n        yield toPin(PinTypes.indirect, cid)\n      }\n    }\n\n    if (type === PinTypes.direct || type === PinTypes.all) {\n      for await (const { cid, metadata } of pinManager.directKeys()) {\n        yield toPin(PinTypes.direct, cid, metadata)\n      }\n    }\n  })\n}\n"]},"metadata":{},"sourceType":"script"}