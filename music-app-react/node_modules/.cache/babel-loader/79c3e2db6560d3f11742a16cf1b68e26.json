{"ast":null,"code":"'use strict';\n\nconst PeerId = require('peer-id');\n\nconst multiaddr = require('multiaddr');\n\nconst protons = require('protons');\n\nconst {\n  Record\n} = require('libp2p-record');\n\nconst pbm = protons(require('./dht.proto'));\nconst MESSAGE_TYPE = pbm.Message.MessageType;\nconst CONNECTION_TYPE = pbm.Message.ConnectionType;\n/**\n * Represents a single DHT control message.\n */\n\nclass Message {\n  /**\n   * @param {MessageType} type\n   * @param {Uint8Array} key\n   * @param {number} level\n   */\n  constructor(type, key, level) {\n    if (key && !(key instanceof Uint8Array)) {\n      throw new Error('Key must be a Uint8Array');\n    }\n\n    this.type = type;\n    this.key = key;\n    this._clusterLevelRaw = level;\n    this.closerPeers = [];\n    this.providerPeers = [];\n    this.record = null;\n  }\n  /**\n   * @type {number}\n   */\n\n\n  get clusterLevel() {\n    const level = this._clusterLevelRaw - 1;\n\n    if (level < 0) {\n      return 0;\n    }\n\n    return level;\n  }\n\n  set clusterLevel(level) {\n    this._clusterLevelRaw = level;\n  }\n  /**\n   * Encode into protobuf\n   * @returns {Uint8Array}\n   */\n\n\n  serialize() {\n    const obj = {\n      key: this.key,\n      type: this.type,\n      clusterLevelRaw: this._clusterLevelRaw,\n      closerPeers: this.closerPeers.map(toPbPeer),\n      providerPeers: this.providerPeers.map(toPbPeer)\n    };\n\n    if (this.record) {\n      if (this.record instanceof Uint8Array) {\n        obj.record = this.record;\n      } else {\n        obj.record = this.record.serialize();\n      }\n    }\n\n    return pbm.Message.encode(obj);\n  }\n  /**\n   * Decode from protobuf\n   *\n   * @param {Uint8Array} raw\n   * @returns {Message}\n   */\n\n\n  static deserialize(raw) {\n    const dec = pbm.Message.decode(raw);\n    const msg = new Message(dec.type, dec.key, dec.clusterLevelRaw);\n    msg.closerPeers = dec.closerPeers.map(fromPbPeer);\n    msg.providerPeers = dec.providerPeers.map(fromPbPeer);\n\n    if (dec.record) {\n      msg.record = Record.deserialize(dec.record);\n    }\n\n    return msg;\n  }\n\n}\n\nMessage.TYPES = MESSAGE_TYPE;\nMessage.CONNECTION_TYPES = CONNECTION_TYPE;\n\nfunction toPbPeer(peer) {\n  return {\n    id: peer.id.id,\n    addrs: (peer.multiaddrs || []).map(m => m.bytes),\n    connection: CONNECTION_TYPE.CONNECTED\n  };\n}\n\nfunction fromPbPeer(peer) {\n  return {\n    id: new PeerId(peer.id),\n    multiaddrs: peer.addrs.map(a => multiaddr(a))\n  };\n}\n\nmodule.exports = Message;","map":{"version":3,"sources":["/home/user/orbit-playground/music-app/node_modules/libp2p-kad-dht/src/message/index.js"],"names":["PeerId","require","multiaddr","protons","Record","pbm","MESSAGE_TYPE","Message","MessageType","CONNECTION_TYPE","ConnectionType","constructor","type","key","level","Uint8Array","Error","_clusterLevelRaw","closerPeers","providerPeers","record","clusterLevel","serialize","obj","clusterLevelRaw","map","toPbPeer","encode","deserialize","raw","dec","decode","msg","fromPbPeer","TYPES","CONNECTION_TYPES","peer","id","addrs","multiaddrs","m","bytes","connection","CONNECTED","a","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst PeerId = require('peer-id')\nconst multiaddr = require('multiaddr')\nconst protons = require('protons')\nconst { Record } = require('libp2p-record')\nconst pbm = protons(require('./dht.proto'))\n\nconst MESSAGE_TYPE = pbm.Message.MessageType\nconst CONNECTION_TYPE = pbm.Message.ConnectionType\n\n/**\n * Represents a single DHT control message.\n */\nclass Message {\n  /**\n   * @param {MessageType} type\n   * @param {Uint8Array} key\n   * @param {number} level\n   */\n  constructor (type, key, level) {\n    if (key && !(key instanceof Uint8Array)) {\n      throw new Error('Key must be a Uint8Array')\n    }\n\n    this.type = type\n    this.key = key\n    this._clusterLevelRaw = level\n    this.closerPeers = []\n    this.providerPeers = []\n    this.record = null\n  }\n\n  /**\n   * @type {number}\n   */\n  get clusterLevel () {\n    const level = this._clusterLevelRaw - 1\n    if (level < 0) {\n      return 0\n    }\n\n    return level\n  }\n\n  set clusterLevel (level) {\n    this._clusterLevelRaw = level\n  }\n\n  /**\n   * Encode into protobuf\n   * @returns {Uint8Array}\n   */\n  serialize () {\n    const obj = {\n      key: this.key,\n      type: this.type,\n      clusterLevelRaw: this._clusterLevelRaw,\n      closerPeers: this.closerPeers.map(toPbPeer),\n      providerPeers: this.providerPeers.map(toPbPeer)\n    }\n\n    if (this.record) {\n      if (this.record instanceof Uint8Array) {\n        obj.record = this.record\n      } else {\n        obj.record = this.record.serialize()\n      }\n    }\n\n    return pbm.Message.encode(obj)\n  }\n\n  /**\n   * Decode from protobuf\n   *\n   * @param {Uint8Array} raw\n   * @returns {Message}\n   */\n  static deserialize (raw) {\n    const dec = pbm.Message.decode(raw)\n\n    const msg = new Message(dec.type, dec.key, dec.clusterLevelRaw)\n\n    msg.closerPeers = dec.closerPeers.map(fromPbPeer)\n    msg.providerPeers = dec.providerPeers.map(fromPbPeer)\n    if (dec.record) {\n      msg.record = Record.deserialize(dec.record)\n    }\n\n    return msg\n  }\n}\n\nMessage.TYPES = MESSAGE_TYPE\nMessage.CONNECTION_TYPES = CONNECTION_TYPE\n\nfunction toPbPeer (peer) {\n  return {\n    id: peer.id.id,\n    addrs: (peer.multiaddrs || []).map((m) => m.bytes),\n    connection: CONNECTION_TYPE.CONNECTED\n  }\n}\n\nfunction fromPbPeer (peer) {\n  return {\n    id: new PeerId(peer.id),\n    multiaddrs: peer.addrs.map((a) => multiaddr(a))\n  }\n}\n\nmodule.exports = Message\n"]},"metadata":{},"sourceType":"script"}