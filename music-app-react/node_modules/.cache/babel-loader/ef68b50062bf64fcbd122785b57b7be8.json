{"ast":null,"code":"'use strict';\n\nconst PeerId = require('peer-id');\n\nconst {\n  Message\n} = require('./index');\n\nconst uint8ArrayConcat = require('uint8arrays/concat');\n\nconst uint8ArrayFromString = require('uint8arrays/from-string');\n\nconst SignPrefix = uint8ArrayFromString('libp2p-pubsub:');\n/**\n * Signs the provided message with the given `peerId`\n *\n * @param {PeerId} peerId\n * @param {Message} message\n * @returns {Promise<Message>}\n */\n\nasync function signMessage(peerId, message) {\n  // Get the message in bytes, and prepend with the pubsub prefix\n  const bytes = uint8ArrayConcat([SignPrefix, Message.encode(message)]);\n  const signature = await peerId.privKey.sign(bytes);\n  return { ...message,\n    signature: signature,\n    key: peerId.pubKey.bytes\n  };\n}\n/**\n * Verifies the signature of the given message\n * @param {InMessage} message\n * @returns {Promise<Boolean>}\n */\n\n\nasync function verifySignature(message) {\n  // Get message sans the signature\n  const baseMessage = { ...message\n  };\n  delete baseMessage.signature;\n  delete baseMessage.key;\n  baseMessage.from = PeerId.createFromCID(baseMessage.from).toBytes();\n  const bytes = uint8ArrayConcat([SignPrefix, Message.encode(baseMessage)]); // Get the public key\n\n  const pubKey = await messagePublicKey(message); // verify the base message\n\n  return pubKey.verify(bytes, message.signature);\n}\n/**\n * Returns the PublicKey associated with the given message.\n * If no, valid PublicKey can be retrieved an error will be returned.\n *\n * @param {InMessage} message\n * @returns {Promise<PublicKey>}\n */\n\n\nasync function messagePublicKey(message) {\n  // should be available in the from property of the message (peer id)\n  const from = PeerId.createFromCID(message.from);\n\n  if (message.key) {\n    const keyPeerId = await PeerId.createFromPubKey(message.key); // the key belongs to the sender, return the key\n\n    if (keyPeerId.isEqual(from)) return keyPeerId.pubKey; // We couldn't validate pubkey is from the originator, error\n\n    throw new Error('Public Key does not match the originator');\n  } else if (from.pubKey) {\n    return from.pubKey;\n  } else {\n    throw new Error('Could not get the public key from the originator id');\n  }\n}\n\nmodule.exports = {\n  messagePublicKey,\n  signMessage,\n  SignPrefix,\n  verifySignature\n};","map":{"version":3,"sources":["/home/user/orbit-playground/music-app/node_modules/libp2p-gossipsub/node_modules/libp2p-interfaces/src/pubsub/message/sign.js"],"names":["PeerId","require","Message","uint8ArrayConcat","uint8ArrayFromString","SignPrefix","signMessage","peerId","message","bytes","encode","signature","privKey","sign","key","pubKey","verifySignature","baseMessage","from","createFromCID","toBytes","messagePublicKey","verify","keyPeerId","createFromPubKey","isEqual","Error","module","exports"],"mappings":"AAAA;;AAEA,MAAMA,MAAM,GAAGC,OAAO,CAAC,SAAD,CAAtB;;AACA,MAAM;AAAEC,EAAAA;AAAF,IAAcD,OAAO,CAAC,SAAD,CAA3B;;AACA,MAAME,gBAAgB,GAAGF,OAAO,CAAC,oBAAD,CAAhC;;AACA,MAAMG,oBAAoB,GAAGH,OAAO,CAAC,yBAAD,CAApC;;AACA,MAAMI,UAAU,GAAGD,oBAAoB,CAAC,gBAAD,CAAvC;AAEA;;;;;;;;AAOA,eAAeE,WAAf,CAA4BC,MAA5B,EAAoCC,OAApC,EAA6C;AAC3C;AACA,QAAMC,KAAK,GAAGN,gBAAgB,CAAC,CAC7BE,UAD6B,EAE7BH,OAAO,CAACQ,MAAR,CAAeF,OAAf,CAF6B,CAAD,CAA9B;AAKA,QAAMG,SAAS,GAAG,MAAMJ,MAAM,CAACK,OAAP,CAAeC,IAAf,CAAoBJ,KAApB,CAAxB;AAEA,SAAO,EACL,GAAGD,OADE;AAELG,IAAAA,SAAS,EAAEA,SAFN;AAGLG,IAAAA,GAAG,EAAEP,MAAM,CAACQ,MAAP,CAAcN;AAHd,GAAP;AAKD;AAED;;;;;;;AAKA,eAAeO,eAAf,CAAgCR,OAAhC,EAAyC;AACvC;AACA,QAAMS,WAAW,GAAG,EAAE,GAAGT;AAAL,GAApB;AACA,SAAOS,WAAW,CAACN,SAAnB;AACA,SAAOM,WAAW,CAACH,GAAnB;AACAG,EAAAA,WAAW,CAACC,IAAZ,GAAmBlB,MAAM,CAACmB,aAAP,CAAqBF,WAAW,CAACC,IAAjC,EAAuCE,OAAvC,EAAnB;AACA,QAAMX,KAAK,GAAGN,gBAAgB,CAAC,CAC7BE,UAD6B,EAE7BH,OAAO,CAACQ,MAAR,CAAeO,WAAf,CAF6B,CAAD,CAA9B,CANuC,CAWvC;;AACA,QAAMF,MAAM,GAAG,MAAMM,gBAAgB,CAACb,OAAD,CAArC,CAZuC,CAcvC;;AACA,SAAOO,MAAM,CAACO,MAAP,CAAcb,KAAd,EAAqBD,OAAO,CAACG,SAA7B,CAAP;AACD;AAED;;;;;;;;;AAOA,eAAeU,gBAAf,CAAiCb,OAAjC,EAA0C;AACxC;AACA,QAAMU,IAAI,GAAGlB,MAAM,CAACmB,aAAP,CAAqBX,OAAO,CAACU,IAA7B,CAAb;;AAEA,MAAIV,OAAO,CAACM,GAAZ,EAAiB;AACf,UAAMS,SAAS,GAAG,MAAMvB,MAAM,CAACwB,gBAAP,CAAwBhB,OAAO,CAACM,GAAhC,CAAxB,CADe,CAGf;;AACA,QAAIS,SAAS,CAACE,OAAV,CAAkBP,IAAlB,CAAJ,EAA6B,OAAOK,SAAS,CAACR,MAAjB,CAJd,CAKf;;AACA,UAAM,IAAIW,KAAJ,CAAU,0CAAV,CAAN;AACD,GAPD,MAOO,IAAIR,IAAI,CAACH,MAAT,EAAiB;AACtB,WAAOG,IAAI,CAACH,MAAZ;AACD,GAFM,MAEA;AACL,UAAM,IAAIW,KAAJ,CAAU,qDAAV,CAAN;AACD;AACF;;AAEDC,MAAM,CAACC,OAAP,GAAiB;AACfP,EAAAA,gBADe;AAEff,EAAAA,WAFe;AAGfD,EAAAA,UAHe;AAIfW,EAAAA;AAJe,CAAjB","sourcesContent":["'use strict'\n\nconst PeerId = require('peer-id')\nconst { Message } = require('./index')\nconst uint8ArrayConcat = require('uint8arrays/concat')\nconst uint8ArrayFromString = require('uint8arrays/from-string')\nconst SignPrefix = uint8ArrayFromString('libp2p-pubsub:')\n\n/**\n * Signs the provided message with the given `peerId`\n *\n * @param {PeerId} peerId\n * @param {Message} message\n * @returns {Promise<Message>}\n */\nasync function signMessage (peerId, message) {\n  // Get the message in bytes, and prepend with the pubsub prefix\n  const bytes = uint8ArrayConcat([\n    SignPrefix,\n    Message.encode(message)\n  ])\n\n  const signature = await peerId.privKey.sign(bytes)\n\n  return {\n    ...message,\n    signature: signature,\n    key: peerId.pubKey.bytes\n  }\n}\n\n/**\n * Verifies the signature of the given message\n * @param {InMessage} message\n * @returns {Promise<Boolean>}\n */\nasync function verifySignature (message) {\n  // Get message sans the signature\n  const baseMessage = { ...message }\n  delete baseMessage.signature\n  delete baseMessage.key\n  baseMessage.from = PeerId.createFromCID(baseMessage.from).toBytes()\n  const bytes = uint8ArrayConcat([\n    SignPrefix,\n    Message.encode(baseMessage)\n  ])\n\n  // Get the public key\n  const pubKey = await messagePublicKey(message)\n\n  // verify the base message\n  return pubKey.verify(bytes, message.signature)\n}\n\n/**\n * Returns the PublicKey associated with the given message.\n * If no, valid PublicKey can be retrieved an error will be returned.\n *\n * @param {InMessage} message\n * @returns {Promise<PublicKey>}\n */\nasync function messagePublicKey (message) {\n  // should be available in the from property of the message (peer id)\n  const from = PeerId.createFromCID(message.from)\n\n  if (message.key) {\n    const keyPeerId = await PeerId.createFromPubKey(message.key)\n\n    // the key belongs to the sender, return the key\n    if (keyPeerId.isEqual(from)) return keyPeerId.pubKey\n    // We couldn't validate pubkey is from the originator, error\n    throw new Error('Public Key does not match the originator')\n  } else if (from.pubKey) {\n    return from.pubKey\n  } else {\n    throw new Error('Could not get the public key from the originator id')\n  }\n}\n\nmodule.exports = {\n  messagePublicKey,\n  signMessage,\n  SignPrefix,\n  verifySignature\n}\n"]},"metadata":{},"sourceType":"script"}