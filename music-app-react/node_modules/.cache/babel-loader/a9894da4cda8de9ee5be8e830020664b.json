{"ast":null,"code":"'use strict';\n\nconst BufferList = require('bl/BufferList');\n\nconst {\n  InvalidCryptoTransmissionError\n} = require('libp2p-interfaces/src/crypto/errors');\n\nconst uint8ArrayToString = require('uint8arrays/to-string');\n\nconst uint8ArrayEquals = require('uint8arrays/equals');\n\nexports.createBoxStream = (cipher, mac) => {\n  return async function* (source) {\n    for await (const chunk of source) {\n      const data = await cipher.encrypt(BufferList.isBufferList(chunk) ? chunk.slice() : chunk);\n      const digest = await mac.digest(data);\n      yield new BufferList([data, digest]);\n    }\n  };\n};\n\nexports.createUnboxStream = (decipher, mac) => {\n  return async function* (source) {\n    for await (const chunk of source) {\n      const l = chunk.length;\n      const macSize = mac.length;\n\n      if (l < macSize) {\n        throw new InvalidCryptoTransmissionError(`buffer (${l}) shorter than MAC size (${macSize})`);\n      }\n\n      const mark = l - macSize;\n      const data = chunk.slice(0, mark);\n      const macd = chunk.slice(mark);\n      const expected = await mac.digest(data);\n\n      if (!uint8ArrayEquals(macd, expected)) {\n        throw new InvalidCryptoTransmissionError(`MAC Invalid: ${uint8ArrayToString(macd, 'base16')} != ${uint8ArrayToString(expected, 'base16')}`);\n      }\n\n      const decrypted = await decipher.decrypt(data);\n      yield decrypted;\n    }\n  };\n};","map":{"version":3,"sources":["/home/user/orbit-playground/music-app/node_modules/libp2p-secio/src/etm.js"],"names":["BufferList","require","InvalidCryptoTransmissionError","uint8ArrayToString","uint8ArrayEquals","exports","createBoxStream","cipher","mac","source","chunk","data","encrypt","isBufferList","slice","digest","createUnboxStream","decipher","l","length","macSize","mark","macd","expected","decrypted","decrypt"],"mappings":"AAAA;;AAEA,MAAMA,UAAU,GAAGC,OAAO,CAAC,eAAD,CAA1B;;AACA,MAAM;AAAEC,EAAAA;AAAF,IAAqCD,OAAO,CAAC,qCAAD,CAAlD;;AACA,MAAME,kBAAkB,GAAGF,OAAO,CAAC,uBAAD,CAAlC;;AACA,MAAMG,gBAAgB,GAAGH,OAAO,CAAC,oBAAD,CAAhC;;AAEAI,OAAO,CAACC,eAAR,GAA0B,CAACC,MAAD,EAASC,GAAT,KAAiB;AACzC,SAAO,iBAAkBC,MAAlB,EAA0B;AAC/B,eAAW,MAAMC,KAAjB,IAA0BD,MAA1B,EAAkC;AAChC,YAAME,IAAI,GAAG,MAAMJ,MAAM,CAACK,OAAP,CAAeZ,UAAU,CAACa,YAAX,CAAwBH,KAAxB,IAAiCA,KAAK,CAACI,KAAN,EAAjC,GAAiDJ,KAAhE,CAAnB;AACA,YAAMK,MAAM,GAAG,MAAMP,GAAG,CAACO,MAAJ,CAAWJ,IAAX,CAArB;AACA,YAAM,IAAIX,UAAJ,CAAe,CAACW,IAAD,EAAOI,MAAP,CAAf,CAAN;AACD;AACF,GAND;AAOD,CARD;;AAUAV,OAAO,CAACW,iBAAR,GAA4B,CAACC,QAAD,EAAWT,GAAX,KAAmB;AAC7C,SAAO,iBAAkBC,MAAlB,EAA0B;AAC/B,eAAW,MAAMC,KAAjB,IAA0BD,MAA1B,EAAkC;AAChC,YAAMS,CAAC,GAAGR,KAAK,CAACS,MAAhB;AACA,YAAMC,OAAO,GAAGZ,GAAG,CAACW,MAApB;;AAEA,UAAID,CAAC,GAAGE,OAAR,EAAiB;AACf,cAAM,IAAIlB,8BAAJ,CAAoC,WAAUgB,CAAE,4BAA2BE,OAAQ,GAAnF,CAAN;AACD;;AAED,YAAMC,IAAI,GAAGH,CAAC,GAAGE,OAAjB;AACA,YAAMT,IAAI,GAAGD,KAAK,CAACI,KAAN,CAAY,CAAZ,EAAeO,IAAf,CAAb;AACA,YAAMC,IAAI,GAAGZ,KAAK,CAACI,KAAN,CAAYO,IAAZ,CAAb;AAEA,YAAME,QAAQ,GAAG,MAAMf,GAAG,CAACO,MAAJ,CAAWJ,IAAX,CAAvB;;AAEA,UAAI,CAACP,gBAAgB,CAACkB,IAAD,EAAOC,QAAP,CAArB,EAAuC;AACrC,cAAM,IAAIrB,8BAAJ,CAAoC,gBAAeC,kBAAkB,CAACmB,IAAD,EAAO,QAAP,CAAiB,OAAMnB,kBAAkB,CAACoB,QAAD,EAAW,QAAX,CAAqB,EAAnI,CAAN;AACD;;AAED,YAAMC,SAAS,GAAG,MAAMP,QAAQ,CAACQ,OAAT,CAAiBd,IAAjB,CAAxB;AAEA,YAAMa,SAAN;AACD;AACF,GAvBD;AAwBD,CAzBD","sourcesContent":["'use strict'\n\nconst BufferList = require('bl/BufferList')\nconst { InvalidCryptoTransmissionError } = require('libp2p-interfaces/src/crypto/errors')\nconst uint8ArrayToString = require('uint8arrays/to-string')\nconst uint8ArrayEquals = require('uint8arrays/equals')\n\nexports.createBoxStream = (cipher, mac) => {\n  return async function * (source) {\n    for await (const chunk of source) {\n      const data = await cipher.encrypt(BufferList.isBufferList(chunk) ? chunk.slice() : chunk)\n      const digest = await mac.digest(data)\n      yield new BufferList([data, digest])\n    }\n  }\n}\n\nexports.createUnboxStream = (decipher, mac) => {\n  return async function * (source) {\n    for await (const chunk of source) {\n      const l = chunk.length\n      const macSize = mac.length\n\n      if (l < macSize) {\n        throw new InvalidCryptoTransmissionError(`buffer (${l}) shorter than MAC size (${macSize})`)\n      }\n\n      const mark = l - macSize\n      const data = chunk.slice(0, mark)\n      const macd = chunk.slice(mark)\n\n      const expected = await mac.digest(data)\n\n      if (!uint8ArrayEquals(macd, expected)) {\n        throw new InvalidCryptoTransmissionError(`MAC Invalid: ${uint8ArrayToString(macd, 'base16')} != ${uint8ArrayToString(expected, 'base16')}`)\n      }\n\n      const decrypted = await decipher.decrypt(data)\n\n      yield decrypted\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}