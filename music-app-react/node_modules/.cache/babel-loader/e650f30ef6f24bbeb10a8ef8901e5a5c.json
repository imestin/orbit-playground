{"ast":null,"code":"'use strict';\n\nconst ipns = require('ipns');\n\nconst {\n  toB58String\n} = require('multihashing-async').multihash;\n\nconst PubsubDatastore = require('datastore-pubsub');\n\nconst uint8ArrayToString = require('uint8arrays/to-string');\n\nconst uint8ArrayFromString = require('uint8arrays/from-string');\n\nconst withIs = require('class-is');\n\nconst errcode = require('err-code');\n\nconst debug = require('debug');\n\nconst log = debug('ipfs:ipns:pubsub');\nlog.error = debug('ipfs:ipns:pubsub:error'); // Pubsub datastore aims to manage the pubsub subscriptions for IPNS\n\nclass IpnsPubsubDatastore {\n  constructor(pubsub, localDatastore, peerId) {\n    this._pubsub = pubsub;\n    this._subscriptions = {}; // Bind _handleSubscriptionKey function, which is called by PubsubDatastore.\n\n    this._handleSubscriptionKey = this._handleSubscriptionKey.bind(this);\n    this._pubsubDs = new PubsubDatastore(pubsub, localDatastore, peerId, ipns.validator, this._handleSubscriptionKey);\n  }\n  /**\n   * Put a value to the pubsub datastore indexed by the received key properly encoded.\n   * @param {Buffer} key identifier of the value.\n   * @param {Buffer} value value to be stored.\n   * @param {function(Error)} callback\n   * @returns {void}\n   */\n\n\n  async put(key, value) {\n    // eslint-disable-line require-await\n    return this._pubsubDs.put(key, value);\n  }\n  /**\n   * Get a value from the pubsub datastore indexed by the received key properly encoded.\n   * Also, the identifier topic is subscribed to and the pubsub datastore records will be\n   * updated once new publishes occur.\n   * @param {Buffer} key identifier of the value to be obtained.\n   * @param {function(Error, Buffer)} callback\n   * @returns {void}\n   */\n\n\n  async get(key) {\n    let res;\n    let err;\n\n    try {\n      res = await this._pubsubDs.get(key);\n    } catch (e) {\n      err = e;\n    } // Add topic subscribed\n\n\n    const ns = key.slice(0, ipns.namespaceLength);\n\n    if (uint8ArrayToString(ns) === ipns.namespace) {\n      const stringifiedTopic = toB58String(key);\n      const id = toB58String(key.slice(ipns.namespaceLength));\n      this._subscriptions[stringifiedTopic] = id;\n      log(`subscribed to pubsub topic ${stringifiedTopic}, id ${id}`);\n    } // If no data was obtained, after storing the subscription, return the error.\n\n\n    if (err) {\n      throw err;\n    }\n\n    return res;\n  } // Modify subscription key to have a proper encoding\n\n\n  _handleSubscriptionKey(key) {\n    if (key instanceof Uint8Array) {\n      key = uint8ArrayToString(key, 'base58btc');\n    }\n\n    const subscriber = this._subscriptions[key];\n\n    if (!subscriber) {\n      throw errcode(new Error(`key ${key} does not correspond to a subscription`), 'ERR_INVALID_KEY');\n    }\n\n    let keys;\n\n    try {\n      keys = ipns.getIdKeys(uint8ArrayFromString(subscriber, 'base58btc'));\n    } catch (err) {\n      log.error(err);\n      throw err;\n    }\n\n    return keys.routingKey.uint8Array();\n  }\n  /**\n   * Get pubsub subscriptions related to ipns.\n   * @param {function(Error, Object)} callback\n   * @returns {Array<Object>}\n   */\n\n\n  getSubscriptions() {\n    const subscriptions = Object.values(this._subscriptions).filter(Boolean);\n    return subscriptions.map(sub => `${ipns.namespace}${sub}`);\n  }\n  /**\n   * Cancel pubsub subscriptions related to ipns.\n   * @param {String} name ipns path to cancel the pubsub subscription.\n   * @param {function(Error, Object)} callback\n   * @returns {void}\n   */\n\n\n  async cancel(name) {\n    // eslint-disable-line require-await\n    if (typeof name !== 'string') {\n      throw errcode(new Error('invalid subscription name'), 'ERR_INVALID_SUBSCRIPTION_NAME');\n    } // Trim /ipns/ prefix from the name\n\n\n    if (name.startsWith(ipns.namespace)) {\n      name = name.substring(ipns.namespaceLength);\n    }\n\n    const stringifiedTopic = Object.keys(this._subscriptions).find(key => this._subscriptions[key] === name); // Not found topic\n\n    if (!stringifiedTopic) {\n      return {\n        canceled: false\n      };\n    } // Unsubscribe topic\n\n\n    const bufTopic = uint8ArrayFromString(stringifiedTopic);\n\n    this._pubsubDs.unsubscribe(bufTopic);\n\n    this._subscriptions[stringifiedTopic] = undefined;\n    log(`unsubscribed pubsub ${stringifiedTopic}: ${name}`);\n    return {\n      canceled: true\n    };\n  }\n\n}\n\nexports = module.exports = withIs(IpnsPubsubDatastore, {\n  className: 'IpnsPubsubDatastore',\n  symbolName: '@js-ipfs/ipns/IpnsPubsubDatastore'\n});","map":{"version":3,"sources":["/home/user/orbit-playground/music-app/node_modules/ipfs/src/core/ipns/routing/pubsub-datastore.js"],"names":["ipns","require","toB58String","multihash","PubsubDatastore","uint8ArrayToString","uint8ArrayFromString","withIs","errcode","debug","log","error","IpnsPubsubDatastore","constructor","pubsub","localDatastore","peerId","_pubsub","_subscriptions","_handleSubscriptionKey","bind","_pubsubDs","validator","put","key","value","get","res","err","e","ns","slice","namespaceLength","namespace","stringifiedTopic","id","Uint8Array","subscriber","Error","keys","getIdKeys","routingKey","uint8Array","getSubscriptions","subscriptions","Object","values","filter","Boolean","map","sub","cancel","name","startsWith","substring","find","canceled","bufTopic","unsubscribe","undefined","exports","module","className","symbolName"],"mappings":"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","sourcesContent":["'use strict'\n\nconst ipns = require('ipns')\nconst { toB58String } = require('multihashing-async').multihash\nconst PubsubDatastore = require('datastore-pubsub')\nconst uint8ArrayToString = require('uint8arrays/to-string')\nconst uint8ArrayFromString = require('uint8arrays/from-string')\n\nconst withIs = require('class-is')\n\nconst errcode = require('err-code')\nconst debug = require('debug')\nconst log = debug('ipfs:ipns:pubsub')\nlog.error = debug('ipfs:ipns:pubsub:error')\n\n// Pubsub datastore aims to manage the pubsub subscriptions for IPNS\nclass IpnsPubsubDatastore {\n  constructor (pubsub, localDatastore, peerId) {\n    this._pubsub = pubsub\n    this._subscriptions = {}\n\n    // Bind _handleSubscriptionKey function, which is called by PubsubDatastore.\n    this._handleSubscriptionKey = this._handleSubscriptionKey.bind(this)\n    this._pubsubDs = new PubsubDatastore(pubsub, localDatastore, peerId, ipns.validator, this._handleSubscriptionKey)\n  }\n\n  /**\n   * Put a value to the pubsub datastore indexed by the received key properly encoded.\n   * @param {Buffer} key identifier of the value.\n   * @param {Buffer} value value to be stored.\n   * @param {function(Error)} callback\n   * @returns {void}\n   */\n  async put (key, value) { // eslint-disable-line require-await\n    return this._pubsubDs.put(key, value)\n  }\n\n  /**\n   * Get a value from the pubsub datastore indexed by the received key properly encoded.\n   * Also, the identifier topic is subscribed to and the pubsub datastore records will be\n   * updated once new publishes occur.\n   * @param {Buffer} key identifier of the value to be obtained.\n   * @param {function(Error, Buffer)} callback\n   * @returns {void}\n   */\n  async get (key) {\n    let res\n    let err\n\n    try {\n      res = await this._pubsubDs.get(key)\n    } catch (e) {\n      err = e\n    }\n\n    // Add topic subscribed\n    const ns = key.slice(0, ipns.namespaceLength)\n\n    if (uint8ArrayToString(ns) === ipns.namespace) {\n      const stringifiedTopic = toB58String(key)\n      const id = toB58String(key.slice(ipns.namespaceLength))\n\n      this._subscriptions[stringifiedTopic] = id\n\n      log(`subscribed to pubsub topic ${stringifiedTopic}, id ${id}`)\n    }\n\n    // If no data was obtained, after storing the subscription, return the error.\n    if (err) {\n      throw err\n    }\n\n    return res\n  }\n\n  // Modify subscription key to have a proper encoding\n  _handleSubscriptionKey (key) {\n    if (key instanceof Uint8Array) {\n      key = uint8ArrayToString(key, 'base58btc')\n    }\n\n    const subscriber = this._subscriptions[key]\n\n    if (!subscriber) {\n      throw errcode(new Error(`key ${key} does not correspond to a subscription`), 'ERR_INVALID_KEY')\n    }\n\n    let keys\n    try {\n      keys = ipns.getIdKeys(uint8ArrayFromString(subscriber, 'base58btc'))\n    } catch (err) {\n      log.error(err)\n      throw err\n    }\n\n    return keys.routingKey.uint8Array()\n  }\n\n  /**\n   * Get pubsub subscriptions related to ipns.\n   * @param {function(Error, Object)} callback\n   * @returns {Array<Object>}\n   */\n  getSubscriptions () {\n    const subscriptions = Object.values(this._subscriptions).filter(Boolean)\n\n    return subscriptions.map((sub) => `${ipns.namespace}${sub}`)\n  }\n\n  /**\n   * Cancel pubsub subscriptions related to ipns.\n   * @param {String} name ipns path to cancel the pubsub subscription.\n   * @param {function(Error, Object)} callback\n   * @returns {void}\n   */\n  async cancel (name) { // eslint-disable-line require-await\n    if (typeof name !== 'string') {\n      throw errcode(new Error('invalid subscription name'), 'ERR_INVALID_SUBSCRIPTION_NAME')\n    }\n\n    // Trim /ipns/ prefix from the name\n    if (name.startsWith(ipns.namespace)) {\n      name = name.substring(ipns.namespaceLength)\n    }\n\n    const stringifiedTopic = Object.keys(this._subscriptions).find((key) => this._subscriptions[key] === name)\n\n    // Not found topic\n    if (!stringifiedTopic) {\n      return {\n        canceled: false\n      }\n    }\n\n    // Unsubscribe topic\n    const bufTopic = uint8ArrayFromString(stringifiedTopic)\n\n    this._pubsubDs.unsubscribe(bufTopic)\n\n    this._subscriptions[stringifiedTopic] = undefined\n    log(`unsubscribed pubsub ${stringifiedTopic}: ${name}`)\n\n    return {\n      canceled: true\n    }\n  }\n}\n\nexports = module.exports = withIs(IpnsPubsubDatastore, { className: 'IpnsPubsubDatastore', symbolName: '@js-ipfs/ipns/IpnsPubsubDatastore' })\n"]},"metadata":{},"sourceType":"script"}