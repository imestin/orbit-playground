{"ast":null,"code":"'use strict';\n\nconst core = require('datastore-core');\n\nconst ShardingStore = core.ShardingDatastore;\n\nconst Block = require('ipld-block');\n\nconst {\n  cidToKey,\n  keyToCid\n} = require('./blockstore-utils');\n\nconst map = require('it-map');\n\nconst drain = require('it-drain');\n\nconst pushable = require('it-pushable');\n\nmodule.exports = async (filestore, options) => {\n  const store = await maybeWithSharding(filestore, options);\n  return createBaseStore(store);\n};\n\nfunction maybeWithSharding(filestore, options) {\n  if (options.sharding) {\n    const shard = new core.shard.NextToLast(2);\n    return ShardingStore.createOrOpen(filestore, shard);\n  }\n\n  return filestore;\n}\n\nfunction createBaseStore(store) {\n  return {\n    /**\n     * Query the store\n     *\n     * @param {Object} query\n     * @param {Object} options\n     * @returns {AsyncIterator<Block|CID>}\n     */\n    async *query(query, options) {\n      for await (const {\n        key,\n        value\n      } of store.query(query, options)) {\n        if (query.keysOnly) {\n          yield keyToCid(key);\n          continue;\n        }\n\n        yield new Block(value, keyToCid(key));\n      }\n    },\n\n    /**\n     * Get a single block by CID\n     *\n     * @param {CID} cid\n     * @param {Object} options\n     * @returns {Promise<Block>}\n     */\n    async get(cid, options) {\n      const key = cidToKey(cid);\n      const blockData = await store.get(key, options);\n      return new Block(blockData, cid);\n    },\n\n    /**\n     * Like get, but for more\n     *\n     * @param {AsyncIterator<CID>} cids\n     * @param {Object} options\n     * @returns {AsyncIterator<Block>}\n     */\n    async *getMany(cids, options) {\n      for await (const cid of cids) {\n        yield this.get(cid, options);\n      }\n    },\n\n    /**\n     * Write a single block to the store\n     *\n     * @param {Block} block\n     * @param {Object} options\n     * @returns {Promise<Block>}\n     */\n    async put(block, options) {\n      if (!Block.isBlock(block)) {\n        throw new Error('invalid block');\n      }\n\n      const key = cidToKey(block.cid);\n      const exists = await store.has(key, options);\n\n      if (!exists) {\n        await store.put(key, block.data, options);\n      }\n\n      return block;\n    },\n\n    /**\n     * Like put, but for more\n     *\n     * @param {AsyncIterable<Block>|Iterable<Block>} blocks\n     * @param {Object} options\n     * @returns {AsyncIterable<Block>}\n     */\n    async *putMany(blocks, options) {\n      // eslint-disable-line require-await\n      // we cannot simply chain to `store.putMany` because we convert a CID into\n      // a key based on the multihash only, so we lose the version & codec and\n      // cannot give the user back the CID they used to create the block, so yield\n      // to `store.putMany` but return the actual block the user passed in.\n      //\n      // nb. we want to use `store.putMany` here so bitswap can control batching\n      // up block HAVEs to send to the network - if we use multiple `store.put`s\n      // it will not be able to guess we are about to `store.put` more blocks\n      const output = pushable(); // process.nextTick runs on the microtask queue, setImmediate runs on the next\n      // event loop iteration so is slower. Use process.nextTick if it is available.\n\n      const runner = process && process.nextTick ? process.nextTick : setImmediate;\n      runner(async () => {\n        try {\n          await drain(store.putMany(async function* () {\n            for await (const block of blocks) {\n              const key = cidToKey(block.cid);\n              const exists = await store.has(key, options);\n\n              if (!exists) {\n                yield {\n                  key,\n                  value: block.data\n                };\n              } // there is an assumption here that after the yield has completed\n              // the underlying datastore has finished writing the block\n\n\n              output.push(block);\n            }\n          }()));\n          output.end();\n        } catch (err) {\n          output.end(err);\n        }\n      });\n      yield* output;\n    },\n\n    /**\n     * Does the store contain block with this CID?\n     *\n     * @param {CID} cid\n     * @param {Object} options\n     * @returns {Promise<bool>}\n     */\n    async has(cid, options) {\n      // eslint-disable-line require-await\n      return store.has(cidToKey(cid), options);\n    },\n\n    /**\n     * Delete a block from the store\n     *\n     * @param {CID} cid\n     * @param {Object} options\n     * @returns {Promise<void>}\n     */\n    async delete(cid, options) {\n      // eslint-disable-line require-await\n      return store.delete(cidToKey(cid), options);\n    },\n\n    /**\n     * Delete a block from the store\n     *\n     * @param {AsyncIterable<CID>} cids\n     * @param {Object} options\n     * @returns {Promise<void>}\n     */\n    async *deleteMany(cids, options) {\n      // eslint-disable-line require-await\n      yield* store.deleteMany(map(cids, cid => cidToKey(cid)), options);\n    },\n\n    /**\n     * Close the store\n     *\n     * @returns {Promise<void>}\n     */\n    async close() {\n      // eslint-disable-line require-await\n      return store.close();\n    }\n\n  };\n}","map":{"version":3,"sources":["/home/user/orbit-playground/music-app/node_modules/ipfs-repo/src/blockstore.js"],"names":["core","require","ShardingStore","ShardingDatastore","Block","cidToKey","keyToCid","map","drain","pushable","module","exports","filestore","options","store","maybeWithSharding","createBaseStore","sharding","shard","NextToLast","createOrOpen","query","key","value","keysOnly","get","cid","blockData","getMany","cids","put","block","isBlock","Error","exists","has","data","putMany","blocks","output","runner","process","nextTick","setImmediate","push","end","err","delete","deleteMany","close"],"mappings":"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","sourcesContent":["'use strict'\n\nconst core = require('datastore-core')\nconst ShardingStore = core.ShardingDatastore\nconst Block = require('ipld-block')\nconst { cidToKey, keyToCid } = require('./blockstore-utils')\nconst map = require('it-map')\nconst drain = require('it-drain')\nconst pushable = require('it-pushable')\n\nmodule.exports = async (filestore, options) => {\n  const store = await maybeWithSharding(filestore, options)\n  return createBaseStore(store)\n}\n\nfunction maybeWithSharding (filestore, options) {\n  if (options.sharding) {\n    const shard = new core.shard.NextToLast(2)\n    return ShardingStore.createOrOpen(filestore, shard)\n  }\n  return filestore\n}\n\nfunction createBaseStore (store) {\n  return {\n    /**\n     * Query the store\n     *\n     * @param {Object} query\n     * @param {Object} options\n     * @returns {AsyncIterator<Block|CID>}\n     */\n    async * query (query, options) {\n      for await (const { key, value } of store.query(query, options)) {\n        if (query.keysOnly) {\n          yield keyToCid(key)\n          continue\n        }\n\n        yield new Block(value, keyToCid(key))\n      }\n    },\n\n    /**\n     * Get a single block by CID\n     *\n     * @param {CID} cid\n     * @param {Object} options\n     * @returns {Promise<Block>}\n     */\n    async get (cid, options) {\n      const key = cidToKey(cid)\n      const blockData = await store.get(key, options)\n\n      return new Block(blockData, cid)\n    },\n\n    /**\n     * Like get, but for more\n     *\n     * @param {AsyncIterator<CID>} cids\n     * @param {Object} options\n     * @returns {AsyncIterator<Block>}\n     */\n    async * getMany (cids, options) {\n      for await (const cid of cids) {\n        yield this.get(cid, options)\n      }\n    },\n\n    /**\n     * Write a single block to the store\n     *\n     * @param {Block} block\n     * @param {Object} options\n     * @returns {Promise<Block>}\n     */\n    async put (block, options) {\n      if (!Block.isBlock(block)) {\n        throw new Error('invalid block')\n      }\n\n      const key = cidToKey(block.cid)\n      const exists = await store.has(key, options)\n\n      if (!exists) {\n        await store.put(key, block.data, options)\n      }\n\n      return block\n    },\n\n    /**\n     * Like put, but for more\n     *\n     * @param {AsyncIterable<Block>|Iterable<Block>} blocks\n     * @param {Object} options\n     * @returns {AsyncIterable<Block>}\n     */\n    async * putMany (blocks, options) { // eslint-disable-line require-await\n      // we cannot simply chain to `store.putMany` because we convert a CID into\n      // a key based on the multihash only, so we lose the version & codec and\n      // cannot give the user back the CID they used to create the block, so yield\n      // to `store.putMany` but return the actual block the user passed in.\n      //\n      // nb. we want to use `store.putMany` here so bitswap can control batching\n      // up block HAVEs to send to the network - if we use multiple `store.put`s\n      // it will not be able to guess we are about to `store.put` more blocks\n      const output = pushable()\n\n      // process.nextTick runs on the microtask queue, setImmediate runs on the next\n      // event loop iteration so is slower. Use process.nextTick if it is available.\n      const runner = process && process.nextTick ? process.nextTick : setImmediate\n\n      runner(async () => {\n        try {\n          await drain(store.putMany(async function * () {\n            for await (const block of blocks) {\n              const key = cidToKey(block.cid)\n              const exists = await store.has(key, options)\n\n              if (!exists) {\n                yield { key, value: block.data }\n              }\n\n              // there is an assumption here that after the yield has completed\n              // the underlying datastore has finished writing the block\n              output.push(block)\n            }\n          }()))\n\n          output.end()\n        } catch (err) {\n          output.end(err)\n        }\n      })\n\n      yield * output\n    },\n\n    /**\n     * Does the store contain block with this CID?\n     *\n     * @param {CID} cid\n     * @param {Object} options\n     * @returns {Promise<bool>}\n     */\n    async has (cid, options) { // eslint-disable-line require-await\n      return store.has(cidToKey(cid), options)\n    },\n\n    /**\n     * Delete a block from the store\n     *\n     * @param {CID} cid\n     * @param {Object} options\n     * @returns {Promise<void>}\n     */\n    async delete (cid, options) { // eslint-disable-line require-await\n      return store.delete(cidToKey(cid), options)\n    },\n\n    /**\n     * Delete a block from the store\n     *\n     * @param {AsyncIterable<CID>} cids\n     * @param {Object} options\n     * @returns {Promise<void>}\n     */\n    async * deleteMany (cids, options) { // eslint-disable-line require-await\n      yield * store.deleteMany(map(cids, cid => cidToKey(cid)), options)\n    },\n\n    /**\n     * Close the store\n     *\n     * @returns {Promise<void>}\n     */\n    async close () { // eslint-disable-line require-await\n      return store.close()\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}