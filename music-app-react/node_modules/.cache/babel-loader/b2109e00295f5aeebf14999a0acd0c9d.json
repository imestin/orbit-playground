{"ast":null,"code":"'use strict';\n\nconst secp256k1 = require('secp256k1');\n\nconst sha = require('multihashing-async/src/sha');\n\nconst HASH_ALGORITHM = 'sha2-256';\n\nmodule.exports = randomBytes => {\n  const privateKeyLength = 32;\n\n  function generateKey() {\n    let privateKey;\n\n    do {\n      privateKey = randomBytes(32);\n    } while (!secp256k1.privateKeyVerify(privateKey));\n\n    return privateKey;\n  }\n\n  async function hashAndSign(key, msg) {\n    const digest = await sha.digest(msg, HASH_ALGORITHM);\n    const sig = secp256k1.ecdsaSign(digest, key);\n    return secp256k1.signatureExport(sig.signature);\n  }\n\n  async function hashAndVerify(key, sig, msg) {\n    const digest = await sha.digest(msg, HASH_ALGORITHM);\n    sig = secp256k1.signatureImport(sig);\n    return secp256k1.ecdsaVerify(sig, digest, key);\n  }\n\n  function compressPublicKey(key) {\n    if (!secp256k1.publicKeyVerify(key)) {\n      throw new Error('Invalid public key');\n    }\n\n    return secp256k1.publicKeyConvert(key, true);\n  }\n\n  function decompressPublicKey(key) {\n    return secp256k1.publicKeyConvert(key, false);\n  }\n\n  function validatePrivateKey(key) {\n    if (!secp256k1.privateKeyVerify(key)) {\n      throw new Error('Invalid private key');\n    }\n  }\n\n  function validatePublicKey(key) {\n    if (!secp256k1.publicKeyVerify(key)) {\n      throw new Error('Invalid public key');\n    }\n  }\n\n  function computePublicKey(privateKey) {\n    validatePrivateKey(privateKey);\n    return secp256k1.publicKeyCreate(privateKey);\n  }\n\n  return {\n    generateKey,\n    privateKeyLength,\n    hashAndSign,\n    hashAndVerify,\n    compressPublicKey,\n    decompressPublicKey,\n    validatePrivateKey,\n    validatePublicKey,\n    computePublicKey\n  };\n};","map":{"version":3,"sources":["/home/user/orbit-playground/music-app/node_modules/ipns/node_modules/libp2p-crypto/src/keys/secp256k1.js"],"names":["secp256k1","require","sha","HASH_ALGORITHM","module","exports","randomBytes","privateKeyLength","generateKey","privateKey","privateKeyVerify","hashAndSign","key","msg","digest","sig","ecdsaSign","signatureExport","signature","hashAndVerify","signatureImport","ecdsaVerify","compressPublicKey","publicKeyVerify","Error","publicKeyConvert","decompressPublicKey","validatePrivateKey","validatePublicKey","computePublicKey","publicKeyCreate"],"mappings":"AAAA;;AAEA,MAAMA,SAAS,GAAGC,OAAO,CAAC,WAAD,CAAzB;;AACA,MAAMC,GAAG,GAAGD,OAAO,CAAC,4BAAD,CAAnB;;AACA,MAAME,cAAc,GAAG,UAAvB;;AAEAC,MAAM,CAACC,OAAP,GAAkBC,WAAD,IAAiB;AAChC,QAAMC,gBAAgB,GAAG,EAAzB;;AAEA,WAASC,WAAT,GAAwB;AACtB,QAAIC,UAAJ;;AACA,OAAG;AACDA,MAAAA,UAAU,GAAGH,WAAW,CAAC,EAAD,CAAxB;AACD,KAFD,QAES,CAACN,SAAS,CAACU,gBAAV,CAA2BD,UAA3B,CAFV;;AAGA,WAAOA,UAAP;AACD;;AAED,iBAAeE,WAAf,CAA4BC,GAA5B,EAAiCC,GAAjC,EAAsC;AACpC,UAAMC,MAAM,GAAG,MAAMZ,GAAG,CAACY,MAAJ,CAAWD,GAAX,EAAgBV,cAAhB,CAArB;AACA,UAAMY,GAAG,GAAGf,SAAS,CAACgB,SAAV,CAAoBF,MAApB,EAA4BF,GAA5B,CAAZ;AACA,WAAOZ,SAAS,CAACiB,eAAV,CAA0BF,GAAG,CAACG,SAA9B,CAAP;AACD;;AAED,iBAAeC,aAAf,CAA8BP,GAA9B,EAAmCG,GAAnC,EAAwCF,GAAxC,EAA6C;AAC3C,UAAMC,MAAM,GAAG,MAAMZ,GAAG,CAACY,MAAJ,CAAWD,GAAX,EAAgBV,cAAhB,CAArB;AACAY,IAAAA,GAAG,GAAGf,SAAS,CAACoB,eAAV,CAA0BL,GAA1B,CAAN;AACA,WAAOf,SAAS,CAACqB,WAAV,CAAsBN,GAAtB,EAA2BD,MAA3B,EAAmCF,GAAnC,CAAP;AACD;;AAED,WAASU,iBAAT,CAA4BV,GAA5B,EAAiC;AAC/B,QAAI,CAACZ,SAAS,CAACuB,eAAV,CAA0BX,GAA1B,CAAL,EAAqC;AACnC,YAAM,IAAIY,KAAJ,CAAU,oBAAV,CAAN;AACD;;AACD,WAAOxB,SAAS,CAACyB,gBAAV,CAA2Bb,GAA3B,EAAgC,IAAhC,CAAP;AACD;;AAED,WAASc,mBAAT,CAA8Bd,GAA9B,EAAmC;AACjC,WAAOZ,SAAS,CAACyB,gBAAV,CAA2Bb,GAA3B,EAAgC,KAAhC,CAAP;AACD;;AAED,WAASe,kBAAT,CAA6Bf,GAA7B,EAAkC;AAChC,QAAI,CAACZ,SAAS,CAACU,gBAAV,CAA2BE,GAA3B,CAAL,EAAsC;AACpC,YAAM,IAAIY,KAAJ,CAAU,qBAAV,CAAN;AACD;AACF;;AAED,WAASI,iBAAT,CAA4BhB,GAA5B,EAAiC;AAC/B,QAAI,CAACZ,SAAS,CAACuB,eAAV,CAA0BX,GAA1B,CAAL,EAAqC;AACnC,YAAM,IAAIY,KAAJ,CAAU,oBAAV,CAAN;AACD;AACF;;AAED,WAASK,gBAAT,CAA2BpB,UAA3B,EAAuC;AACrCkB,IAAAA,kBAAkB,CAAClB,UAAD,CAAlB;AACA,WAAOT,SAAS,CAAC8B,eAAV,CAA0BrB,UAA1B,CAAP;AACD;;AAED,SAAO;AACLD,IAAAA,WADK;AAELD,IAAAA,gBAFK;AAGLI,IAAAA,WAHK;AAILQ,IAAAA,aAJK;AAKLG,IAAAA,iBALK;AAMLI,IAAAA,mBANK;AAOLC,IAAAA,kBAPK;AAQLC,IAAAA,iBARK;AASLC,IAAAA;AATK,GAAP;AAWD,CA9DD","sourcesContent":["'use strict'\n\nconst secp256k1 = require('secp256k1')\nconst sha = require('multihashing-async/src/sha')\nconst HASH_ALGORITHM = 'sha2-256'\n\nmodule.exports = (randomBytes) => {\n  const privateKeyLength = 32\n\n  function generateKey () {\n    let privateKey\n    do {\n      privateKey = randomBytes(32)\n    } while (!secp256k1.privateKeyVerify(privateKey))\n    return privateKey\n  }\n\n  async function hashAndSign (key, msg) {\n    const digest = await sha.digest(msg, HASH_ALGORITHM)\n    const sig = secp256k1.ecdsaSign(digest, key)\n    return secp256k1.signatureExport(sig.signature)\n  }\n\n  async function hashAndVerify (key, sig, msg) {\n    const digest = await sha.digest(msg, HASH_ALGORITHM)\n    sig = secp256k1.signatureImport(sig)\n    return secp256k1.ecdsaVerify(sig, digest, key)\n  }\n\n  function compressPublicKey (key) {\n    if (!secp256k1.publicKeyVerify(key)) {\n      throw new Error('Invalid public key')\n    }\n    return secp256k1.publicKeyConvert(key, true)\n  }\n\n  function decompressPublicKey (key) {\n    return secp256k1.publicKeyConvert(key, false)\n  }\n\n  function validatePrivateKey (key) {\n    if (!secp256k1.privateKeyVerify(key)) {\n      throw new Error('Invalid private key')\n    }\n  }\n\n  function validatePublicKey (key) {\n    if (!secp256k1.publicKeyVerify(key)) {\n      throw new Error('Invalid public key')\n    }\n  }\n\n  function computePublicKey (privateKey) {\n    validatePrivateKey(privateKey)\n    return secp256k1.publicKeyCreate(privateKey)\n  }\n\n  return {\n    generateKey,\n    privateKeyLength,\n    hashAndSign,\n    hashAndVerify,\n    compressPublicKey,\n    decompressPublicKey,\n    validatePrivateKey,\n    validatePublicKey,\n    computePublicKey\n  }\n}\n"]},"metadata":{},"sourceType":"script"}