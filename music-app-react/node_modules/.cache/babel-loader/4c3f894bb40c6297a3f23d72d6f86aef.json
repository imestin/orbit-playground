{"ast":null,"code":"'use strict';\n\nconst Key = require('interface-datastore').Key;\n\nconst {\n  default: Queue\n} = require('p-queue');\n\nconst _get = require('just-safe-get');\n\nconst _set = require('just-safe-set');\n\nconst errcode = require('err-code');\n\nconst errors = require('./errors');\n\nconst uint8ArrayToString = require('uint8arrays/to-string');\n\nconst uint8ArrayFromString = require('uint8arrays/from-string');\n\nconst configKey = new Key('config');\n\nmodule.exports = store => {\n  const setQueue = new Queue({\n    concurrency: 1\n  });\n  const configStore = {\n    /**\n     * Get the current configuration from the repo.\n     *\n     * @param {Object} options - options\n     * @param {AbortSignal} options.signal - abort this config read\n     * @returns {Promise<Object>}\n     */\n    async getAll(options = {}) {\n      // eslint-disable-line require-await\n      return configStore.get(undefined, options);\n    },\n\n    /**\n     * Get the value for the passed configuration key from the repo.\n     *\n     * @param {String} key - the config key to get\n     * @param {Object} options - options\n     * @param {AbortSignal} options.signal - abort this config read\n     * @returns {Promise<Object>}\n     */\n    async get(key, options = {}) {\n      if (!key) {\n        key = undefined;\n      }\n\n      const encodedValue = await store.get(configKey);\n\n      if (options.signal && options.signal.aborted) {\n        return;\n      }\n\n      const config = JSON.parse(uint8ArrayToString(encodedValue));\n\n      if (key !== undefined && _get(config, key) === undefined) {\n        throw new errors.NotFoundError(`Key ${key} does not exist in config`);\n      }\n\n      const value = key !== undefined ? _get(config, key) : config;\n      return value;\n    },\n\n    /**\n     * Set the current configuration for this repo.\n     *\n     * @param {String} key - the config key to be written\n     * @param {Object} value - the config value to be written\n     * @param {Object} options - options\n     * @param {AbortSignal} options.signal - abort this config write\n     * @returns {void}\n     */\n    async set(key, value, options = {}) {\n      // eslint-disable-line require-await\n      if (arguments.length === 1) {\n        value = key;\n        key = undefined;\n      } else if (!key || typeof key !== 'string') {\n        throw errcode(new Error('Invalid key type: ' + typeof key), 'ERR_INVALID_KEY');\n      }\n\n      if (value === undefined || value instanceof Uint8Array) {\n        throw errcode(new Error('Invalid value type: ' + typeof value), 'ERR_INVALID_VALUE');\n      }\n\n      return setQueue.add(() => _maybeDoSet({\n        key: key,\n        value: value\n      }, options.signal));\n    },\n\n    /**\n     * Set the current configuration for this repo.\n     *\n     * @param {Object} value - the config value to be written\n     * @param {Object} options - options\n     * @param {AbortSignal} options.signal - abort this config write\n     * @returns {void}\n     */\n    async replace(value, options = {}) {\n      // eslint-disable-line require-await\n      if (!value || value instanceof Uint8Array) {\n        throw errcode(new Error('Invalid value type: ' + typeof value), 'ERR_INVALID_VALUE');\n      }\n\n      return setQueue.add(() => _maybeDoSet({\n        key: undefined,\n        value: value\n      }, options.signal));\n    },\n\n    /**\n     * Check if a config file exists.\n     *\n     * @returns {Promise<bool>}\n     */\n    async exists() {\n      // eslint-disable-line require-await\n      return store.has(configKey);\n    }\n\n  };\n  return configStore;\n\n  async function _maybeDoSet(m, signal) {\n    if (signal && signal.aborted) {\n      return;\n    }\n\n    const key = m.key;\n    const value = m.value;\n\n    if (key) {\n      const config = await configStore.get();\n\n      _set(config, key, value);\n\n      return _saveAll(config);\n    }\n\n    return _saveAll(value);\n  }\n\n  function _saveAll(config) {\n    const buf = uint8ArrayFromString(JSON.stringify(config, null, 2));\n    return store.put(configKey, buf);\n  }\n};","map":{"version":3,"sources":["/home/user/orbit-playground/music-app/node_modules/ipfs-repo/src/config.js"],"names":["Key","require","default","Queue","_get","_set","errcode","errors","uint8ArrayToString","uint8ArrayFromString","configKey","module","exports","store","setQueue","concurrency","configStore","getAll","options","get","undefined","key","encodedValue","signal","aborted","config","JSON","parse","NotFoundError","value","set","arguments","length","Error","Uint8Array","add","_maybeDoSet","replace","exists","has","m","_saveAll","buf","stringify","put"],"mappings":"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","sourcesContent":["'use strict'\n\nconst Key = require('interface-datastore').Key\nconst { default: Queue } = require('p-queue')\nconst _get = require('just-safe-get')\nconst _set = require('just-safe-set')\nconst errcode = require('err-code')\nconst errors = require('./errors')\nconst uint8ArrayToString = require('uint8arrays/to-string')\nconst uint8ArrayFromString = require('uint8arrays/from-string')\n\nconst configKey = new Key('config')\n\nmodule.exports = (store) => {\n  const setQueue = new Queue({ concurrency: 1 })\n\n  const configStore = {\n    /**\n     * Get the current configuration from the repo.\n     *\n     * @param {Object} options - options\n     * @param {AbortSignal} options.signal - abort this config read\n     * @returns {Promise<Object>}\n     */\n    async getAll (options = {}) { // eslint-disable-line require-await\n      return configStore.get(undefined, options)\n    },\n\n    /**\n     * Get the value for the passed configuration key from the repo.\n     *\n     * @param {String} key - the config key to get\n     * @param {Object} options - options\n     * @param {AbortSignal} options.signal - abort this config read\n     * @returns {Promise<Object>}\n     */\n    async get (key, options = {}) {\n      if (!key) {\n        key = undefined\n      }\n\n      const encodedValue = await store.get(configKey)\n\n      if (options.signal && options.signal.aborted) {\n        return\n      }\n\n      const config = JSON.parse(uint8ArrayToString(encodedValue))\n      if (key !== undefined && _get(config, key) === undefined) {\n        throw new errors.NotFoundError(`Key ${key} does not exist in config`)\n      }\n\n      const value = key !== undefined ? _get(config, key) : config\n      return value\n    },\n\n    /**\n     * Set the current configuration for this repo.\n     *\n     * @param {String} key - the config key to be written\n     * @param {Object} value - the config value to be written\n     * @param {Object} options - options\n     * @param {AbortSignal} options.signal - abort this config write\n     * @returns {void}\n     */\n    async set (key, value, options = {}) { // eslint-disable-line require-await\n      if (arguments.length === 1) {\n        value = key\n        key = undefined\n      } else if (!key || typeof key !== 'string') {\n        throw errcode(new Error('Invalid key type: ' + typeof key), 'ERR_INVALID_KEY')\n      }\n\n      if (value === undefined || (value instanceof Uint8Array)) {\n        throw errcode(new Error('Invalid value type: ' + typeof value), 'ERR_INVALID_VALUE')\n      }\n\n      return setQueue.add(() => _maybeDoSet({\n        key: key,\n        value: value\n      }, options.signal))\n    },\n\n    /**\n     * Set the current configuration for this repo.\n     *\n     * @param {Object} value - the config value to be written\n     * @param {Object} options - options\n     * @param {AbortSignal} options.signal - abort this config write\n     * @returns {void}\n     */\n    async replace (value, options = {}) { // eslint-disable-line require-await\n      if (!value || (value instanceof Uint8Array)) {\n        throw errcode(new Error('Invalid value type: ' + typeof value), 'ERR_INVALID_VALUE')\n      }\n\n      return setQueue.add(() => _maybeDoSet({\n        key: undefined,\n        value: value\n      }, options.signal))\n    },\n\n    /**\n     * Check if a config file exists.\n     *\n     * @returns {Promise<bool>}\n     */\n    async exists () { // eslint-disable-line require-await\n      return store.has(configKey)\n    }\n  }\n\n  return configStore\n\n  async function _maybeDoSet (m, signal) {\n    if (signal && signal.aborted) {\n      return\n    }\n\n    const key = m.key\n    const value = m.value\n    if (key) {\n      const config = await configStore.get()\n      _set(config, key, value)\n      return _saveAll(config)\n    }\n    return _saveAll(value)\n  }\n\n  function _saveAll (config) {\n    const buf = uint8ArrayFromString(JSON.stringify(config, null, 2))\n    return store.put(configKey, buf)\n  }\n}\n"]},"metadata":{},"sourceType":"script"}