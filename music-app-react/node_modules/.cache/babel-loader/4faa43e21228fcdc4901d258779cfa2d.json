{"ast":null,"code":"'use strict';\n\nconst errcode = require('err-code');\n\nconst debug = require('debug');\n\nconst log = debug('libp2p:peer-store');\nlog.error = debug('libp2p:peer-store:error');\n\nconst {\n  EventEmitter\n} = require('events');\n\nconst PeerId = require('peer-id');\n\nconst AddressBook = require('./address-book');\n\nconst KeyBook = require('./key-book');\n\nconst MetadataBook = require('./metadata-book');\n\nconst ProtoBook = require('./proto-book');\n\nconst {\n  ERR_INVALID_PARAMETERS\n} = require('../errors');\n/**\n * Responsible for managing known peers, as well as their addresses, protocols and metadata.\n * @fires PeerStore#peer Emitted when a new peer is added.\n * @fires PeerStore#change:protocols Emitted when a known peer supports a different set of protocols.\n * @fires PeerStore#change:multiaddrs Emitted when a known peer has a different set of multiaddrs.\n * @fires PeerStore#change:pubkey Emitted emitted when a peer's public key is known.\n * @fires PeerStore#change:metadata Emitted when the known metadata of a peer change.\n */\n\n\nclass PeerStore extends EventEmitter {\n  /**\n   * Peer object\n   * @typedef {Object} Peer\n   * @property {PeerId} id peer's peer-id instance.\n   * @property {Array<Address>} addresses peer's addresses containing its multiaddrs and metadata.\n   * @property {Array<string>} protocols peer's supported protocols.\n   * @property {Map<string, Buffer>} metadata peer's metadata map.\n   */\n\n  /**\n   * @constructor\n   */\n  constructor({\n    peerId\n  }) {\n    super();\n    this._peerId = peerId;\n    /**\n     * AddressBook containing a map of peerIdStr to Address.\n     */\n\n    this.addressBook = new AddressBook(this);\n    /**\n     * KeyBook containing a map of peerIdStr to their PeerId with public keys.\n     */\n\n    this.keyBook = new KeyBook(this);\n    /**\n     * MetadataBook containing a map of peerIdStr to their metadata Map.\n     */\n\n    this.metadataBook = new MetadataBook(this);\n    /**\n     * ProtoBook containing a map of peerIdStr to supported protocols.\n     */\n\n    this.protoBook = new ProtoBook(this);\n  }\n  /**\n   * Start the PeerStore.\n   */\n\n\n  start() {}\n  /**\n   * Stop the PeerStore.\n   */\n\n\n  stop() {}\n  /**\n   * Get all the stored information of every peer known.\n   * @returns {Map<string, Peer>}\n   */\n\n\n  get peers() {\n    const storedPeers = new Set([...this.addressBook.data.keys(), ...this.keyBook.data.keys(), ...this.protoBook.data.keys(), ...this.metadataBook.data.keys()]); // Remove self peer if present\n\n    this._peerId && storedPeers.delete(this._peerId.toB58String());\n    const peersData = new Map();\n    storedPeers.forEach(idStr => {\n      peersData.set(idStr, this.get(PeerId.createFromCID(idStr)));\n    });\n    return peersData;\n  }\n  /**\n   * Delete the information of the given peer in every book.\n   * @param {PeerId} peerId\n   * @returns {boolean} true if found and removed\n   */\n\n\n  delete(peerId) {\n    const addressesDeleted = this.addressBook.delete(peerId);\n    const keyDeleted = this.keyBook.delete(peerId);\n    const protocolsDeleted = this.protoBook.delete(peerId);\n    const metadataDeleted = this.metadataBook.delete(peerId);\n    return addressesDeleted || keyDeleted || protocolsDeleted || metadataDeleted;\n  }\n  /**\n   * Get the stored information of a given peer.\n   * @param {PeerId} peerId\n   * @returns {Peer}\n   */\n\n\n  get(peerId) {\n    if (!PeerId.isPeerId(peerId)) {\n      throw errcode(new Error('peerId must be an instance of peer-id'), ERR_INVALID_PARAMETERS);\n    }\n\n    const id = this.keyBook.data.get(peerId.toB58String());\n    const addresses = this.addressBook.get(peerId);\n    const metadata = this.metadataBook.get(peerId);\n    const protocols = this.protoBook.get(peerId);\n\n    if (!id && !addresses && !metadata && !protocols) {\n      return undefined;\n    }\n\n    return {\n      id: id || peerId,\n      addresses: addresses || [],\n      protocols: protocols || [],\n      metadata: metadata\n    };\n  }\n\n}\n\nmodule.exports = PeerStore;","map":{"version":3,"sources":["/home/user/orbit-playground/music-app/node_modules/libp2p/src/peer-store/index.js"],"names":["errcode","require","debug","log","error","EventEmitter","PeerId","AddressBook","KeyBook","MetadataBook","ProtoBook","ERR_INVALID_PARAMETERS","PeerStore","constructor","peerId","_peerId","addressBook","keyBook","metadataBook","protoBook","start","stop","peers","storedPeers","Set","data","keys","delete","toB58String","peersData","Map","forEach","idStr","set","get","createFromCID","addressesDeleted","keyDeleted","protocolsDeleted","metadataDeleted","isPeerId","Error","id","addresses","metadata","protocols","undefined","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst errcode = require('err-code')\nconst debug = require('debug')\nconst log = debug('libp2p:peer-store')\nlog.error = debug('libp2p:peer-store:error')\n\nconst { EventEmitter } = require('events')\nconst PeerId = require('peer-id')\n\nconst AddressBook = require('./address-book')\nconst KeyBook = require('./key-book')\nconst MetadataBook = require('./metadata-book')\nconst ProtoBook = require('./proto-book')\n\nconst {\n  ERR_INVALID_PARAMETERS\n} = require('../errors')\n\n/**\n * Responsible for managing known peers, as well as their addresses, protocols and metadata.\n * @fires PeerStore#peer Emitted when a new peer is added.\n * @fires PeerStore#change:protocols Emitted when a known peer supports a different set of protocols.\n * @fires PeerStore#change:multiaddrs Emitted when a known peer has a different set of multiaddrs.\n * @fires PeerStore#change:pubkey Emitted emitted when a peer's public key is known.\n * @fires PeerStore#change:metadata Emitted when the known metadata of a peer change.\n */\nclass PeerStore extends EventEmitter {\n  /**\n   * Peer object\n   * @typedef {Object} Peer\n   * @property {PeerId} id peer's peer-id instance.\n   * @property {Array<Address>} addresses peer's addresses containing its multiaddrs and metadata.\n   * @property {Array<string>} protocols peer's supported protocols.\n   * @property {Map<string, Buffer>} metadata peer's metadata map.\n   */\n\n  /**\n   * @constructor\n   */\n  constructor ({ peerId }) {\n    super()\n\n    this._peerId = peerId\n\n    /**\n     * AddressBook containing a map of peerIdStr to Address.\n     */\n    this.addressBook = new AddressBook(this)\n\n    /**\n     * KeyBook containing a map of peerIdStr to their PeerId with public keys.\n     */\n    this.keyBook = new KeyBook(this)\n\n    /**\n     * MetadataBook containing a map of peerIdStr to their metadata Map.\n     */\n    this.metadataBook = new MetadataBook(this)\n\n    /**\n     * ProtoBook containing a map of peerIdStr to supported protocols.\n     */\n    this.protoBook = new ProtoBook(this)\n  }\n\n  /**\n   * Start the PeerStore.\n   */\n  start () {}\n\n  /**\n   * Stop the PeerStore.\n   */\n  stop () {}\n\n  /**\n   * Get all the stored information of every peer known.\n   * @returns {Map<string, Peer>}\n   */\n  get peers () {\n    const storedPeers = new Set([\n      ...this.addressBook.data.keys(),\n      ...this.keyBook.data.keys(),\n      ...this.protoBook.data.keys(),\n      ...this.metadataBook.data.keys()\n    ])\n\n    // Remove self peer if present\n    this._peerId && storedPeers.delete(this._peerId.toB58String())\n\n    const peersData = new Map()\n    storedPeers.forEach((idStr) => {\n      peersData.set(idStr, this.get(PeerId.createFromCID(idStr)))\n    })\n\n    return peersData\n  }\n\n  /**\n   * Delete the information of the given peer in every book.\n   * @param {PeerId} peerId\n   * @returns {boolean} true if found and removed\n   */\n  delete (peerId) {\n    const addressesDeleted = this.addressBook.delete(peerId)\n    const keyDeleted = this.keyBook.delete(peerId)\n    const protocolsDeleted = this.protoBook.delete(peerId)\n    const metadataDeleted = this.metadataBook.delete(peerId)\n\n    return addressesDeleted || keyDeleted || protocolsDeleted || metadataDeleted\n  }\n\n  /**\n   * Get the stored information of a given peer.\n   * @param {PeerId} peerId\n   * @returns {Peer}\n   */\n  get (peerId) {\n    if (!PeerId.isPeerId(peerId)) {\n      throw errcode(new Error('peerId must be an instance of peer-id'), ERR_INVALID_PARAMETERS)\n    }\n\n    const id = this.keyBook.data.get(peerId.toB58String())\n    const addresses = this.addressBook.get(peerId)\n    const metadata = this.metadataBook.get(peerId)\n    const protocols = this.protoBook.get(peerId)\n\n    if (!id && !addresses && !metadata && !protocols) {\n      return undefined\n    }\n\n    return {\n      id: id || peerId,\n      addresses: addresses || [],\n      protocols: protocols || [],\n      metadata: metadata\n    }\n  }\n}\n\nmodule.exports = PeerStore\n"]},"metadata":{},"sourceType":"script"}